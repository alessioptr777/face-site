<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Tenerife Stars Pictures - Find your photos</title>
  <style>
    :root{
      --bg-dark: #0a0e27;
      --bg-dark2: #1a1f3a;
      --bg-gradient: linear-gradient(180deg, #1a1f3a 0%, #0a0e27 100%);
      --text-light: #ffffff;
      --text-muted: #a0a8c0;
      --accent: #6366f1;
      --accent-light: #818cf8;
      --purple: #a855f7;
      --pink: #ec4899;
      --radius: 16px;
      --shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    *{box-sizing:border-box; margin:0; padding:0}
    html, body{
      margin:0;
      padding:0;
      height: 100%;
      overflow: hidden;
    }
    body{
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;
      color:var(--text-light);
      height: 100dvh;
      height: 100vh; /* Fallback per browser che non supportano dvh */
      background: var(--bg-gradient);
      overflow: hidden;
      position: fixed;
      width: 100%;
    }
    
    /* Utility */
    .screen{
      height: 100dvh;
      height: 100vh; /* Fallback */
      display: none;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    .screen.active{
      display: flex;
    }
    
    /* Language Selection Screen */
    .language-screen{
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }
    
    .language-title{
      font-size: 28px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 10px;
    }
    
    .language-subtitle{
      font-size: 16px;
      color: var(--text-muted);
      margin-bottom: 40px;
    }
    
    .language-grid{
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      max-width: 400px;
      width: 100%;
      margin: 0 auto;
    }
    
    .language-option{
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    
    .language-option:hover{
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--accent);
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(99, 102, 241, 0.3);
    }
    
    .language-flag{
      font-size: 48px;
      line-height: 1;
    }
    
    .language-name{
      font-size: 18px;
      font-weight: 600;
      color: var(--text-light);
    }
    
    /* Email Screen */
    .email-screen{
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }
    
    .email-title{
      font-size: 28px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 10px;
    }
    
    .email-subtitle{
      font-size: 16px;
      color: var(--text-muted);
      margin-bottom: 30px;
    }
    
    .email-input-container{
      max-width: 400px;
      width: 100%;
      margin: 0 auto 30px;
    }
    
    .email-input{
      width: 100%;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      color: var(--text-light);
      font-size: 16px;
      transition: all 0.3s ease;
    }
    
    .email-input:focus{
      outline: none;
      border-color: var(--accent);
      background: rgba(255, 255, 255, 0.08);
    }
    
    .email-input::placeholder{
      color: var(--text-muted);
    }
    
    .email-error{
      color: #ff4444;
      font-size: 14px;
      margin-top: 10px;
      display: none;
    }
    
    .email-error.show{
      display: block;
    }
    
    .email-loading{
      margin-top: 20px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    
    .email-loading p{
      color: var(--text-muted);
      font-size: 14px;
      margin: 0;
    }
    
    .loading-spinner{
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin{
      to { transform: rotate(360deg); }
    }
    
    /* Welcome Screen */
    .welcome-screen{
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }
    
    .welcome-icon{
      width: 120px;
      height: 120px;
      margin-bottom: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .welcome-icon svg{
      width: 100%;
      height: 100%;
      stroke: var(--accent-light);
      fill: none;
      stroke-width: 2;
    }
    
    .welcome-title{
      font-size: 32px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 20px;
    }
    
    .welcome-text{
      font-size: 16px;
      color: var(--text-muted);
      line-height: 1.6;
      max-width: 400px;
      margin: 0 auto 40px;
    }
    
    .welcome-privacy{
      font-size: 14px;
      color: var(--text-muted);
      max-width: 400px;
      margin: 20px auto 0;
    }
    
    .btn-primary{
      background: linear-gradient(135deg, var(--accent) 0%, var(--purple) 100%);
      color: white;
      border: none;
      padding: 16px 48px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .btn-primary:active{
      transform: scale(0.98);
    }
    
    /* Selfie Screen */
    .selfie-screen{
      padding: 10px;
      overflow: hidden;
    }
    
    .selfie-header{
      flex-shrink: 0;
      padding: 10px 0;
      text-align: center;
    }
    
    .selfie-header h2{
      font-size: 20px;
      font-weight: 600;
      color: var(--text-light);
      margin: 0;
    }
    
    .selfie-preview{
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      min-height: 0; /* Importante per flex */
      overflow: hidden;
    }
    
    .selfie-video{
      width: 100%;
      max-width: 100%;
      aspect-ratio: 3 / 4; /* Aspect ratio fisso 3:4 verticale */
      border-radius: 16px;
      overflow: hidden;
      background: #000;
      flex-shrink: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .selfie-video video{
      width: 100%;
      height: 100%;
      object-fit: cover; /* Copre tutto il contenitore senza bande nere */
      display: block;
      object-position: center center; /* Centra verticalmente sul volto */
    }
    
    .selfie-controls{
      flex-shrink: 0;
      margin-top: 15px;
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    
    /* Upload Status Area - sempre visibile */
    .upload-status{
      flex-shrink: 0;
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.3);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: none;
      flex-direction: column;
      gap: 8px;
    }
    
    .upload-status.active{
      display: flex;
    }
    
    .upload-status-text{
      font-size: 14px;
      color: var(--text-light);
      text-align: center;
      font-weight: 500;
    }
    
    .upload-progress-container{
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }
    
    .upload-progress-bar{
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--purple));
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 3px;
    }
    
    .upload-percentage{
      font-size: 12px;
      color: var(--text-muted);
      text-align: center;
    }
    
    /* Selfie Error Box */
    .selfie-error-box{
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }
    
    .selfie-error-content{
      background: var(--bg-dark);
      border-radius: 16px;
      padding: 32px 24px;
      max-width: 400px;
      width: 100%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .selfie-error-message{
      font-size: 16px;
      color: var(--text-light);
      margin: 0 0 24px 0;
      line-height: 1.5;
    }
    
    .btn-retake-selfie{
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 14px 28px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      transition: all 0.2s ease;
    }
    
    .btn-retake-selfie:hover{
      background: var(--accent-hover);
      transform: translateY(-1px);
    }
    
    .btn-retake-selfie:active{
      transform: translateY(0);
    }
    
    .upload-spinner{
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }
    
    .camera-btn{
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: white;
      border: 4px solid var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    .camera-btn svg{
      width: 40px;
      height: 40px;
      stroke: var(--accent);
      stroke-width: 2;
    }
    
    /* Confirm Selfie Screen */
    .confirm-screen{
      padding: 10px 20px;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .confirm-title{
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 30px;
      text-align: center;
    }
    
    .confirm-preview{
      width: 100%;
      max-width: 300px;
      aspect-ratio: 3 / 4; /* Stesso aspect ratio del selfie catturato */
      border-radius: 20px;
      overflow: hidden;
      margin-bottom: 15px;
      box-shadow: var(--shadow);
      flex-shrink: 1;
      background: #000;
    }
    
    .confirm-preview img{
      width: 100%;
      height: 100%;
      object-fit: cover; /* Stesso comportamento del video */
      object-position: center center;
      display: block;
    }
    
    .confirm-privacy{
      max-width: 400px;
      text-align: center;
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 30px;
      line-height: 1.6;
    }
    
    .confirm-privacy a{
      color: var(--accent-light);
      text-decoration: underline;
    }
    
    .confirm-buttons{
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      max-width: 400px;
    }
    
    .btn-confirm{
      background: var(--accent);
      color: white;
      border: none;
      padding: 16px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .btn-retake{
      background: transparent;
      color: var(--text-light);
      border: 2px solid var(--text-muted);
      padding: 16px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }
    
    /* Add People Screen */
    .add-people-screen{
      padding: 40px 20px;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    
    .add-people-title{
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 30px;
    }
    
    .people-list{
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 40px;
      flex-wrap: wrap;
    }
    
    .person-avatar{
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--bg-dark2);
      border: 3px solid var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .person-avatar img{
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .add-person-btn{
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 32px;
      color: white;
    }
    
    .add-people-buttons{
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      max-width: 400px;
    }
    
    /* Album Screen */
    .album-screen{
      padding: 0;
      overflow-y: auto; /* Permetti scroll verticale */
      -webkit-overflow-scrolling: touch; /* Smooth scroll su iOS */
    }
    
    .album-header{
      position: sticky;
      top: 0;
      background: var(--bg-dark2);
      padding: 16px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      z-index: 999; /* Sotto il banner sticky ma sopra il contenuto */
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .album-back{
      background: none;
      border: none;
      color: var(--text-light);
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
    }
    
    .album-cart{
      background: var(--accent);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }
    
    .album-profile{
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .profile-avatar{
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-dark2);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .profile-avatar img{
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .profile-info h3{
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 2px;
      line-height: 1.2;
    }
    
    .profile-info p{
      font-size: 11px;
      color: var(--text-muted);
      line-height: 1.3;
      margin: 0;
    }
    
    .album-tabs{
      display: flex;
      padding: 0 20px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .album-tab{
      background: none;
      border: none;
      color: var(--text-muted);
      padding: 16px 20px;
      font-size: 16px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: color 0.2s, border-color 0.2s;
    }
    
    .album-tab.active{
      color: var(--accent-light);
      border-bottom-color: var(--accent-light);
    }
    
    .album-tab:hover{
      color: var(--text-light);
    }
    
    /* Listino prezzi */
    .prices-list{
      display: none;
      padding: 15px 20px;
      padding-bottom: calc(80px + env(safe-area-inset-bottom)); /* Spazio per banner sticky */
      max-width: 600px;
      margin: 0 auto;
      max-height: calc(100vh - 200px); /* Altezza massima per evitare overflow */
      overflow-y: auto;
    }
    
    .prices-list.active{
      display: block;
    }
    
    .prices-title{
      font-size: 20px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 8px;
      text-align: center;
    }
    
    .prices-subtitle{
      font-size: 12px;
      color: var(--text-muted);
      text-align: center;
      margin-bottom: 12px;
    }
    
    .price-item{
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      margin-bottom: 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: background 0.2s, transform 0.2s;
    }
    
    .price-item:hover{
      background: rgba(255, 255, 255, 0.08);
      transform: translateX(4px);
    }
    
    .price-item.highlight{
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.2) 0%, rgba(236, 72, 153, 0.2) 100%);
      border-color: var(--purple);
    }
    
    .price-item-info{
      flex: 1;
    }
    
    .price-item-count{
      font-size: 15px;
      font-weight: 600;
      color: var(--text-light);
      margin-bottom: 2px;
    }
    
    .price-item-desc{
      font-size: 11px;
      color: var(--text-muted);
    }
    
    .price-item-value{
      font-size: 20px;
      font-weight: 700;
      color: var(--accent-light);
    }
    
    .price-item-badge{
      display: inline-block;
      background: var(--purple);
      color: white;
      font-size: 10px;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      margin-left: 8px;
      text-transform: uppercase;
    }
    
    .album-tab.active{
      color: var(--text-light);
      border-bottom-color: var(--accent);
    }
    
    .album-grid{
      padding: 20px;
      padding-bottom: calc(100px + env(safe-area-inset-bottom)); /* Spazio per il CTA fisso + safe area iPhone */
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 20px;
    }
    
    .album-photo{
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      aspect-ratio: 1;
      background: var(--bg-dark2);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .album-photo:active{
      transform: scale(0.98);
    }
    
    .album-photo img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .album-photo img.loaded{
      opacity: 1;
    }
    
    .album-photo .photo-skeleton{
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(255,255,255,0.05) 0%, 
        rgba(255,255,255,0.1) 50%, 
        rgba(255,255,255,0.05) 100%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s ease-in-out infinite;
    }
    
    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    .album-loading-overlay{
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(4px);
    }
    
    .album-loading-overlay.active{
      display: flex;
    }
    
    .album-loading-content{
      text-align: center;
      color: white;
    }
    
    .album-loading-spinner{
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255,255,255,0.3);
      border-top-color: var(--purple);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    .album-photo {
      position: relative;
    }
    
    .add-to-cart-btn{
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 5;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 34px;
      height: 34px;
      min-width: 34px;
      min-height: 34px;
      border-radius: 50%;
      border: 5px solid rgb(76, 175, 80); /* Bordo verde spesso - stesso colore del badge "Pagata" */
      background: rgba(76, 175, 80, 0.5); /* Sfondo verde trasparente al 50% */
      font-weight: 800;
      font-size: 18px;
      line-height: 1;
      color: #fff; /* "+" bianco */
      box-shadow: 0 2px 8px rgba(0,0,0,.25);
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      transition: transform 160ms ease, background-color 160ms ease, border-color 160ms ease, box-shadow 160ms ease;
      user-select: none;
    }
    
    /* Desktop: dimensioni leggermente pi√π grandi */
    @media (min-width: 768px) {
      .add-to-cart-btn{
        width: 36px;
        height: 36px;
        min-width: 36px;
        min-height: 36px;
      }
    }
    
    .add-to-cart-btn:active{
      transform: scale(0.95);
    }
    
    .add-to-cart-btn .btn-icon{
      display: inline-block;
      font-weight: 800;
      font-size: 18px;
    }
    
    .add-to-cart-btn .btn-check{
      display: none;
      color: #fff; /* "‚úì" bianca quando √® nel carrello */
      font-weight: 800;
      font-size: 20px;
    }
    
    /* Stato: FOTO NEL carrello - cerchio pieno verde con ‚úì bianca */
    .add-to-cart-btn.is-added{
      background: rgb(76, 175, 80); /* Cerchio pieno verde - stesso colore del badge "Pagata" */
      border-color: rgb(76, 175, 80);
      box-shadow: 0 2px 8px rgba(0,0,0,.3);
    }
    
    .add-to-cart-btn.is-added .btn-icon{
      display: none;
    }
    
    .add-to-cart-btn.is-added .btn-check{
      display: inline-block;
    }
    
    /* Animazione "pop" quando cambia stato */
    @keyframes cartPop {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.12);
      }
      100% {
        transform: scale(1);
      }
    }
    
    .add-to-cart-btn.pop{
      animation: cartPop 160ms ease;
    }
    
    .album-buy-all{
      margin: 20px;
      background: linear-gradient(135deg, var(--purple) 0%, var(--pink) 100%);
      color: white;
      border: none;
      padding: 20px;
      border-radius: 16px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 4px 20px rgba(168, 85, 247, 0.4);
    }
    
    .album-buy-all .price{
      font-size: 24px;
    }
    
    .album-buy-all .subtitle{
      font-size: 14px;
      opacity: 0.9;
      margin-top: 4px;
    }
    
    /* Modal styles */
    .ios-share-modal{
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .ios-share-modal.active{
      opacity: 1;
      visibility: visible;
    }
    
    .ios-share-modal-content{
      background: var(--bg-dark2);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Sticky Offer Bar */
    .sticky-offer-bar{
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, var(--purple) 0%, var(--pink) 100%);
      padding: 8px 12px;
      padding-bottom: calc(8px + env(safe-area-inset-bottom)); /* Safe area iPhone */
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
      z-index: 1000; /* Z-index pi√π alto per essere sopra tutto */
      display: none;
      transform: translateY(100%);
      transition: transform 0.3s ease-out;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      /* Assicura che rimanga fisso durante lo scroll con accelerazione hardware */
      will-change: transform;
      -webkit-transform: translateZ(0);
      transform: translateZ(0) translateY(100%);
      min-height: 60px; /* Altezza minima ridotta */
    }
    
    .sticky-offer-bar.active{
      transform: translateZ(0) translateY(0);
    }
    
    /* Mostra solo quando lo schermo album √® attivo */
    .album-screen.active ~ .sticky-offer-bar.active,
    body:has(.album-screen.active) .sticky-offer-bar.active{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      animation: slideUp 0.4s ease-out forwards;
    }
    
    @keyframes slideUp {
      from {
        transform: translateY(100%);
      }
      to {
        transform: translateY(0);
      }
    }
    
    .sticky-offer-content{
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .sticky-offer-text{
      font-size: 12px;
      font-weight: 600;
      color: white;
      line-height: 1.2;
    }
    
    .sticky-offer-price{
      font-size: 16px;
      font-weight: 700;
      color: white;
    }
    
    .sticky-offer-actions{
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .sticky-offer-btn{
      background: white;
      color: var(--purple);
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      transition: transform 0.2s, opacity 0.2s;
    }
    
    .sticky-offer-btn:active{
      transform: scale(0.95);
      opacity: 0.8;
    }
    
    .sticky-offer-close{
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      flex-shrink: 0;
      transition: background 0.2s;
    }
    
    .sticky-offer-close:active{
      background: rgba(255, 255, 255, 0.3);
    }
    
    /* Nudge Bar: suggerisce upgrade al prossimo scaglione */
    .nudge-bar{
      position: fixed;
      bottom: calc(80px + env(safe-area-inset-bottom) + 10px); /* Altezza sticky + safe area + 10px */
      left: 12px;
      right: 12px;
      max-width: 600px;
      margin: 0 auto;
      background: rgba(20, 20, 30, 0.95);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      z-index: 1200; /* Tra sticky (1000) e lightbox (2000) */
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    .nudge-bar.active{
      display: flex;
    }
    
    .nudge-content{
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    .nudge-text{
      flex: 1;
      font-size: 13px;
      line-height: 1.4;
      color: var(--text-light);
    }
    
    .nudge-text small{
      display: block;
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    
    .nudge-btn{
      background: linear-gradient(135deg, var(--accent) 0%, var(--purple) 100%);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      transition: transform 0.2s, opacity 0.2s;
      flex-shrink: 0;
    }
    
    .nudge-btn:active{
      transform: scale(0.95);
      opacity: 0.8;
    }
    
    /* Paid Photos Countdown Banner */
    .paid-countdown-banner{
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      padding: 12px 20px;
      z-index: 90;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }
    
    .paid-countdown-banner.show{
      transform: translateY(0);
    }
    
    .paid-countdown-content{
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      max-width: 1200px;
      margin: 0 auto;
      font-size: 14px;
      font-weight: 500;
    }
    
    .paid-countdown-icon{
      font-size: 18px;
    }
    
    .paid-countdown-text{
      text-align: center;
    }
    
    .paid-countdown-text strong{
      font-weight: 700;
      font-size: 16px;
    }
    
    /* Album photo count banner sopra la griglia */
    .album-photo-count{
      padding: 12px 20px;
      background: rgba(168, 85, 247, 0.1);
      border-bottom: 1px solid rgba(168, 85, 247, 0.2);
      text-align: center;
      font-size: 16px;
      font-weight: 600;
      color: var(--accent-light);
    }
  </style>
</head>
<body>
  <!-- Email Screen -->
  <div class="screen email-screen" id="emailScreen">
    <h1 class="email-title">ENTER YOUR EMAIL ‚úÖ LIVE TEST</h1>
    <p class="email-subtitle">Your email is required to save and recover your photos</p>
    <div class="email-input-container">
      <input type="email" class="email-input" id="emailInput" placeholder="your@email.com">
      <p class="email-error" id="emailError">Invalid email address</p>
        </div>
    <button class="btn-primary" id="emailContinueBtn">CONTINUE ‚úÖ LIVE</button>
    <div class="email-loading" id="emailLoading" style="display: none;">
      <div class="loading-spinner"></div>
      <p>Checking your photos...</p>
    </div>
      </div>

  <!-- Welcome Screen -->
  <div class="screen welcome-screen" id="welcomeScreen">
    <div class="welcome-icon">
      <svg viewBox="0 0 100 100">
        <rect x="20" y="25" width="60" height="50" rx="8"/>
        <circle cx="50" cy="45" r="12"/>
        <rect x="35" y="60" width="30" height="8" rx="4"/>
        <circle cx="70" cy="35" r="4"/>
      </svg>
        </div>
    <h1 class="welcome-title">Find your photos!</h1>
    <p class="welcome-text">
      Here is how it works: take a selfie and the system will find your photos. On the next step, you will be asked to allow camera access.
    </p>
    <button class="btn-primary" id="welcomeContinueBtn">Continue</button>
    <p class="welcome-privacy">
      We operate in full respect of Privacy and use your face exclusively to find photos that feature you.
    </p>
      </div>

  <!-- Selfie Screen -->
  <div class="screen selfie-screen" id="selfieScreen">
    <div class="selfie-header">
      <h2 id="selfieHeaderText">Take your selfie</h2>
    </div>
    <div class="selfie-preview">
      <div class="selfie-video">
        <video id="video" autoplay playsinline muted webkit-playsinline style="display:none;"></video>
        <canvas id="canvas" style="display:none;"></canvas>
        <div id="videoPlaceholder" style="display: none; text-align: center; padding: 20px; color: var(--text-muted);">
          <p style="font-size: 14px;">Camera not available</p>
          <button class="btn-primary" id="retryCameraBtn" style="margin-top: 15px; padding: 12px 24px; font-size: 14px;">Retry</button>
        </div>
        <div id="startCameraPrompt" style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px 20px; text-align: center; min-height: 300px;">
          <p style="font-size: 16px; color: var(--text-muted); margin-bottom: 20px;">Enable camera access to take your selfie</p>
          <button class="btn-primary" id="startCameraBtn" style="padding: 14px 28px; font-size: 16px;">Start Camera</button>
        </div>
      </div>
      <div class="selfie-controls">
        <button class="camera-btn" id="captureBtn" disabled>
          <svg viewBox="0 0 24 24" fill="none">
            <circle cx="12" cy="12" r="10"/>
          </svg>
        </button>
        <button class="btn-retake" id="switchCameraBtn" style="display:none;">Switch camera</button>
      </div>
    </div>
    <!-- Upload Status Area - sempre visibile quando attiva -->
    <div class="upload-status" id="uploadStatus">
      <div class="upload-status-text">
        <span class="upload-spinner"></span>
        <span id="uploadStatusText">Loading photos...</span>
      </div>
      <div class="upload-progress-container">
        <div class="upload-progress-bar" id="uploadProgressBar"></div>
      </div>
      <div class="upload-percentage" id="uploadPercentage">0%</div>
        </div>
      </div>
    
    <!-- Selfie Error Box - mostra errore quando match_selfie fallisce -->
    <div class="selfie-error-box" id="selfieErrorBox" style="display: none;">
      <div class="selfie-error-content">
        <p class="selfie-error-message" id="selfieErrorMessage">No photos found or still processing. Please try again.</p>
        <button class="btn-retake-selfie" id="retakeSelfieBtn">Retake selfie</button>
      </div>
    </div>

  <!-- Confirm Selfie Screen -->
  <div class="screen confirm-screen" id="confirmScreen">
    <h2 class="confirm-title">Confirm selfie</h2>
    <div class="confirm-preview">
      <img id="confirmPreview" alt="Selfie preview">
    </div>
    <p class="confirm-privacy">
      By selecting "Confirm" you consent to the processing of biometric data for the purposes of Detection and Recognition as per Privacy Policy.
    </p>
    <div class="confirm-buttons">
      <button class="btn-confirm" id="confirmBtn">Confirm</button>
      <button class="btn-retake" id="retakeBtn">Take again</button>
    </div>
    <!-- Loading indicator per ricerca foto -->
    <div id="confirmLoadingIndicator" style="display: none; text-align: center; margin-top: 20px;">
      <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: var(--purple); border-radius: 50%; animation: spin 1s linear infinite;"></div>
      <p style="color: var(--text-muted); margin-top: 15px;">Loading photos...</p>
    </div>
  </div>

  <!-- Add People Screen -->
  <div class="screen add-people-screen" id="addPeopleScreen">
    <h2 class="add-people-title">Great!</h2>
    <p style="color: var(--text-muted); margin-bottom: 30px;">Do you want to add family members to this album?</p>
    <div class="people-list" id="peopleList">
      <div class="person-avatar">
        <img id="mainPersonAvatar" alt="Persona principale">
      </div>
      <button class="add-person-btn" id="addPersonBtn">+</button>
    </div>
    <div class="add-people-buttons">
      <button class="btn-primary" id="addPersonConfirmBtn">Yes, add another person</button>
      <button class="btn-retake" id="skipAddPersonBtn">Not now, go to album</button>
    </div>
    <!-- Loading indicator -->
    <div id="loadingIndicator" style="display: none; text-align: center; margin-top: 20px;">
      <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: var(--purple); border-radius: 50%; animation: spin 1s linear infinite;"></div>
      <p style="color: var(--text-muted); margin-top: 15px;">Loading photos...</p>
    </div>
  </div>

  <!-- Album Screen -->
  <div class="screen album-screen" id="albumScreen">
    <div class="album-header">
      <button class="album-back" id="albumBackBtn">‚Üê</button>
      <button class="album-cart" id="albumCartBtn">
        üõí <span id="albumCartCount">0</span> - <span id="albumCartPrice">‚Ç¨0</span>
      </button>
      <button class="btn-primary" id="addFamilyBtn" style="padding: 8px 16px; font-size: 14px; margin-left: 10px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; border-radius: 20px;">
        üë• Add family member
        <span id="familyMembersCount" style="margin-left: 8px; font-size: 12px; opacity: 0.8;">(0/8)</span>
      </button>
    </div>
    <div class="album-profile">
      <div class="profile-avatar">
        <!-- Logo rimosso per evitare 404 - usa solo testo -->
      </div>
      <div class="profile-info">
        <h3>Tenerife Stars Pictures</h3>
        <p>Your photo session was taken by Metaproos</p>
      </div>
    </div>
    
    <!-- Sezione Membri -->
    <div id="familyMembersSection" style="padding: 0 20px 20px; margin-bottom: 20px; display: none;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 style="color: white; font-size: 18px; margin: 0;">Added members</h3>
        <button class="btn-primary" id="addMemberBtn" style="padding: 10px 20px; font-size: 14px;">
          üë• Add member
        </button>
      </div>
      <div id="familyMembersList" style="display: flex; flex-wrap: wrap; gap: 10px;">
        <!-- Membri verranno aggiunti qui -->
      </div>
    </div>
    <div class="album-tabs">
      <button class="album-tab active" id="myContentTab">My content</button>
      <button class="album-tab" id="pricesTab">Price list ‚Üó</button>
    </div>
    <div class="album-photo-count" id="albumPhotoCount" style="display: none;">
      <span>You found <span id="photoCountNumber">0</span> photos</span>
    </div>
    
    <!-- Listino Prezzi -->
    <div class="prices-list" id="pricesList">
      <h2 class="prices-title">Price List</h2>
      <p class="prices-subtitle">Choose the offer you prefer</p>
      
      <div class="price-item">
        <div class="price-item-info">
          <div class="price-item-count">1 <span>photo</span></div>
          <div class="price-item-desc">Single photo</div>
        </div>
        <div class="price-item-value">‚Ç¨25</div>
      </div>

      <div class="price-item">
        <div class="price-item-info">
          <div class="price-item-count">2 <span>photos</span></div>
          <div class="price-item-desc">Double</div>
        </div>
        <div class="price-item-value">‚Ç¨40</div>
      </div>
      
      <div class="price-item highlight">
        <div class="price-item-info">
          <div class="price-item-count">3 <span>photos</span> <span class="price-item-badge">Discount</span></div>
          <div class="price-item-desc">Special offer</div>
      </div>
        <div class="price-item-value">‚Ç¨35</div>
    </div>

      <div class="price-item">
        <div class="price-item-info">
          <div class="price-item-count">4 <span>photos</span></div>
          <div class="price-item-desc">Package</div>
        </div>
        <div class="price-item-value">‚Ç¨40</div>
      </div>
      
      <div class="price-item">
        <div class="price-item-info">
          <div class="price-item-count">5 <span >photos</span></div>
          <div class="price-item-desc" >Package</div>
        </div>
        <div class="price-item-value">‚Ç¨45</div>
      </div>
      
      <div class="price-item highlight">
        <div class="price-item-info">
          <div class="price-item-count">6-11 <span >photos</span> <span class="price-item-badge" >Best</span></div>
          <div class="price-item-desc" >Complete package</div>
        </div>
        <div class="price-item-value">‚Ç¨50</div>
      </div>
      
      <div class="price-item highlight">
        <div class="price-item-info">
          <div class="price-item-count">12+ <span >photos</span> <span class="price-item-badge" >Top</span></div>
          <div class="price-item-desc" >All photos at the best price</div>
        </div>
        <div class="price-item-value">‚Ç¨60</div>
      </div>
    </div>
    
    <div class="album-grid" id="albumGrid">
      <!-- Foto verranno aggiunte qui -->
    </div>
    
    <!-- Overlay caricamento album -->
    <div class="album-loading-overlay" id="albumLoadingOverlay">
      <div class="album-loading-content">
        <div class="album-loading-spinner"></div>
        <p id="albumLoadingText">Loading photos...</p>
      </div>
    </div>
    
  </div>
  
  <!-- Sticky Offer Bar -->
  <!-- Nudge Bar: suggerisce upgrade al prossimo scaglione -->
  <div class="nudge-bar" id="nudgeBar" style="display: none;">
    <div class="nudge-content">
      <div class="nudge-text" id="nudgeText"></div>
      <button class="nudge-btn" id="nudgeCheckoutBtn">Vai al checkout</button>
    </div>
  </div>
  
  <div class="sticky-offer-bar" id="stickyOfferBar">
      <div class="sticky-offer-content">
      <div class="sticky-offer-text" id="stickyOfferText">Prendile tutte</div>
      <div class="sticky-offer-price" id="stickyOfferPrice">‚Ç¨0</div>
    </div>
    <div class="sticky-offer-actions">
      <button class="sticky-offer-btn" id="stickyOfferBuyBtn">Sblocca tutte</button>
    </div>
  </div>
  
  <!-- Paid Photos Countdown Banner -->
  <div class="paid-countdown-banner" id="paidCountdownBanner" style="display: none;">
    <div class="paid-countdown-content">
      <span class="paid-countdown-icon">‚è∞</span>
      <span class="paid-countdown-text" id="paidCountdownText">Your paid photos will expire in <strong id="paidCountdownDays">30</strong> days</span>
    </div>
  </div>

  <!-- Lightbox per foto -->
  <div class="ios-share-modal" id="photoLightbox" style="z-index: 2000;">
    <div style="position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
      <button id="lightboxClose" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.6); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 24px; cursor: pointer; z-index: 10;">‚úï</button>
      <div style="position: absolute; top: 20px; left: 20px; color: white; font-size: 16px; z-index: 10; background: rgba(0,0,0,0.6); padding: 8px 16px; border-radius: 20px;" id="photoCounter">1/1</div>
      <button id="lightboxPrev" style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.6); color: white; border: none; width: 50px; height: 50px; border-radius: 50%; font-size: 24px; cursor: pointer; z-index: 10; display: none;">‚Üê</button>
      <button id="lightboxNext" style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.6); color: white; border: none; width: 50px; height: 50px; border-radius: 50%; font-size: 24px; cursor: pointer; z-index: 10; display: none;">‚Üí</button>
      <button id="lightboxDownload" style="position: absolute; bottom: 20px; right: 20px; background: rgba(123, 116, 255, 0.9); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; z-index: 10; display: none;">üì• Download</button>
      <div id="lightboxIOSInstruction" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.85); color: white; padding: 14px 20px; border-radius: 12px; font-size: 15px; font-weight: 500; text-align: center; z-index: 10; pointer-events: none; display: none; max-width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">üì± Tieni premuto sull'immagine e tocca 'Salva in Foto'</div>
      <div id="lightboxCartCTA" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(123, 116, 255, 0.95); color: white; padding: 16px 24px; border-radius: 12px; text-align: center; z-index: 10; display: none; max-width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: auto;">
        <button id="lightboxAddCartBtn" style="background: white; color: rgba(123, 116, 255, 1); border: none; padding: 12px 32px; border-radius: 8px; font-size: 16px; font-weight: 700; cursor: pointer; width: 100%; margin-bottom: 8px;">Aggiungi al carrello</button>
        <div style="font-size: 13px; opacity: 0.9;">Acquista per scaricare le foto senza watermark</div>
      </div>
      <img id="lightboxImage" style="max-width: 100%; max-height: 100%; object-fit: contain;" alt="Foto">
    </div>
  </div>
  
  <!-- Modal Carrello -->
  <div class="ios-share-modal" id="cartModal">
    <div class="ios-share-modal-content" style="max-width: 500px; width: 90%;">
      <h3 style="margin-top: 0; font-size: 20px; color: var(--text-light);">üõí Carrello</h3>
      <div id="cartItems" style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
        <p style="text-align: center; color: var(--text-muted);">Il carrello √® vuoto</p>
      </div>
      <div style="border-top: 2px solid rgba(255,255,255,0.1); padding-top: 15px; margin-top: 15px;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 15px; font-size: 18px; font-weight: 600; color: var(--text-light);">
          <span>Totale:</span>
          <span id="cartTotal">‚Ç¨0.00</span>
        </div>
        <button class="btn-primary" id="checkoutBtn" style="width: 100%; margin-bottom: 10px;" disabled>üí≥ Checkout</button>
        <button class="btn-retake" id="closeCartBtn" style="width: 100%;">Chiudi</button>
      </div>
    </div>
  </div>

  <!-- Modal Offerte -->
  <div class="ios-share-modal" id="offersModal">
    <div class="ios-share-modal-content" style="max-width: 500px; width: 90%; background: var(--bg-dark2); border: 2px solid var(--accent);">
      <h3 style="margin-top: 0; font-size: 24px; color: var(--text-light); text-align: center;">üéÅ Offerta Speciale!</h3>
      <div id="offersContent" style="text-align: center; padding: 20px 0;">
        <p style="font-size: 18px; color: var(--text-light); margin-bottom: 15px;">
          Hai trovato <strong id="offersPhotoCount" style="color: var(--accent-light);">0</strong> foto!
        </p>
        <div id="offersMessage" style="font-size: 16px; color: var(--text-muted); margin-bottom: 20px;">
          <!-- Messaggio offerta dinamico -->
        </div>
        <div style="background: linear-gradient(135deg, var(--purple), var(--pink)); color: #fff; padding: 20px; border-radius: 12px; margin: 20px 0;">
          <div style="font-size: 32px; font-weight: 900; margin-bottom: 10px;" id="offersPrice">‚Ç¨0</div>
          <div style="font-size: 14px; opacity: 0.9;">per tutte le tue foto</div>
        </div>
        <button class="btn-primary" id="offersBuyBtn" style="width: 100%; margin-bottom: 10px; font-size: 18px; padding: 16px;">
          üí≥ Buy All Photos
        </button>
        <button class="btn-retake" id="offersCloseBtn" style="width: 100%;">
          Choose Single Photos
        </button>
      </div>
    </div>
  </div>

  <script>
    // ========== SISTEMA TRADUZIONI ==========

    // Variabili globali
    let currentScreen = 'email';
    let stream = null;
    // Usa anche window._cameraStream per compatibilit√†
    if(typeof window._cameraStream === 'undefined') {
      window._cameraStream = null;
    }
    
    // Stato globale camera (robusto)
    let cameraStream = null;
    let cameraReady = false;
    let cameraStarting = false;
    let useFront = true;
    let capturedBlob = null;
    // Stateless mode: genera session_id ogni volta (non persistente)
    let sessionId = "session_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
    let currentCart = { photo_ids: [], count: 0, price_euros: 0 };
    let allPhotos = [];
    let currentPhotoIndex = 0;
    let paidPhotos = []; // Array di photo_id pagate
    let selfieCompleted = false; // Flag per tracciare se il selfie √® stato completato
    let photosLoaded = false; // Flag per tracciare se le foto sono state caricate
    
    // Carrello solo in memoria - SEMPRE VUOTO ad ogni refresh (non persistente)
    let cartPhotoIds = []; // Array in memoria, si svuota automaticamente ad ogni refresh
    
    // Inizializza sempre carrello vuoto
    function initCart() {
      cartPhotoIds = [];
      currentCart = { photo_ids: [], count: 0, price_euros: 0 };
      // Aggiorna UI solo se gli elementi DOM esistono (evita errori all'avvio)
      try {
        if (document.readyState === 'loading') {
          // DOM non ancora caricato, aggiorna dopo
          return;
        }
        updateCart();
        updateCartModal();
      } catch(e) {
        console.warn('initCart: DOM not ready yet, skipping UI update');
      }
    }
    
    function loadCart() {
      // Sempre ritorna array vuoto - carrello non persistente
      return [];
    }
    
    function saveCart(ids) {
      // Aggiorna solo la variabile in memoria, NON salva nulla
      cartPhotoIds = ids || [];
    }
    
    function addToCartLocal(photoId) {
      // Aggiungi solo in memoria (si perde ad ogni refresh)
      if (!cartPhotoIds.includes(photoId)) {
        cartPhotoIds.push(photoId);
      }
      return [...cartPhotoIds];
    }
    
    function removeFromCartLocal(photoId) {
      // Rimuovi solo dalla memoria
      cartPhotoIds = cartPhotoIds.filter(id => id !== photoId);
      return [...cartPhotoIds];
    }
    
    function syncCart() {
      // Sincronizza carrello in memoria con currentCart
      const photoIds = cartPhotoIds;
      const count = photoIds.length;
      const priceCents = computePrice(count);
      currentCart = {
        photo_ids: photoIds,
        count: count,
        price_cents: priceCents,
        price_euros: priceCents / 100.0
      };
      updateCart();
      updateCartModal();
      updateNudgeBar(); // Aggiorna nudge bar quando carrello cambia
    }
    
    // NON chiamare initCart() qui - viene chiamato in bootApp() quando il DOM √® pronto
    let fromStripeSuccess = false; // Flag per tracciare se arrivo da Stripe success

    // Elementi DOM
    const welcomeScreen = document.getElementById("welcomeScreen");
    const selfieScreen = document.getElementById("selfieScreen");
    const confirmScreen = document.getElementById("confirmScreen");
    const addPeopleScreen = document.getElementById("addPeopleScreen");
    const albumScreen = document.getElementById("albumScreen");
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const confirmPreview = document.getElementById("confirmPreview");
    const mainPersonAvatar = document.getElementById("mainPersonAvatar");
    const albumGrid = document.getElementById("albumGrid");
    const albumCartBtn = document.getElementById("albumCartBtn");
    const albumCartCount = document.getElementById("albumCartCount");
    const albumCartPrice = document.getElementById("albumCartPrice");
    // buyAllBtn rimosso - ora si usa solo il banner sticky
    const buyAllPrice = document.getElementById("buyAllPrice"); // Mantenuto per compatibilit√† se usato altrove
    const photoLightbox = document.getElementById("photoLightbox");
    const lightboxImage = photoLightbox ? photoLightbox.querySelector("img") : null;
    const photoCounter = document.getElementById("photoCounter");

    // Funzioni screen management
    function showScreen(screenName) {
      console.log('showScreen called with:', screenName);
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      const screen = document.getElementById(screenName + 'Screen');
      console.log('Screen element found:', screen ? 'YES' : 'NO', 'ID:', screenName + 'Screen');
      if(screen) {
        screen.classList.add('active');
        console.log('Screen activated:', screenName);
      } else {
        console.error('Screen not found:', screenName + 'Screen');
      }
      currentScreen = screenName;
      
      // Gestione stickyOfferBar e nudgeBar: visibili SOLO quando albumScreen √® attivo
      const stickyOfferBar = document.getElementById('stickyOfferBar');
      const nudgeBar = document.getElementById('nudgeBar');
      
      if(stickyOfferBar) {
        if(screenName !== 'album') {
          stickyOfferBar.classList.remove('active');
          stickyOfferBar.style.display = 'none';
        }
        // Se √® album, verr√† mostrato dopo che le foto sono renderizzate
      }
      
      if(nudgeBar) {
        if(screenName !== 'album') {
          nudgeBar.classList.remove('active');
          nudgeBar.style.display = 'none';
        }
        // Se √® album, verr√† mostrato dopo che le foto sono renderizzate
      }
      
      // Gestione selfieErrorBox: nascondi quando non siamo in selfieScreen
      const selfieErrorBox = document.getElementById('selfieErrorBox');
      if(selfieErrorBox) {
        if(screenName !== 'selfie') {
          selfieErrorBox.style.display = 'none';
        }
      }
      
      // Aggiorna header selfie in base a activeFamilyMode
      if(screenName === 'selfie') {
        const headerText = document.getElementById('selfieHeaderText');
        if(headerText) {
          headerText.textContent = activeFamilyMode ? 'Family member selfie' : 'Take your selfie';
        }
        // Mostra/nascondi prompt start camera
        const startCameraPrompt = document.getElementById('startCameraPrompt');
        const video = document.getElementById('video');
        if(startCameraPrompt && video) {
          if(cameraReady || cameraStarting) {
            startCameraPrompt.style.display = 'none';
            if(video.srcObject && video.videoWidth > 0) {
              video.style.display = 'block';
            }
        } else {
            startCameraPrompt.style.display = 'flex';
            video.style.display = 'none';
          }
        }
      } else if(screenName === 'album') {
        // Carica membri quando si entra nell'album
        if(userEmail) {
          loadFamilyMembersOnce();
        }
        // Stop camera quando esci dalla selfie screen
        stopCamera();
      } else if(screenName === 'confirm') {
        // Stop camera quando vai a confirm screen
        stopCamera();
      } else if(screenName !== 'selfie') {
        // Stop camera quando esci dalla selfie screen (qualsiasi altro screen)
        stopCamera();
      }
    }

    // Variabile globale per email utente (stateless: non persistente)
    let userEmail = null;
    let familyMembers = []; // Lista membri famiglia (stateless: sempre vuoto)
    let activeFamilyMode = false; // Modalit√† aggiunta membro famiglia (disabilitata)
    
    // ========== INIZIALIZZAZIONE SEMPLIFICATA ==========
    // Separazione netta tra flusso base e flusso post-pagamento
    
    // Funzione helper per verificare parametri Stripe success
    function hasStripeSuccessParams() {
      const p = new URLSearchParams(window.location.search);
      const success = p.get('success');
      const sessionId = p.get('session_id');
      const token = p.get('download_token');
      return success === '1' && (!!sessionId || !!token);
    }
    
    // Flag globale per bloccare flusso normale durante post-pagamento
    let IS_STRIPE_SUCCESS_FLOW = false;
    
    // Funzione per tornare al flusso normale (welcome/selfie)
    function goToNormalFlowStart() {
      console.log('[StripeSuccess] Returning to normal flow (welcome screen)');
      IS_STRIPE_SUCCESS_FLOW = false; // Reset flag
      showScreen('welcome');
    }
    
    // Bootstrap app: mostra sempre welcome/selfie screen (stateless)
    async function bootApp() {
      console.log('bootApp() called (stateless mode)');
      
      // Carrello sempre vuoto all'inizio (si svuota ad ogni refresh)
      initCart();
      
      // 1. Controlla se √® ritorno dopo pagamento Stripe (success=1 e session_id)
      if (hasStripeSuccessParams()) {
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('session_id');
        const token = urlParams.get('download_token');
        const sid = sessionId || token;
        
        // Controlla se questo session_id √® gi√† stato "consumato" (anti-refresh)
        if (sid) {
          const consumedKey = "stripe_consumed_" + sid;
          if (sessionStorage.getItem(consumedKey) === "1") {
            console.log('[StripeSuccess] Session ID already consumed, going to normal flow');
            goToNormalFlowStart();
            return;
          }
        }
        
        // Se non consumato, entra nel flusso post-pagamento
        IS_STRIPE_SUCCESS_FLOW = true;
        console.log('[StripeSuccess] Detected success params, entering post-payment flow');
        
        if (sid) {
          // FLUSSO POST-PAGAMENTO: carica pagina download usando session_id
          console.log('[StripeSuccess] Loading album after payment...');
          await loadAlbumAfterPayment(sid);
          return;
        }
      }
      
      // 2. Mostra sempre schermata welcome (poi selfie)
      console.log('Mostrando schermata welcome');
      try {
        showScreen('welcome');
        console.log('Schermata welcome mostrata correttamente');
      } catch(e) {
        console.error('Errore mostrando schermata welcome:', e);
        // Fallback: mostra welcome direttamente
        const welcomeEl = document.getElementById('welcomeScreen');
        if(welcomeEl) {
          document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
          welcomeEl.classList.add('active');
          console.log('Schermata welcome mostrata con fallback');
        }
      }
    }
    
    // Funzione separata per caricare album dopo pagamento (stateless: usa session_id)
    async function loadAlbumAfterPayment(sessionId) {
      console.log('[StripeSuccess] loadAlbumAfterPayment called with sessionId:', sessionId);
      
      // Stateless mode: usa session_id per recuperare foto pagate da Stripe
      if (!sessionId) {
        console.error('[StripeSuccess] No session_id provided');
        IS_STRIPE_SUCCESS_FLOW = false; // Reset flag se errore
        goToNormalFlowStart();
        return;
      }
      
      // Controlla se questo session_id √® gi√† stato "consumato" (anti-refresh)
      const consumedKey = "stripe_consumed_" + sessionId;
      if (sessionStorage.getItem(consumedKey) === "1") {
        console.log('[StripeSuccess] Session ID already consumed, going to normal flow');
        goToNormalFlowStart();
        return;
      }
      
      try {
        console.log('[StripeSuccess] Fetching /stripe/verify...');
        const res = await fetch(`/stripe/verify?session_id=${encodeURIComponent(sessionId)}`);
        
        if (!res.ok) {
          console.error('[StripeSuccess] /stripe/verify failed:', res.status, res.statusText);
          IS_STRIPE_SUCCESS_FLOW = false; // Reset flag se errore
          goToNormalFlowStart();
          return;
        }
        
        const data = await res.json();
        console.log('[StripeSuccess] /stripe/verify response:', data);
        
        if(data.ok && data.photo_ids && data.photo_ids.length > 0) {
          console.log('[StripeSuccess] Found', data.photo_ids.length, 'paid photos');
          
          allPhotos = [];
          paidPhotos = data.photo_ids;
          userEmail = data.customer_email || null;
          
          // Prepara foto pagate da mostrare con URL corretti per download senza watermark
          const photosToShow = data.photo_ids.map(photoId => {
            // Costruisci URL per foto pagate (senza watermark) - VELOCIT√Ä MASSIMA: usa originale R2
            const paidUrl = userEmail 
              ? `/photo/${encodeURIComponent(photoId)}?paid=true&email=${encodeURIComponent(userEmail)}`
              : `/photo/${encodeURIComponent(photoId)}?paid=true`;
            const thumbUrl = `/photo/${encodeURIComponent(photoId)}?variant=thumb`;
            const wmUrl = `/photo/${encodeURIComponent(photoId)}?variant=wm`;
            
            return {
              photo_id: photoId,
              score: 0,
              has_face: true,
              paid: true,
              paid_url: paidUrl,  // URL per foto originale senza watermark (VELOCIT√Ä MASSIMA)
              thumb_url: thumbUrl, // URL per thumbnail (pre-generato, veloce)
              wm_url: wmUrl        // URL per preview con watermark (pre-generato, veloce)
            };
          });
            
          allPhotos = photosToShow;
          
          console.log('[StripeSuccess] Showing album with', allPhotos.length, 'paid photos');
          showScreen('album');
          await displayPhotos();
          
          // Non mostrare sticky bar per foto pagate (sono gi√† tutte pagate)
          const stickyBar = document.getElementById('stickyOfferBar');
          if(stickyBar) {
            stickyBar.style.display = 'none';
          }
          
          // IMPORTANTE: marca questo session_id come "consumato" (anti-refresh)
          sessionStorage.setItem(consumedKey, "1");
          console.log('[StripeSuccess] Marked session_id as consumed in sessionStorage');
          
          // IMPORTANTE: pulisci URL immediatamente (cos√¨ refresh non rilancia il success flow)
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, "", cleanUrl);
          console.log('[StripeSuccess] Cleaned URL, removed success params');
          
          console.log('[StripeSuccess] Post-payment page displayed successfully');
          // Mantieni IS_STRIPE_SUCCESS_FLOW = true per bloccare altri flussi
        } else {
          console.error('[StripeSuccess] No photos found in Stripe session');
          IS_STRIPE_SUCCESS_FLOW = false; // Reset flag se errore
          goToNormalFlowStart();
        }
      } catch(e) {
        console.error('[StripeSuccess] Error loading album after payment:', e);
        IS_STRIPE_SUCCESS_FLOW = false; // Reset flag se errore
        goToNormalFlowStart();
      }
    }
    
    // Setup bottone "Rifai selfie" (una volta sola)
    function setupRetakeSelfieButton() {
        const retakeSelfieBtn = document.getElementById('retakeSelfieBtn');
        if(retakeSelfieBtn) {
          retakeSelfieBtn.addEventListener('click', function() {
            resetSelfieState();
          });
        }
    }
    
    // Avvia bootstrap quando DOM √® pronto
    function initializeApp() {
      console.log('Script loaded, document.readyState:', document.readyState);
      
      if(document.readyState === 'loading') {
        console.log('Waiting for DOMContentLoaded...');
        document.addEventListener('DOMContentLoaded', () => {
          console.log('DOMContentLoaded fired');
          setupRetakeSelfieButton();
          try {
            bootApp();
        } catch(e) {
            console.error('Error in bootApp():', e);
          // Fallback: mostra sempre la schermata welcome in caso di errore
          showScreen('welcome');
        }
      });
    } else {
        console.log('DOM already ready, calling bootApp() immediately');
        setupRetakeSelfieButton();
      try {
          bootApp();
      } catch(e) {
          console.error('Error in bootApp():', e);
        // Fallback: mostra sempre la schermata email in caso di errore
        showScreen('email');
      }
    }
    }
    
    // Avvia inizializzazione
    initializeApp();
    
    // Event listener per email screen
    const emailInput = document.getElementById('emailInput');
    const emailError = document.getElementById('emailError');
    const emailContinueBtn = document.getElementById('emailContinueBtn');
    
    // Funzione per controllare lo stato dell'utente (disabilitata in stateless mode)
    async function checkUserState(email, forceAlbum = false) {
      // Stateless: non controllare stato utente, sempre ritorna "no photos"
      console.log('checkUserState called (stateless: always returns no photos)');
      return { hasPaid: false, hasFound: false };
      
      // Codice vecchio disabilitato (stateless mode):
      if(false) {
      try {
        // 1. Salva l'utente solo con email
        try {
          await fetch(`/user/register?email=${encodeURIComponent(email)}`, {
            method: 'POST'
          });
          console.log('User registered/updated with email:', email);
        } catch(e) {
          console.error('Error registering user:', e);
          // Continua comunque
        }
        
        // 2. Controlla foto dell'utente
        const res = await fetch(`/user/photos?email=${encodeURIComponent(email)}`);
        const data = await res.json();
        
        console.log('checkUserState - API response:', data);
        console.log('checkUserState - paid_photos:', data.paid_photos);
        console.log('checkUserState - found_photos:', data.found_photos);
        console.log('checkUserState - forceAlbum:', forceAlbum);
        
        if(!data.ok) {
          console.log('checkUserState - API returned !ok');
          return { hasPaid: false, hasFound: false }; // Nessuna foto
        }
        
        const hasPaid = data.paid_photos && data.paid_photos.length > 0;
        const hasFound = data.found_photos && data.found_photos.length > 0;
        
        // Controlla anche se ci sono foto trovate con status='paid'
        const hasPaidInFound = data.found_photos && data.found_photos.some(p => p.status === 'paid');
        const hasAnyPaid = hasPaid || hasPaidInFound;
        
        // PULISCI CARRELLO: Se ha foto pagate, rimuovi tutte le foto dal carrello
        // (potrebbero essere rimaste da una sessione precedente)
        if(hasAnyPaid) {
          // Carrello sempre vuoto all'inizio - non persiste tra sessioni
          cartPhotoIds = [];
          syncCart();
        }
        
        // 3. Se ha foto trovate ‚Üí mostra album (SEMPRE, anche se ha foto pagate)
        // Le foto pagate vengono mostrate nella griglia con badge "paid" e sono scaricabili
        if(hasFound) {
          userEmail = email;
          // Stateless: non salvare email
          
          // Mostra TUTTE le foto trovate (pagate e non pagate) nella griglia
          // Le foto pagate avranno badge "paid" e saranno scaricabili
          let photosToShow = data.found_photos.map(p => ({
              photo_id: p.photo_id,
              score: 0,
              has_face: true,
              paid: p.status === 'paid'
            }));
          
          // Aggiungi anche le foto pagate che non sono in found_photos
          if(data.paid_photos && data.paid_photos.length > 0) {
            const foundPhotoIds = new Set(photosToShow.map(p => p.photo_id));
            data.paid_photos.forEach(photoId => {
              if(!foundPhotoIds.has(photoId)) {
                photosToShow.push({
                  photo_id: photoId,
              score: 0,
              has_face: true,
                  paid: true
                });
              }
            });
          }
          
          console.log(`Showing ${photosToShow.length} photos in album (${photosToShow.filter(p => p.paid).length} paid, ${photosToShow.filter(p => !p.paid).length} unpaid)`);
          
          if(photosToShow.length > 0) {
            allPhotos = photosToShow;
            
            // Mostra album
            showScreen('album');
            await displayPhotos();
            loadFamilyMembersOnce(); // Carica membri famiglia
            
            // Mostra sticky bar solo con conteggio foto NON pagate
            const unpaidCount = photosToShow.filter(p => !p.paid).length;
            if(unpaidCount > 0) {
              showStickyOfferBar(unpaidCount);
            } else {
              // Nascondi sticky bar se tutte le foto sono pagate
              const stickyBar = document.getElementById('stickyOfferBar');
              if(stickyBar) {
                stickyBar.style.display = 'none';
              }
            }
            
            return { hasPaid: hasAnyPaid, hasFound: true, shown: true };
          } else {
            // Nessuna foto trovata (tutte pagate o nessuna foto)
            // Se forceAlbum=true, mostra messaggio nell'album invece del selfie
            if(forceAlbum) {
              console.log('No unpaid photos found, showing message in album');
              userEmail = email;
              // Stateless: non salvare email
              
              // Mostra album con messaggio
              showScreen('album');
              
              // Pulisci griglia e mostra messaggio
              const albumGrid = document.getElementById('albumGrid');
              if(albumGrid) {
                albumGrid.innerHTML = '';
                
                // Crea messaggio
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 60px 20px; background: rgba(255, 255, 255, 0.05); border-radius: 16px; margin: 40px 0;';
                
                const icon = document.createElement('div');
                icon.textContent = '‚úÖ';
                icon.style.cssText = 'font-size: 64px; margin-bottom: 20px;';
                
                const title = document.createElement('h2');
                title.textContent = 'You\'ve purchased all available photos!';
                title.style.cssText = 'color: white; font-size: 24px; font-weight: 700; margin-bottom: 12px;';
                
                const subtitle = document.createElement('p');
                subtitle.textContent = 'There are no more photos available for purchase at the moment.';
                subtitle.style.cssText = 'color: rgba(255, 255, 255, 0.8); font-size: 16px; line-height: 1.6;';
                
                messageDiv.appendChild(icon);
                messageDiv.appendChild(title);
                messageDiv.appendChild(subtitle);
                albumGrid.appendChild(messageDiv);
              }
              
              // Nascondi sticky bar
              const stickyBar = document.getElementById('stickyOfferBar');
              if(stickyBar) {
                stickyBar.style.display = 'none';
              }
              
              return { hasPaid: hasAnyPaid, hasFound: false, shown: true };
            } else {
              // Se ha foto pagate ma non found_photos, mostra album con solo foto pagate
              // NON richiedere selfie se ha foto pagate
              if(hasAnyPaid) {
                // Prepara foto pagate da mostrare
                let paidPhotosToShow = [];
                
                // Aggiungi foto pagate da paid_photos
                if(data.paid_photos && data.paid_photos.length > 0) {
                  paidPhotosToShow = data.paid_photos.map(photoId => ({
                    photo_id: photoId,
                    score: 0,
                    has_face: true,
                    paid: true
                  }));
                }
                
                // Se abbiamo foto pagate da mostrare, mostra la griglia
                if(paidPhotosToShow.length > 0) {
                  console.log('No found photos but has paid photos, showing album with paid photos (no selfie required)');
      userEmail = email;
                  // Stateless: non salvare email
                  
                  allPhotos = paidPhotosToShow;
                  showScreen('album');
                  await displayPhotos();
                  loadFamilyMembersOnce(); // Carica membri famiglia
                  
                  // Nascondi sticky bar (tutte le foto sono pagate)
                  const stickyBar = document.getElementById('stickyOfferBar');
                  if(stickyBar) {
                    stickyBar.style.display = 'none';
                  }
                  
                  return { hasPaid: true, hasFound: false, shown: true };
                }
              }
              
              // Solo se NON ha foto (n√© trovate n√© pagate) ‚Üí richiedi selfie
              console.log('No photos found (neither found nor paid), showing selfie');
                showScreen('selfie');
                await startCamera();
                return { hasPaid: false, hasFound: false, shown: false };
            }
          }
        }
        
        // 5. Non ha nulla ‚Üí flusso normale
        console.log('checkUserState - No photos found, continuing with normal flow');
        return { hasPaid: false, hasFound: false };
      } catch(e) {
        console.error('Error checking user state:', e);
        return { hasPaid: false, hasFound: false };
      }
      } // Fine if(false) - codice vecchio disabilitato
    }
    
    // Stateless: emailContinueBtn disabilitato - non pi√π usato come primo step
    // Se viene ancora chiamato (es. da codice legacy), va direttamente al selfie
    if(emailContinueBtn) {
      emailContinueBtn.addEventListener('click', async () => {
        // Stateless: vai direttamente al selfie senza email o API calls
        console.log('Email Continue clicked (stateless: going to selfie)');
        showScreen('selfie');
        // Camera verr√† avviata quando l'utente clicca "Start Camera"
      });
      }
    
    // Funzione per caricare album di test (salta camera)
    async function loadTestAlbum() {
      const email = emailInput.value.trim();
      
      // Validazione email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if(!email || !emailRegex.test(email)) {
        emailError.classList.add('show');
        emailInput.style.borderColor = '#ff4444';
        return;
      }

      // Salva email
      userEmail = email;
      localStorage.setItem('userEmail', email);
      emailError.classList.remove('show');
      emailInput.style.borderColor = 'rgba(255, 255, 255, 0.1)';
      
      // Mostra loading
      const testBtn = document.getElementById('testAlbumBtn');
      if(testBtn) {
        testBtn.disabled = true;
        testBtn.textContent = '‚è≥ Caricamento...';
      }
      
      try {
        // Chiama endpoint test-album
        const res = await fetch(`/test-album?email=${encodeURIComponent(email)}`);
        const data = await res.json();
        
        if(data.ok && data.results && data.results.length > 0) {
          console.log(`Test album: trovate ${data.results.length} foto`);
          
          allPhotos = data.results;
          photosLoadedCount = 0;
          
          // Carica anche le foto gi√† acquistate
          if(userEmail) {
            try {
              const paidRes = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
              const paidData = await paidRes.json();
              
              if(paidData.ok && paidData.paid_photos && paidData.paid_photos.length > 0) {
                paidPhotos = [...paidData.paid_photos];
                console.log(`Caricate ${paidPhotos.length} foto pagate`);
                
                // Marca come pagate le foto nell'album
                allPhotos.forEach(photo => {
                  if(paidData.paid_photos.includes(photo.photo_id)) {
                    photo.paid = true;
                    if(!paidPhotos.includes(photo.photo_id)) {
                      paidPhotos.push(photo.photo_id);
                    }
                  }
                });
              }
            } catch(e) {
              console.error('Errore caricamento foto pagate:', e);
            }
          }
          
          // Mostra album
          showScreen('album');
          await displayPhotos();
          showStickyOfferBar(allPhotos.length);
          applyTranslations();
        } else {
          alert('No photos found for test. Make sure there are photos in the photos folder.');
        }
      } catch(e) {
        console.error('Errore caricamento test album:', e);
        alert('Error loading test album: ' + e.message);
      } finally {
        if(testBtn) {
          testBtn.disabled = false;
          testBtn.textContent = 'üß™ Test Album (salta camera)';
        }
      }
    }
    
    
    // Enter key su input email
    emailInput.addEventListener('keypress', (e) => {
      if(e.key === 'Enter') {
        emailContinueBtn.click();
      }
    });

    // Event listeners
    // Rimosso pulsante "Continua" - vai direttamente al selfie quando si inserisce email
    // Bottone Continue nella welcome screen: va al selfie e RICHIEDE permesso camera
    const welcomeContinueBtn = document.getElementById("welcomeContinueBtn");
    if(welcomeContinueBtn) {
      welcomeContinueBtn.addEventListener("click", async () => {
        // Stateless: vai direttamente al selfie senza email o check utente
        console.log('Welcome Continue clicked - going to selfie screen and requesting camera');
      showScreen('selfie');
        // QUI e SOLO QUI richiediamo permesso camera
      await startCamera();
      });
    }
    
    // RIMOSSO: Auto-avanzamento automatico dopo 2 secondi
    // La camera deve essere avviata SOLO quando l'utente clicca "Continue"

    document.getElementById("captureBtn").addEventListener("click", async () => {
      console.log("captureBtn clicked, cameraReady:", cameraReady);
      // captureSelfie() ha gi√† il guard interno, ma verifichiamo comunque
      if(!cameraReady) {
        console.warn("Camera not ready, ignoring click");
        return;
      }
      captureSelfie();
    });
    document.getElementById("confirmBtn").addEventListener("click", confirmSelfie);
    document.getElementById("retakeBtn").addEventListener("click", async () => {
      showScreen('selfie');
      await startCamera();
    });
    document.getElementById("retryCameraBtn")?.addEventListener("click", async () => {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked retryCameraBtn click - post-payment flow active');
        return;
      }
      
      const placeholder = document.getElementById('videoPlaceholder');
      const retryCameraBtn = document.getElementById('retryCameraBtn');
      if(placeholder) placeholder.style.display = 'none';
      if(retryCameraBtn) retryCameraBtn.style.display = 'none';
      await startCamera();
    });
    // Bottone "Start Camera" - avvia la camera quando l'utente clicca
    const startCameraBtn = document.getElementById('startCameraBtn');
    if(startCameraBtn) {
      startCameraBtn.addEventListener('click', async () => {
        // Guardia: blocca se siamo in flusso post-pagamento
        if (IS_STRIPE_SUCCESS_FLOW) {
          console.log('[StripeSuccess] Blocked startCameraBtn click - post-payment flow active');
          return;
        }
        
        console.log('[CAM] Start camera button clicked');
        const startCameraPrompt = document.getElementById('startCameraPrompt');
        if(startCameraPrompt) {
          startCameraPrompt.style.display = 'none';
        }
        await startCamera();
      });
    }
    document.getElementById("skipAddPersonBtn").addEventListener("click", async () => {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked skipAddPersonBtn click - post-payment flow active');
        return;
      }
      
      // Se le foto sono gi√† state caricate, mostra direttamente l'album
      if(allPhotos && allPhotos.length > 0) {
        await displayPhotos();
        updateCart();
        showScreen('album');
      } else {
        matchPhotos();
      }
    });
    document.getElementById("addPersonConfirmBtn").addEventListener("click", async () => {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked addPersonConfirmBtn click - post-payment flow active');
        return;
      }
      
      // Per ora salta, poi implementeremo aggiunta persone
      // Se le foto sono gi√† state caricate, mostra direttamente l'album
      if(allPhotos && allPhotos.length > 0) {
        await displayPhotos();
        updateCart();
        showScreen('album');
      } else {
        matchPhotos();
      }
    });
    // Pulsante buyAllBtn rimosso - ora si usa solo il banner sticky
    const albumBackBtn = document.getElementById("albumBackBtn");
    if(albumBackBtn) {
      albumBackBtn.addEventListener("click", () => {
        showScreen('welcome');
      });
    }
    
    if(albumCartBtn) {
      albumCartBtn.addEventListener("click", () => {
        const cartModal = document.getElementById('cartModal');
        if(cartModal) {
          cartModal.classList.add('active');
          updateCartModal();
        }
      });
      
      // Event listener per nudge checkout button (se non gi√† presente)
      const nudgeCheckoutBtn = document.getElementById('nudgeCheckoutBtn');
      if(nudgeCheckoutBtn && !nudgeCheckoutBtn.dataset.listenerAdded) {
        // L'onclick viene impostato dinamicamente in updateNudgeBar()
        nudgeCheckoutBtn.dataset.listenerAdded = 'true';
      }
    }
    
    // Bottone "Aggiungi membro famiglia"
    const addFamilyBtn = document.getElementById('addFamilyBtn');
    if(addFamilyBtn) {
      addFamilyBtn.addEventListener('click', async () => {
        if(!userEmail) {
          alert('Email not found');
          return;
        }
        
        // Verifica limite membri
        if(familyMembers.length >= 8) {
          alert('You have already added the maximum number of members (8).');
          return;
        }
        
        // Attiva modalit√† family
        activeFamilyMode = true;
        
        // Aggiorna header
        const headerText = document.getElementById('selfieHeaderText');
        if(headerText) headerText.textContent = 'Family member selfie';
        
        // Mostra schermata selfie
        showScreen('selfie');
        
        // Avvia camera (parte di un gesto utente)
        try {
          await startCamera();
        } catch(e) {
          console.error('Error starting camera for family member:', e);
          alert('Error accessing camera');
          activeFamilyMode = false;
          const headerText2 = document.getElementById('selfieHeaderText');
          if(headerText2) headerText2.textContent = 'Take your selfie';
        }
      });
    }
    
    // Gestione tab album
    const myContentTab = document.getElementById("myContentTab");
    const pricesTab = document.getElementById("pricesTab");
    const pricesList = document.getElementById("pricesList");
    const closeCartBtn = document.getElementById("closeCartBtn");
    const cartModal = document.getElementById('cartModal');
    
    if(myContentTab && pricesTab && albumGrid && pricesList) {
      myContentTab.addEventListener("click", () => {
        myContentTab.classList.add('active');
        pricesTab.classList.remove('active');
        if(albumGrid) albumGrid.style.display = 'grid';
        pricesList.classList.remove('active');
      });
      
      pricesTab.addEventListener("click", () => {
        pricesTab.classList.add('active');
        myContentTab.classList.remove('active');
        if(albumGrid) albumGrid.style.display = 'none';
        pricesList.classList.add('active');
      });
    }
    
    if(closeCartBtn && cartModal) {
      closeCartBtn.addEventListener("click", () => {
        cartModal.classList.remove('active');
      });
    }
    const checkoutBtn = document.getElementById("checkoutBtn");
    if(checkoutBtn) {
      checkoutBtn.addEventListener("click", checkout);
    }
    
    // Chiudi modal cliccando fuori
    if(cartModal) {
      cartModal.addEventListener('click', (e) => {
        if(e.target.id === 'cartModal') {
          cartModal.classList.remove('active');
        }
      });
    }
    
    document.getElementById('offersModal').addEventListener('click', (e) => {
      if(e.target.id === 'offersModal') {
        document.getElementById('offersModal').classList.remove('active');
      }
    });

    // ========== FAMILY MEMBERS MANAGEMENT ==========
    let memberStream = null;
    let memberCapturedBlob = null;
    
    // Funzione per mostrare album da foto gi√† caricate (senza fetch)
    async function showAlbumFromCachedPhotos(email, foundPhotos, paidPhotos) {
      if(!email) {
        console.error("showAlbumFromCachedPhotos: email is required");
          return;
        }

      console.log(`showAlbumFromCachedPhotos: found=${foundPhotos.length}, paid=${paidPhotos.length}`);
      
      // Unisci found+paid per photo_id senza duplicati
      let photosToShow = [];
      const photoIdsSet = new Set();
      
      // Aggiungi found_photos
      if(foundPhotos && foundPhotos.length > 0) {
        foundPhotos.forEach(p => {
          const photoId = typeof p === 'string' ? p : p.photo_id;
          if(photoId && !photoIdsSet.has(photoId)) {
            photosToShow.push({
              photo_id: photoId,
              score: 0,
              has_face: true,
              paid: (typeof p === 'object' && p.status === 'paid') || false
            });
            photoIdsSet.add(photoId);
          }
        });
      }
      
      // Aggiungi paid_photos che non sono gi√† in found
      if(paidPhotos && paidPhotos.length > 0) {
        paidPhotos.forEach(photoId => {
          const pid = typeof photoId === 'string' ? photoId : photoId.photo_id;
          if(pid && !photoIdsSet.has(pid)) {
            photosToShow.push({
              photo_id: pid,
              score: 0,
              has_face: true,
              paid: true
            });
            photoIdsSet.add(pid);
          }
        });
      }
      
      // Aggiorna paidPhotos array globale per il carrello (array di stringhe)
      if(paidPhotos && paidPhotos.length > 0) {
        paidPhotos = paidPhotos.map(p => typeof p === 'string' ? p : p.photo_id).filter(Boolean);
      }
      
      if(photosToShow.length > 0) {
        allPhotos = photosToShow;
        photosLoadedCount = 0;
        
        // Salva step
        // Stateless: non salvare step
        
        // Mostra schermata album
        showScreen('album');
        
        // Carica membri famiglia in background
        loadFamilyMembersOnce().catch(e => console.error('Error loading family members:', e));
        
        // Aggiorna carrello
        updateCart();
        
        // Carica le foto (con lazy loading)
        await displayPhotos();
        
        // Mostra banner dopo che lo schermo √® visibile
        setTimeout(() => {
          const unpaidCount = photosToShow.filter(p => !p.paid).length;
          if(unpaidCount > 0) {
            showStickyOfferBar(unpaidCount);
          } else {
            // Nascondi sticky bar se tutte le foto sono pagate
            const stickyBar = document.getElementById('stickyOfferBar');
            if(stickyBar) {
              stickyBar.style.display = 'none';
            }
          }
        }, 100);
      } else {
        console.log("No photos to show in showAlbumFromCachedPhotos");
      }
    }
    
    // Funzione unica per andare alla gallery: carica /family/members e /user/photos
    async function goToGallery(email) {
      console.log("STEP match->load photos");
      if(!email) {
        console.error("goToGallery: email is required");
        return;
      }
      
      // Salva step corrente
      localStorage.setItem('step', 'gallery');
      
      // Carica membri famiglia in background (non bloccare)
      loadFamilyMembersOnce().catch(e => console.error('Error loading family members:', e));
      
      // Carica foto utente con funzione centralizzata
      try {
        const data = await fetchUserPhotos(email);
        
        if(data.ok) {
          let photosToShow = [];
          
          // Aggiungi found_photos
          if(data.found_photos && data.found_photos.length > 0) {
            photosToShow = data.found_photos.map(p => ({
              photo_id: p.photo_id,
              score: 0,
              has_face: true,
              paid: p.status === 'paid'
            }));
          }
          
          // Aggiungi anche le foto pagate che non sono in found_photos
          if(data.paid_photos && data.paid_photos.length > 0) {
            const foundPhotoIds = new Set(photosToShow.map(p => p.photo_id));
            data.paid_photos.forEach(photoId => {
              if(!foundPhotoIds.has(photoId)) {
                photosToShow.push({
                  photo_id: photoId,
                  score: 0,
                  has_face: true,
                  paid: true
                });
              }
            });
          }
          
          // Aggiorna paidPhotos array per il carrello
          if(data.paid_photos && data.paid_photos.length > 0) {
            paidPhotos = [...data.paid_photos];
          }
          
          if(photosToShow.length > 0) {
            allPhotos = photosToShow;
            photosLoadedCount = 0; // Reset counter
            
            // Nascondi upload status se presente
            const uploadStatus = document.getElementById('uploadStatus');
            const captureBtn = document.getElementById('captureBtn');
            if(uploadStatus) uploadStatus.classList.remove('active');
            if(captureBtn) {
              captureBtn.disabled = false;
              captureBtn.style.opacity = '1';
            }
            
            // Schermata album gi√† mostrata sopra, ora aggiorna carrello
            updateCart();
            
            // Carica le foto (con lazy loading)
            await displayPhotos();
            
            // Mostra banner dopo che lo schermo √® visibile
                setTimeout(() => {
              const unpaidCount = photosToShow.filter(p => !p.paid).length;
              if(unpaidCount > 0) {
                showStickyOfferBar(unpaidCount);
              } else {
                // Nascondi sticky bar se tutte le foto sono pagate
                const stickyBar = document.getElementById('stickyOfferBar');
                if(stickyBar) {
                  stickyBar.style.display = 'none';
                }
              }
            }, 100);
                } else {
            console.log("No photos found in goToGallery");
          }
        } else {
          console.log("No photos found in goToGallery");
        }
      } catch(e) {
        console.error('Error loading photos in goToGallery:', e);
        // Mostra errore se timeout o altro
        if(e.message && e.message.includes('timeout')) {
          alert('Request timeout. Please check your connection and try again.');
        } else {
          alert('Error loading photos. Please try again.');
        }
      }
    }
    
    // Carica membri quando l'album viene mostrato
    // Guard per evitare doppia chiamata a /family/members
    let familyMembersLoaded = false;
    let familyMembersLoading = false;
    
    async function loadFamilyMembersOnce() {
      if (familyMembersLoaded || familyMembersLoading) {
        return;
      }
      familyMembersLoading = true;
      try {
        await loadFamilyMembers();
        familyMembersLoaded = true;
      } finally {
        familyMembersLoading = false;
      }
    }
    
    async function loadFamilyMembers() {
      if(!userEmail) return;
      
      try {
        // Prova prima localStorage
        // Stateless: non caricare da localStorage
        familyMembers = [];
        
        // Poi carica dal backend (sorgente preferita)
        const res = await fetch(`/family/members?email=${encodeURIComponent(userEmail)}`);
        const data = await res.json();
        
        if(data.ok && data.members) {
          familyMembers = data.members;
          // Salva in localStorage
          // Stateless: non salvare family members
          
          // Aggiorna contatore
          updateFamilyMembersCount();
          
          if(data.members.length > 0) {
            const membersSection = document.getElementById('familyMembersSection');
            const membersList = document.getElementById('familyMembersList');
            
            if(membersSection) membersSection.style.display = 'block';
            if(membersList) {
              membersList.innerHTML = '';
              data.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.style.cssText = 'background: rgba(255,255,255,0.1); padding: 12px 16px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; min-width: 200px;';
                memberDiv.innerHTML = `
                  <span style="color: white; font-size: 14px;">${member.name || 'Membro ' + member.id}</span>
                  <button class="btn-retake" data-member-id="${member.id}" style="padding: 6px 12px; font-size: 12px; margin-left: 10px;">Rimuovi</button>
                `;
                membersList.appendChild(memberDiv);
                
                // Event listener per rimuovere membro
                const removeBtn = memberDiv.querySelector('button');
                removeBtn.addEventListener('click', async () => {
                  if(confirm('Remove this member? Their photos will be removed from the album.')) {
                    try {
                      const deleteRes = await fetch(`/family/members/${member.id}?email=${encodeURIComponent(userEmail)}`, {
                        method: 'DELETE'
                      });
                      const deleteData = await deleteRes.json();
                      if(deleteData.ok) {
                        // Refresh album
                        const photosRes = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
                        const photosData = await photosRes.json();
                        if(photosData.ok) {
                          const hasFound = photosData.found_photos && photosData.found_photos.length > 0;
                          const hasPaid = photosData.paid_photos && photosData.paid_photos.length > 0;
                          let photosToShow = [];
                          if(hasFound) {
                            photosToShow = photosData.found_photos.map(p => ({
                              photo_id: p.photo_id,
                              score: 0,
                              has_face: true,
                              paid: p.status === 'paid'
                            }));
                          }
                          if(hasPaid && photosData.paid_photos) {
                            const foundIds = new Set(photosToShow.map(p => p.photo_id));
                            photosData.paid_photos.forEach(id => {
                              if(!foundIds.has(id)) {
                                photosToShow.push({photo_id: id, score: 0, has_face: true, paid: true});
                              }
                            });
                          }
                          allPhotos = photosToShow;
                          photosLoaded = false;
                          await displayPhotos();
                          loadFamilyMembersOnce(); // Ricarica lista membri
                        }
                      }
                    } catch(e) {
                      console.error('Error deleting member:', e);
                      alert('Error removing member');
                    }
                  }
                });
              });
            }
          } else {
            const membersSection = document.getElementById('familyMembersSection');
            if(membersSection) membersSection.style.display = 'none';
          }
        }
      } catch(e) {
        console.error('Error loading family members:', e);
      }
    }
    
    function updateFamilyMembersCount() {
      const countEl = document.getElementById('familyMembersCount');
      if(countEl) {
        countEl.textContent = `(${familyMembers.length}/8)`;
      }
    }
    
    // Bottone "Aggiungi membro"
    const addMemberBtn = document.getElementById('addMemberBtn');
    const addMemberModal = document.getElementById('addMemberModal');
    const closeAddMemberModalBtn = document.getElementById('closeAddMemberModalBtn');
    const startMemberSelfieBtn = document.getElementById('startMemberSelfieBtn');
    const memberSelfieArea = document.getElementById('memberSelfieArea');
    const memberVideo = document.getElementById('memberVideo');
    const memberCanvas = document.getElementById('memberCanvas');
    const memberCaptureBtn = document.getElementById('memberCaptureBtn');
    const memberNameInput = document.getElementById('memberNameInput');
    const memberUploadStatus = document.getElementById('memberUploadStatus');
    
    if(addMemberBtn && addMemberModal) {
      addMemberBtn.addEventListener('click', () => {
        addMemberModal.classList.add('active');
        memberSelfieArea.style.display = 'none';
        memberNameInput.value = '';
        memberCapturedBlob = null;
      });
    }
    
    if(closeAddMemberModalBtn && addMemberModal) {
      closeAddMemberModalBtn.addEventListener('click', () => {
        addMemberModal.classList.remove('active');
        if(memberStream) {
          memberStream.getTracks().forEach(track => track.stop());
          memberStream = null;
        }
      });
    }
    
    if(startMemberSelfieBtn) {
      startMemberSelfieBtn.addEventListener('click', async () => {
        memberSelfieArea.style.display = 'block';
        startMemberSelfieBtn.style.display = 'none';
        
        // Avvia camera per membro
        try {
          memberStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user' }
          });
          if(memberVideo) {
            memberVideo.srcObject = memberStream;
            memberCaptureBtn.disabled = false;
            memberCaptureBtn.style.opacity = '1';
          }
        } catch(e) {
          console.error('Error starting member camera:', e);
          alert('Error accessing camera');
        }
      });
    }
    
    if(memberCaptureBtn) {
      memberCaptureBtn.addEventListener('click', async () => {
        if(!memberVideo || !memberCanvas) return;
        
        const ctx = memberCanvas.getContext('2d');
        memberCanvas.width = memberVideo.videoWidth;
        memberCanvas.height = memberVideo.videoHeight;
        ctx.drawImage(memberVideo, 0, 0);
        
        memberCanvas.toBlob(async (blob) => {
          memberCapturedBlob = blob;
          
          // Ferma camera
          if(memberStream) {
            memberStream.getTracks().forEach(track => track.stop());
            memberStream = null;
          }
          
          // Mostra loading
          memberUploadStatus.style.display = 'block';
          memberCaptureBtn.disabled = true;
          
          // Invia a backend
          try {
            const formData = new FormData();
            formData.append('selfie', memberCapturedBlob, 'member_selfie.jpg');
            const memberName = memberNameInput.value.trim();
            if(memberName) {
              formData.append('member_name', memberName);
            }
            
            const res = await fetch(`/family/add_member?email=${encodeURIComponent(userEmail)}`, {
              method: 'POST',
              body: formData
            });
            
            const data = await res.json();
            
            if(data.ok) {
              // Successo: mostra toast e refresh album
              alert(`Membro aggiunto: +${data.matched_count} foto`);
              
              // Refresh album
              const photosRes = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
              const photosData = await photosRes.json();
              if(photosData.ok) {
                const hasFound = photosData.found_photos && photosData.found_photos.length > 0;
                const hasPaid = photosData.paid_photos && photosData.paid_photos.length > 0;
                let photosToShow = [];
                if(hasFound) {
                  photosToShow = photosData.found_photos.map(p => ({
                    photo_id: p.photo_id,
                    score: 0,
                    has_face: true,
                    paid: p.status === 'paid'
                  }));
                }
                if(hasPaid && photosData.paid_photos) {
                  const foundIds = new Set(photosToShow.map(p => p.photo_id));
                  photosData.paid_photos.forEach(id => {
                    if(!foundIds.has(id)) {
                      photosToShow.push({photo_id: id, score: 0, has_face: true, paid: true});
                    }
                  });
                }
                allPhotos = photosToShow;
                photosLoaded = false;
                await displayPhotos();
                loadFamilyMembersOnce(); // Ricarica lista membri
              }
              
              // Chiudi modal
              addMemberModal.classList.remove('active');
              memberSelfieArea.style.display = 'none';
              memberUploadStatus.style.display = 'none';
          } else {
              alert(data.detail || 'Error adding member');
              memberUploadStatus.style.display = 'none';
              memberCaptureBtn.disabled = false;
            }
          } catch(e) {
            console.error('Error adding member:', e);
            alert('Error adding member');
            memberUploadStatus.style.display = 'none';
            memberCaptureBtn.disabled = false;
          }
        }, 'image/jpeg', 0.9);
      });
    }
    
    // Chiudi modal cliccando fuori
    if(addMemberModal) {
      addMemberModal.addEventListener('click', (e) => {
        if(e.target.id === 'addMemberModal') {
          addMemberModal.classList.remove('active');
          if(memberStream) {
            memberStream.getTracks().forEach(track => track.stop());
            memberStream = null;
          }
        }
      });
    }

    // Funzioni camera
    async function startCamera() {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked startCamera() - post-payment flow active');
        return;
      }
      
      // Se gi√† in avvio, ritorna
      if(cameraStarting) {
        console.log('[CAM] Camera already starting, skipping');
        return;
      }
      
      // Se gi√† pronta, ritorna
      if(cameraReady && cameraStream) {
        console.log('[CAM] Camera already ready, skipping');
        return;
      }

      const video = document.getElementById('video');
        const captureBtn = document.getElementById('captureBtn');
      const placeholder = document.getElementById('videoPlaceholder');
      const retryCameraBtn = document.getElementById('retryCameraBtn');

      if (!video) {
        console.error('[CAM] Video element not found');
        return;
      }

      // Imposta stato iniziale
      cameraStarting = true;
      cameraReady = false;
      if(captureBtn) {
        captureBtn.disabled = true;
      }
      
      // Nascondi placeholder e retry button inizialmente
      if(placeholder) {
        placeholder.style.display = 'none';
      }
      if(retryCameraBtn) {
        retryCameraBtn.style.display = 'none';
      }

      try {
        // Verifica supporto camera
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('Camera non supportata dal browser');
        }

        console.log('[CAM] Richiesta accesso camera...');
        const constraints = { 
          video: { facingMode: 'user' }, 
          audio: false 
        };
        
        const newStream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log('[CAM] getUserMedia success, stream ottenuto');
        
        // Salva stream
        cameraStream = newStream;
        stream = newStream;
        window._cameraStream = newStream;

        // Assegna stream al video
        video.srcObject = newStream;
        
        // Nascondi prompt start camera
        const startCameraPrompt = document.getElementById('startCameraPrompt');
        if(startCameraPrompt) {
          startCameraPrompt.style.display = 'none';
        }
        
        // Mostra video
        video.style.display = 'block';
        
        // Event listeners per verificare quando il video √® pronto
        const onVideoReady = () => {
          if(video.videoWidth > 0 && video.videoHeight > 0) {
            console.log('[CAM] Video ready:', video.videoWidth, 'x', video.videoHeight);
            cameraReady = true;
            cameraStarting = false;
            
            // Abilita captureBtn
        if(captureBtn) {
      captureBtn.disabled = false;
        }
        
            // Nascondi placeholder
        if(placeholder) {
          placeholder.style.display = 'none';
            }
            
            // Rimuovi listeners (una volta pronta, non servono pi√π)
            video.removeEventListener('loadedmetadata', onVideoReady);
            video.removeEventListener('playing', onVideoReady);
          }
        };
        
        video.addEventListener('loadedmetadata', onVideoReady);
        video.addEventListener('playing', onVideoReady);
        
        // Prova a far partire il video
        try {
          await video.play();
          console.log('[CAM] Video play() success');
        } catch(playErr) {
          console.warn('[CAM] Video play() error (non critico):', playErr);
          // Il video potrebbe partire comunque, aspetta loadedmetadata/playing
        }
        
      } catch (err) {
        console.error('[CAM] Errore accesso camera:', err);
        
        cameraReady = false;
        cameraStarting = false;
        
        // Mostra placeholder e retry button
        if(placeholder) {
          placeholder.style.display = 'block';
        }
        if(retryCameraBtn) {
          retryCameraBtn.style.display = 'block';
        }
        if(video) {
          video.style.display = 'none';
        }
        
        // Disabilita pulsante cattura
        if(captureBtn) {
          captureBtn.disabled = true;
        }
        
        // Pulisci stream se era stato creato
        if(cameraStream) {
          cameraStream.getTracks().forEach(track => track.stop());
          cameraStream = null;
        }
        if(stream) {
          stream.getTracks().forEach(track => track.stop());
          stream = null;
        }
        if(window._cameraStream) {
          window._cameraStream.getTracks().forEach(track => track.stop());
          window._cameraStream = null;
        }
      }
    }
    
    function stopCamera() {
      console.log('[CAM] Stopping camera...');
      if(cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
      if(stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      if(window._cameraStream) {
        window._cameraStream.getTracks().forEach(track => track.stop());
        window._cameraStream = null;
      }
      cameraReady = false;
      cameraStarting = false;
      
      const video = document.getElementById('video');
      if(video) {
        video.srcObject = null;
      }
      
      const captureBtn = document.getElementById('captureBtn');
      if(captureBtn) {
        captureBtn.disabled = true;
    }
  }

  function captureSelfie() {
      const video = document.getElementById('video');
      
      // GUARD: Blocca se camera non pronta
      if(!cameraReady || !video || !video.srcObject || video.videoWidth === 0 || video.videoHeight === 0) {
        console.warn("Camera not ready:", {
          cameraReady,
            video: !!video,
          srcObject: !!video?.srcObject,
            width: video?.videoWidth,
          height: video?.videoHeight
          });
        return; // Non fare nulla, nessun canvas draw, nessuna preview
    }
      
      try {

        console.log("Cattura selfie, dimensioni video:", video.videoWidth, "x", video.videoHeight);
        
        // Aspect ratio fisso 3:4 (verticale) - stesso del contenitore video
        const targetAspectRatio = 3 / 4;
        const videoAspectRatio = video.videoWidth / video.videoHeight;
        
        let sourceX = 0;
        let sourceY = 0;
        let sourceWidth = video.videoWidth;
        let sourceHeight = video.videoHeight;
        
        // Calcola dimensioni canvas con aspect ratio 3:4
        let canvasWidth, canvasHeight;
        
        if(videoAspectRatio > targetAspectRatio) {
          // Video pi√π largo: crop ai lati, mantieni altezza
          canvasHeight = video.videoHeight;
          canvasWidth = Math.round(canvasHeight * targetAspectRatio);
          sourceX = Math.round((video.videoWidth - canvasWidth) / 2);
          sourceY = 0;
          sourceWidth = canvasWidth;  // Usa la larghezza del crop, non quella del video
          sourceHeight = canvasHeight; // Usa l'altezza del crop
        } else {
          // Video pi√π alto: crop sopra/sotto, mantieni larghezza
          canvasWidth = video.videoWidth;
          canvasHeight = Math.round(canvasWidth / targetAspectRatio);
          sourceX = 0;
          sourceY = Math.round((video.videoHeight - canvasHeight) / 2);
          sourceWidth = canvasWidth;  // Usa la larghezza del crop
          sourceHeight = canvasHeight; // Usa l'altezza del crop
        }
        
        // Imposta dimensioni canvas
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        
    const ctx = canvas.getContext('2d');
        
        // Disegna il frame corrente del video sul canvas con crop centrato
        // Usa la stessa area che viene mostrata nel video (object-fit: cover)
        ctx.drawImage(
          video,
          sourceX, sourceY, sourceWidth, sourceHeight,  // Area sorgente (crop) - CORRETTO
          0, 0, canvasWidth, canvasHeight                // Area destinazione (canvas)
        );
        
        console.log("Canvas creato, dimensioni:", canvas.width, "x", canvas.height);
        console.log("Crop applicato:", { sourceX, sourceY, sourceWidth, sourceHeight });
        
        // Converti canvas in blob
    canvas.toBlob(async (blob) => {
          if(!blob) {
            console.error("Error: blob not created");
            alert("Error capturing photo. Please try again.");
        return;
      }
          
          // Se siamo in modalit√† family member, chiama /family/add_member
          if(activeFamilyMode) {
            if(!userEmail) {
              alert('Email not found');
              activeFamilyMode = false;
              return;
            }
            
            // Verifica limite membri
            if(familyMembers.length >= 8) {
              alert('You have already added the maximum number of members (8).');
              activeFamilyMode = false;
              showScreen('album');
              return;
            }
            
            // Mostra loading
            const uploadStatus = document.getElementById('uploadStatus');
            if(uploadStatus) {
              uploadStatus.style.display = 'block';
              uploadStatus.querySelector('.upload-status-text').textContent = 'Adding family member...';
            }
            
            try {
              const formData = new FormData();
              formData.append('selfie', blob, 'member_selfie.jpg');
              
              const res = await fetch(`/family/add_member?email=${encodeURIComponent(userEmail)}`, {
                method: 'POST',
                body: formData
              });
              
              const data = await res.json();
              
              if(data.ok) {
                // Successo: ricarica membri e album
                familyMembersLoaded = false; // Reset per forzare ricaricamento
                await loadFamilyMembersOnce();
                
                // Refresh album
                const photosRes = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
                const photosData = await photosRes.json();
                if(photosData.ok) {
                  const hasFound = photosData.found_photos && photosData.found_photos.length > 0;
                  const hasPaid = photosData.paid_photos && photosData.paid_photos.length > 0;
                  let photosToShow = [];
                  if(hasFound) {
                    photosToShow = photosData.found_photos.map(p => ({
                      photo_id: p.photo_id,
                      score: 0,
                      has_face: true,
                      paid: p.status === 'paid'
                    }));
                  }
                  if(hasPaid && photosData.paid_photos) {
                    const foundIds = new Set(photosToShow.map(p => p.photo_id));
                    photosData.paid_photos.forEach(id => {
                      if(!foundIds.has(id)) {
                        photosToShow.push({photo_id: id, score: 0, has_face: true, paid: true});
                      }
                    });
                  }
                  allPhotos = photosToShow;
                  photosLoaded = false;
                  await displayPhotos();
                }
                
                // Reset modalit√† e torna all'album
                activeFamilyMode = false;
                const headerText = document.getElementById('selfieHeaderText');
                if(headerText) headerText.textContent = 'Take your selfie';
                
                showScreen('album');
                
                // Nascondi loading
                if(uploadStatus) uploadStatus.style.display = 'none';
              } else {
                // Errore: mostra messaggio
                const errorMsg = data.detail || 'Error adding member';
                if(errorMsg.includes('Maximum') && errorMsg.includes('members')) {
                  alert('You have already added the maximum number of members (8).');
                } else if(errorMsg.includes('No face detected')) {
                  alert('No face detected in selfie. Please try again.');
                } else {
                  alert(errorMsg);
                }
                activeFamilyMode = false;
                const headerText = document.getElementById('selfieHeaderText');
                if(headerText) headerText.textContent = 'Take your selfie';
                if(uploadStatus) uploadStatus.style.display = 'none';
              }
            } catch(e) {
              console.error('Error adding family member:', e);
              alert('Error adding member');
              activeFamilyMode = false;
              const headerText = document.getElementById('selfieHeaderText');
              if(headerText) headerText.textContent = 'Take your selfie';
              if(uploadStatus) uploadStatus.style.display = 'none';
            }
            return;
          }
          
          // Logica normale per selfie principale
          console.log("Blob creato, dimensione:", blob.size, "bytes");
          capturedBlob = blob;
          const url = URL.createObjectURL(blob);
          confirmPreview.src = url;
          if(mainPersonAvatar) {
            mainPersonAvatar.src = url;
          }
          
          // Ferma lo stream
          if(stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
          }
          
          showScreen('confirm');
        }, 'image/jpeg', 0.9);
        
      } catch(err) {
        console.error("Errore nella cattura selfie:", err);
        alert("Error capturing photo: " + err.message);
      }
    }
    
    async function confirmSelfie() {
      // Marca selfie come completato (per non interrompere se le API finiscono dopo)
      selfieCompleted = true;
      
      // NON registrare utente: match senza email
      // Dopo la conferma del selfie, cerca direttamente le foto
      matchPhotos();
    }

    // Funzioni UI per gestione selfie loading/error
    function showSelfieLoading(isLoading) {
      const uploadStatus = document.getElementById('uploadStatus');
      const selfieErrorBox = document.getElementById('selfieErrorBox');
      const captureBtn = document.getElementById('captureBtn');
      
      if(isLoading) {
        // Mostra loading, nascondi errore
        if(uploadStatus) uploadStatus.classList.add('active');
        if(selfieErrorBox) selfieErrorBox.style.display = 'none';
        if(captureBtn) {
          captureBtn.disabled = true;
          captureBtn.style.opacity = '0.5';
        }
      } else {
        // Nascondi loading
        if(uploadStatus) uploadStatus.classList.remove('active');
        if(captureBtn) {
          captureBtn.disabled = false;
          captureBtn.style.opacity = '1';
        }
      }
    }
    
    function showSelfieError(message) {
      const uploadStatus = document.getElementById('uploadStatus');
      const selfieErrorBox = document.getElementById('selfieErrorBox');
      const selfieErrorMessage = document.getElementById('selfieErrorMessage');
      const captureBtn = document.getElementById('captureBtn');
      
      // Nascondi loading
      if(uploadStatus) uploadStatus.classList.remove('active');
      if(captureBtn) {
        captureBtn.disabled = false;
        captureBtn.style.opacity = '1';
      }
      
      // Mostra errore
      if(selfieErrorMessage) {
        selfieErrorMessage.textContent = message || "No photos found or still processing. Please try again.";
      }
      if(selfieErrorBox) {
        selfieErrorBox.style.display = 'flex';
      }
    }
    
    function resetSelfieState() {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked resetSelfieState() - post-payment flow active');
        return;
      }
      
      // Reset variabili
      capturedBlob = null;
      selfieCompleted = false;
      allPhotos = [];
      currentPhotoIndex = 0;
      paidPhotos = [];
      
      // Nascondi errore
      const selfieErrorBox = document.getElementById('selfieErrorBox');
      if(selfieErrorBox) selfieErrorBox.style.display = 'none';
      
      // Torna allo schermo selfie e riavvia camera
      showScreen('selfie');
      startCamera();
    }
    
    // Funzioni matching
    async function matchPhotos() {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked matchPhotos() - post-payment flow active');
        return;
      }
      
      if(!capturedBlob) {
        console.error("capturedBlob √® null!");
        alert("Error: selfie not found. Please take it again.");
        showScreen('selfie');
        startCamera();
      return;
    }

      // Mostra area upload status (torna allo schermo selfie se siamo in confirm)
      showScreen('selfie');
      const uploadStatus = document.getElementById('uploadStatus');
      const uploadStatusText = document.getElementById('uploadStatusText');
      const uploadProgressBar = document.getElementById('uploadProgressBar');
      const uploadPercentage = document.getElementById('uploadPercentage');
      const captureBtn = document.getElementById('captureBtn');
      
      // Mostra loading
      showSelfieLoading(true);
      
      // Imposta testo e progress iniziale
      if(uploadStatusText) uploadStatusText.textContent = 'Loading photos...';
      if(uploadProgressBar) uploadProgressBar.style.width = '10%';
      if(uploadPercentage) uploadPercentage.textContent = '10%';
      
      try {
        console.log("STEP selfie->match_selfie");
        console.log("Inizio matchPhotos: invio selfie al server...");
        
        // Aggiorna progress
        if(uploadProgressBar) uploadProgressBar.style.width = '30%';
        if(uploadPercentage) uploadPercentage.textContent = '30%';
        if(uploadStatusText) uploadStatusText.textContent = 'Sending selfie to server...';
        
      const fd = new FormData();
        fd.append("selfie", capturedBlob, "selfie.jpg");
        
        // Simula progress durante upload (XMLHttpRequest per avere progress reale)
        const xhr = new XMLHttpRequest();
        
        // Promise per gestire la risposta
        const uploadPromise = new Promise((resolve, reject) => {
          xhr.upload.addEventListener('progress', (e) => {
            if(e.lengthComputable) {
              const percent = Math.round((e.loaded / e.total) * 50) + 30; // 30-80%
              if(uploadProgressBar) uploadProgressBar.style.width = percent + '%';
              if(uploadPercentage) uploadPercentage.textContent = percent + '%';
            }
          });
          
          xhr.addEventListener('load', () => {
            if(xhr.status >= 200 && xhr.status < 300) {
              resolve(xhr);
            } else {
              // Crea un errore con pi√π informazioni
              const error = new Error(`HTTP ${xhr.status}: ${xhr.statusText}`);
              error.status = xhr.status;
              error.statusText = xhr.statusText;
              error.responseText = xhr.responseText;
              reject(error);
            }
          });
          
          xhr.addEventListener('error', (e) => {
            console.error("XMLHttpRequest error event:", e);
            const error = new Error('Network error');
            error.type = 'network';
            reject(error);
          });
          
          xhr.addEventListener('timeout', () => {
            console.error("XMLHttpRequest timeout");
            const error = new Error('Request timeout');
            error.type = 'timeout';
            reject(error);
          });
          
          xhr.addEventListener('abort', () => {
            const error = new Error('Upload aborted');
            error.type = 'abort';
            reject(error);
          });
          
          // Imposta timeout di 120 secondi (Render pu√≤ essere lento al risveglio)
          xhr.timeout = 120000;
          
          // Aggiungi email se disponibile
          // min_score non passato: usa default server (0.35) che √® pi√π sicuro
          let url = '/match_selfie?top_k_faces=120';
          if(userEmail) {
            url += `&email=${encodeURIComponent(userEmail)}`;
          }
          
          xhr.open('POST', url);
          xhr.send(fd);
        });
        
        // Aggiorna progress
        if(uploadProgressBar) uploadProgressBar.style.width = '80%';
        if(uploadPercentage) uploadPercentage.textContent = '80%';
        if(uploadStatusText) uploadStatusText.textContent = 'Analyzing photos...';
        
        await uploadPromise;
        
        const res = xhr;
        console.log("‚úÖ Risposta ricevuta, status:", res.status, "OK:", res.status >= 200 && res.status < 300);
        console.log("Response text length:", res.responseText ? res.responseText.length : 0);
        console.log("Response type:", res.responseType);
        console.log("Response headers:", res.getAllResponseHeaders());
        
        // Log primi caratteri della risposta per debug
        if(res.responseText && res.responseText.length > 0) {
          console.log("Response preview (primi 200 char):", res.responseText.substring(0, 200));
        }
        
        // Controlla se la risposta √® OK
        if(res.status < 200 || res.status >= 300) {
          console.error("‚ùå Errore HTTP:", res.status, res.statusText);
          console.error("Response text completo:", res.responseText);
          
          // Usa sempre il messaggio richiesto per tutti gli errori
          const errorMsg = "No photos found or still processing. Please try again.";
          
          // Mostra errore con bottone "Rifai selfie"
          showSelfieError(errorMsg);
          return;
        }
        
        // Aggiorna progress finale
        if(uploadProgressBar) uploadProgressBar.style.width = '100%';
        if(uploadPercentage) uploadPercentage.textContent = '100%';
        if(uploadStatusText) uploadStatusText.textContent = 'Completato!';
        
        // Nascondi loading quando tutto va bene (verr√† mostrato l'album)
        showSelfieLoading(false);
        
        // Verifica che la risposta non sia vuota
        if(!res.responseText || res.responseText.trim() === '') {
          console.error("Risposta vuota dal server");
          throw new Error('Empty response from server');
        }
        
        let data;
        try {
          data = JSON.parse(res.responseText);
          console.log("[match_selfie] raw data", data);
        } catch(parseError) {
          console.error("Errore parsing JSON:", parseError);
          console.error("Response text (primi 500 caratteri):", res.responseText.substring(0, 500));
          throw new Error(`Invalid JSON response: ${parseError.message}`);
        }
        
        // Parsing robusto: estrai photo_ids da vari campi possibili
        const mainIds =
          data.photo_ids || data.photoIds ||
          data.matched_photo_ids ||
          (Array.isArray(data.matched_results) ? data.matched_results.map(x => x.photo_id || x.photoId).filter(Boolean) : []) ||
          (Array.isArray(data.matchedResults) ? data.matchedResults.map(x => x.photo_id || x.photoId).filter(Boolean) : []) ||
          [];
        
        const backIds =
          data.back_photos || data.backPhotos ||
          [];
        
        // Estrai anche da results/matches (array di oggetti)
        const resultsIds = [];
        if (Array.isArray(data.results)) {
          data.results.forEach(item => {
            if (item.photo_id) resultsIds.push(item.photo_id);
            else if (item.photoId) resultsIds.push(item.photoId);
          });
        }
        if (Array.isArray(data.matches)) {
          data.matches.forEach(item => {
            if (item.photo_id && !resultsIds.includes(item.photo_id)) resultsIds.push(item.photo_id);
            else if (item.photoId && !resultsIds.includes(item.photoId)) resultsIds.push(item.photoId);
          });
        }
        
        // Combina tutti gli ID unici
        const allIds = [...new Set([...(mainIds||[]), ...(backIds||[]), ...resultsIds].filter(Boolean))];
        console.log("[match_selfie] allIds", allIds);
        
        // Se non ci sono foto, mostra errore
        if (allIds.length === 0) {
          console.warn("‚ö†Ô∏è Nessuna foto trovata - allIds √® vuoto");
          showSelfieError("Nessuna foto trovata per questo selfie. Riprova con un selfie pi√π frontale/luminoso.");
          return;
        }
        
        // Se ci sono foto, mostra l'album
        console.log(`‚úÖ Trovate ${allIds.length} foto, mostrando album`);
        
        // Converti allIds in formato allPhotos
        const photos = data.results || data.matches || [];
        
        if(data.ok && allIds.length > 0) {
          console.log(`Trovate ${photos.length} foto`);
          console.log("STEP selfie->match_selfie");
          if(uploadStatusText) uploadStatusText.textContent = `Found ${photos.length} photos!`;
          
          // Nascondi upload status
          setTimeout(() => {
            if(uploadStatus) uploadStatus.classList.remove('active');
            if(captureBtn) {
              captureBtn.disabled = false;
              captureBtn.style.opacity = '1';
            }
          }, 500);
          
          // STEP 3: Dopo match_selfie completato, mostra album direttamente
          // Converti allIds in formato allPhotos
          // Se abbiamo results/matches con oggetti completi, usali, altrimenti crea oggetti semplici da allIds
          if (photos.length > 0) {
            allPhotos = photos.map(p => ({
              photo_id: p.photo_id || p.photoId || p.get?.('photo_id'),
              score: p.score || p.get?.('score', 0) || 0,
              has_face: true,
              paid: false,
              thumb_url: p.thumb_url || null,
              wm_url: p.wm_url || null,
              paid_url: p.paid_url || null
            }));
          } else {
            // Se non abbiamo oggetti completi, crea oggetti semplici da allIds
            allPhotos = allIds.map(photoId => ({
              photo_id: photoId,
              score: 0,
              has_face: true,
              paid: false
            }));
          }
          
          // Assicurati che tutti gli allIds siano presenti in allPhotos
          const existingIds = new Set(allPhotos.map(p => p.photo_id));
          allIds.forEach(id => {
            if (!existingIds.has(id)) {
              allPhotos.push({
                photo_id: id,
                score: 0,
                has_face: true,
                paid: false
              });
            }
          });
          
          photosLoadedCount = 0;
          paidPhotos = [];
          
          // Mostra album direttamente
          showScreen('album');
          await displayPhotos();
          
          // Aggiorna carrello
          updateCart();
          
          // Mostra sticky offer bar se ci sono foto non pagate
          if(allPhotos.length > 0) {
            showStickyOfferBar();
          }
        } else {
          // Questo blocco viene raggiunto solo se data.ok √® false MA allIds.length > 0
          // In questo caso, mostra comunque l'album usando allIds
          console.warn("‚ö†Ô∏è data.ok √® false ma allIds.length > 0, mostrando comunque album");
          console.warn("data.ok:", data.ok);
          console.warn("allIds.length:", allIds.length);
          
          // Se abbiamo foto in allIds, mostrale comunque
          if (allIds.length > 0) {
            console.log("‚ö†Ô∏è Fallback: usando allIds per mostrare album (data.ok=false)");
            allPhotos = allIds.map(photoId => ({
              photo_id: photoId,
              score: 0,
              has_face: true,
              paid: false
            }));
            photosLoadedCount = 0;
            paidPhotos = [];
            showScreen('album');
          await displayPhotos();
            updateCart();
            if(allPhotos.length > 0) {
              showStickyOfferBar();
            }
            return;
          }
          
          // Solo se davvero non ci sono foto, mostra errore
          console.warn("‚ö†Ô∏è Nessuna foto trovata - allIds √® vuoto e data.ok √® false");
          showSelfieError("Nessuna foto trovata per questo selfie. Riprova con un selfie pi√π frontale/luminoso.");
          
          // Controlla se ci sono foto gi√† acquistate da mostrare (stateless: disabilitato)
          if(false && userEmail) {
            // Mostra schermata subito, fetch in background
            showScreen('album');
            setTimeout(async () => {
            try {
                const paidData = await fetchUserPhotos(userEmail);
              
              if(paidData && paidData.ok && paidData.paid_photos && paidData.paid_photos.length > 0) {
                // Ci sono foto pagate - mostrale nell'album
                paidPhotos = paidData.paid_photos;
                allPhotos = paidData.paid_photos.map(photoId => ({
                  photo_id: photoId,
                  score: 0,
                  has_face: true,
                  paid: true
                }));
                
                photosLoadedCount = 0;
                
                // Nascondi upload status
                if(uploadStatus) uploadStatus.classList.remove('active');
                if(captureBtn) {
                  captureBtn.disabled = false;
                  captureBtn.style.opacity = '1';
                }
                
                // Album gi√† mostrato sopra, aggiorna carrello
                updateCart();
                await displayPhotos();
                showStickyOfferBar(allPhotos.length);
              } else {
                console.log('No paid photos found');
              }
            } catch(e) {
              console.error('Errore caricamento foto pagate:', e);
              if(e.message && e.message.includes('timeout')) {
                alert('Request timeout. Please check your connection and try again.');
              } else {
                alert('Error loading photos. Please try again.');
            }
            }
          }, 0);
          }
          
          // Nessuna foto trovata e nessuna foto pagata
          // Nascondi upload status
          if(uploadStatus) uploadStatus.classList.remove('active');
          if(captureBtn) {
            captureBtn.disabled = false;
            captureBtn.style.opacity = '1';
          }
          
          // NON tornare alla welcome se siamo gi√† nell'album
          // Solo se siamo ancora nella schermata selfie/confirm
          if(currentScreen !== 'album') {
            alert('No photos found. Try again.');
            showScreen('selfie');
            startCamera();
          } else {
            // Se siamo gi√† nell'album, mostra solo un messaggio
            alert('No photos found. Try again.');
          }
        }
      } catch(err) {
        console.error("Errore nel caricamento foto:", err);
        console.error("Stack trace:", err.stack);
        console.error("Tipo errore:", err.name, "Messaggio:", err.message);
        console.error("Error type:", err.type, "Status:", err.status);
        
        // Usa sempre il messaggio richiesto per tutti gli errori (503, network, timeout, ecc.)
        const errorMessage = "No photos found or still processing. Please try again.";
        
        // Mostra errore con bottone "Rifai selfie"
        showSelfieError(errorMessage);
      }
    }

    // Guardia anti-doppio fetch per /user/photos
    let photosFetchInFlight = null;
    
    // Funzione centralizzata per fetch /user/photos con timeout e guardia anti-doppio
    async function fetchUserPhotos(email, timeoutMs = 15000) {
      if(!email) {
        console.error("fetchUserPhotos: email is required");
        return null;
      }
      
      // Guardia anti-doppio: se c'√® gi√† una fetch in corso, ritorna quella
      if(photosFetchInFlight) {
        console.log("fetchUserPhotos: already in flight, returning existing promise");
        return photosFetchInFlight;
      }
      
      // Crea AbortController per timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        controller.abort();
      }, timeoutMs);
      
      // Crea promise con guardia
      photosFetchInFlight = (async () => {
        try {
          console.log(`fetchUserPhotos: fetching for ${email}`);
          const res = await fetch(`/user/photos?email=${encodeURIComponent(email)}`, {
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if(!res.ok) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
          
          const data = await res.json();
          console.log(`fetchUserPhotos: success for ${email}`);
          return data;
        } catch(e) {
          clearTimeout(timeoutId);
          if(e.name === 'AbortError') {
            console.error(`fetchUserPhotos: timeout after ${timeoutMs}ms for ${email}`);
            throw new Error(`Request timeout after ${timeoutMs}ms. Please try again.`);
          }
          console.error(`fetchUserPhotos: error for ${email}:`, e);
          throw e;
        } finally {
          // Reset guardia dopo un breve delay per evitare race conditions
          setTimeout(() => {
            photosFetchInFlight = null;
          }, 100);
        }
      })();
      
      return photosFetchInFlight;
    }

    // Intersection Observer per lazy loading
    let imageObserver = null;
    
    function initImageObserver() {
      if(imageObserver) {
        imageObserver.disconnect();
      }
      
      imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if(entry.isIntersecting) {
            const img = entry.target;
            const photoId = img.dataset.photoId;
            const index = parseInt(img.dataset.index);
            
            // Carica l'immagine solo quando entra nel viewport
            if(!img.dataset.loaded) {
              img.dataset.loaded = 'true';
              const imgElement = new Image();
              
              imgElement.onload = () => {
                img.src = imgElement.src;
                img.classList.add('loaded');
                // Rimuovi skeleton
                const skeleton = img.parentElement.querySelector('.photo-skeleton');
                if(skeleton) skeleton.remove();
              };
              
              // Retry logic per 404 (thumb non ancora generato)
              let retryCount = 0;
              const maxRetries = 3;
              const retryDelay = 500; // ms
              
              const tryLoadLazyImage = () => {
                // Usa thumb_url se disponibile (precomputato), altrimenti fallback
                const photoObj = allPhotos.find(p => p.photo_id === photoId);
                let photoUrl = photoObj?.thumb_url || `/photo/${encodeURIComponent(photoId)}?variant=thumb`;
                imgElement.src = photoUrl;
              };
              
              imgElement.onerror = () => {
                retryCount++;
                if(retryCount < maxRetries) {
                  // Retry dopo delay (thumb potrebbe essere in generazione)
                  console.log(`[RETRY] Thumb not ready for ${photoId}, retrying (${retryCount}/${maxRetries})...`);
                  setTimeout(tryLoadLazyImage, retryDelay * retryCount); // Backoff esponenziale
                } else {
                  // Max retries raggiunto: rimuovi completamente la card dal DOM
                  console.error('Thumb not ready after retries, removing card:', photoId);
                  const cardDiv = img.closest('.album-photo');
                  if(cardDiv && cardDiv.parentNode) {
                    imageObserver.unobserve(img);
                    cardDiv.parentNode.removeChild(cardDiv);
                  }
                }
              };
              
              tryLoadLazyImage();
            }
            
            imageObserver.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px' // Inizia a caricare 50px prima che entri nel viewport
      });
    }
    
    function checkAllPhotosLoaded() {
      photosLoadedCount++;
      // Quando tutte le prime immagini sono caricate, nascondi overlay
      const preloadCount = Math.min(9, allPhotos.length);
      if(photosLoadedCount >= preloadCount) {
        const loadingOverlay = document.getElementById('albumLoadingOverlay');
        if(loadingOverlay) {
          loadingOverlay.classList.remove('active');
        }
        enableAlbumInteractions();
      }
    }
    
    function disableAlbumInteractions() {
      // Disabilita SOLO i pulsanti, NON lo scroll
      // NON bloccare pointer-events sull'albumScreen per permettere lo scroll
      
      // Disabilita pulsanti specifici
      const albumCartBtn = document.getElementById('albumCartBtn');
      const albumBackBtn = document.getElementById('albumBackBtn');
      const myContentTab = document.getElementById('myContentTab');
      const pricesTab = document.getElementById('pricesTab');
      if(albumCartBtn) {
        albumCartBtn.style.pointerEvents = 'none';
        albumCartBtn.style.opacity = '0.5';
      }
      if(albumBackBtn) {
        albumBackBtn.style.pointerEvents = 'none';
        albumBackBtn.style.opacity = '0.5';
      }
      if(myContentTab) {
        myContentTab.style.pointerEvents = 'none';
        myContentTab.style.opacity = '0.5';
      }
      if(pricesTab) {
        pricesTab.style.pointerEvents = 'none';
        pricesTab.style.opacity = '0.5';
      }
      
      // Disabilita click sulle foto durante il caricamento
      const photos = albumGrid.querySelectorAll('.album-photo');
      photos.forEach(photo => {
        photo.style.pointerEvents = 'none';
      });
    }
    
    function enableAlbumInteractions() {
      // Riabilita pulsanti
      const albumCartBtn = document.getElementById('albumCartBtn');
      const albumBackBtn = document.getElementById('albumBackBtn');
      const myContentTab = document.getElementById('myContentTab');
      const pricesTab = document.getElementById('pricesTab');
      if(albumCartBtn) {
        albumCartBtn.style.pointerEvents = 'auto';
        albumCartBtn.style.opacity = '1';
      }
      if(albumBackBtn) {
        albumBackBtn.style.pointerEvents = 'auto';
        albumBackBtn.style.opacity = '1';
      }
      if(myContentTab) {
        myContentTab.style.pointerEvents = 'auto';
        myContentTab.style.opacity = '1';
      }
      if(pricesTab) {
        pricesTab.style.pointerEvents = 'auto';
        pricesTab.style.opacity = '1';
      }
      
      // Riabilita click sulle foto
      const photos = albumGrid.querySelectorAll('.album-photo');
      photos.forEach(photo => {
        photo.style.pointerEvents = 'auto';
      });
    }
    
    // Funzione semplificata per caricare foto pagate
    async function loadPaidPhotos() {
      if(!userEmail) {
        // Stateless: userEmail non persistente
      }
      if(!userEmail) return paidPhotos;
      
      try {
        const res = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
      const data = await res.json();
        if(data.ok) {
          paidPhotos = [];
          if(data.paid_photos) paidPhotos = [...data.paid_photos];
          if(data.found_photos) {
            const paidFromFound = data.found_photos
              .filter(p => p.status === 'paid')
              .map(p => p.photo_id);
            paidPhotos = [...new Set([...paidPhotos, ...paidFromFound])];
          }
        }
      } catch(e) {
        console.error("Error loading paid photos:", e);
      }
      return paidPhotos;
    }
    
    async function displayPhotos() {
      // Carrello sempre vuoto all'inizio (non persistente, si svuota ad ogni refresh)
      initCart();
      // Reset photosLoaded all'inizio
      photosLoaded = false;
      
      if(!allPhotos || allPhotos.length === 0) {
        console.warn("displayPhotos chiamato ma non ci sono foto!");
        // NON mostrare alert, NON chiamare showSelfieError, NON avviare camera
        // L'utente pu√≤ tornare al selfie manualmente se vuole
        return;
      }

      // Carica foto pagate prima di renderizzare
      await loadPaidPhotos();
      
      // NON rimuovere le foto pagate dall'album - le mostriamo con badge "Acquistata"
      // Le foto pagate saranno visibili ma non selezionabili per il carrello
      const paidPhotoIdsSet = new Set(paidPhotos);
      const unpaidPhotos = allPhotos.filter(photo => !paidPhotoIdsSet.has(photo.photo_id));
      const paidCount = allPhotos.length - unpaidPhotos.length;
      
      if(paidCount > 0) {
        console.log(`Mostrando ${paidCount} foto pagate nell'album con badge "Acquistata"`);
      }
      
      const loadingOverlay = document.getElementById('albumLoadingOverlay');
      const loadingText = document.getElementById('albumLoadingText');
      
      // Reset counter
      photosLoadedCount = 0;
      
      // Mostra overlay di caricamento
      if(loadingOverlay) {
        loadingOverlay.classList.add('active');
        if(loadingText) loadingText.textContent = 'Loading photos...';
      }
      
      // Disabilita interazioni
      disableAlbumInteractions();
      
      albumGrid.innerHTML = '';
      
      // Lazy loading ottimizzato: preload delle prime foto visibili
      // Con ~10-12 foto per utente, non serve virtual scrolling
      const PRELOAD_COUNT = Math.min(6, allPhotos.length); // Preload prime 6 foto (quelle visibili subito)
      
      // Nascondi overlay dopo che le prime 6 foto sono caricate (per percepire velocit√†)
      let firstPhotosLoaded = 0;
      const hideOverlayAfter = 6;
      
      // Renderizza tutte le foto (con lazy loading per quelle non visibili)
      allPhotos.forEach((photo, index) => {
        const div = document.createElement('div');
        div.className = 'album-photo';

        const img = document.createElement('img');
        img.dataset.photoId = photo.photo_id;
        img.dataset.index = index;
        img.alt = photo.photo_id;
        img.loading = 'lazy';
        img.decoding = 'async';
        
        // Skeleton loader
        const skeleton = document.createElement('div');
        skeleton.className = 'photo-skeleton';
        
        // Per le prime immagini visibili, carica subito con priorit√† alta
        if(index < PRELOAD_COUNT) {
          img.dataset.loaded = 'true';
          const imgElement = new Image();
          imgElement.onload = () => {
            img.src = imgElement.src;
            img.classList.add('loaded');
            skeleton.remove();
            firstPhotosLoaded++;
            
            // Nascondi overlay dopo le prime foto caricate (per percepire velocit√†)
            if(firstPhotosLoaded >= hideOverlayAfter && loadingOverlay && loadingOverlay.classList.contains('active')) {
              loadingOverlay.classList.remove('active');
              enableAlbumInteractions();
            }
            
            checkAllPhotosLoaded();
          };
          // Retry logic per 404 (thumb non ancora generato)
          let retryCount = 0;
          const maxRetries = 3;
          const retryDelay = 500; // ms
          
          const tryLoadImage = () => {
            // Usa thumb_url se disponibile (precomputato, veloce), altrimenti fallback
            let photoUrl = photo.thumb_url || `/photo/${encodeURIComponent(photo.photo_id)}?variant=thumb`;
          
          // Per le prime 6 foto, usa fetchpriority per caricamento pi√π veloce
          if(index < 6) {
            img.fetchPriority = 'high';
          }
          
          imgElement.src = photoUrl;
          };
          
          imgElement.onerror = () => {
            retryCount++;
            if(retryCount < maxRetries) {
              // Retry dopo delay (thumb potrebbe essere in generazione)
              console.log(`[RETRY] Thumb not ready for ${photo.photo_id}, retrying (${retryCount}/${maxRetries})...`);
              setTimeout(tryLoadImage, retryDelay * retryCount); // Backoff esponenziale
            } else {
              // Max retries raggiunto: rimuovi completamente la card dal DOM
              console.error('Thumb not ready after retries, removing card:', photo.photo_id);
              if(div && div.parentNode) {
                div.parentNode.removeChild(div);
              }
              firstPhotosLoaded++;
              checkAllPhotosLoaded();
            }
          };
          
          tryLoadImage();
        }
        
        // Aggiungi classe photo-card per stili
        div.classList.add('photo-card');
        div.dataset.photoId = photo.photo_id;
        
        // Se la foto √® pagata, mostra solo badge "Pagata"
        const isPaid = paidPhotos.includes(photo.photo_id) || photo.paid === true;
        if(isPaid) {
          // Assicurati che la foto sia in paidPhotos
          if(!paidPhotos.includes(photo.photo_id)) {
            paidPhotos.push(photo.photo_id);
          }
          // Badge "Pagata" pulito e piccolo in alto a sinistra
          const paidText = document.createElement('div');
          paidText.className = 'photo-paid-text';
          paidText.textContent = '‚úì Pagata';
          paidText.style.cssText = 'position: absolute; top: 10px; left: 10px; background: rgba(76, 175, 80, 0.9); color: white; padding: 6px 10px; border-radius: 8px; font-size: 12px; font-weight: 600; z-index: 10; pointer-events: none; box-shadow: 0 2px 4px rgba(0,0,0,0.2);';
          div.appendChild(paidText);
          div.classList.add('photo-paid');
        } else {
          // Icona "+" o "‚úì" verde in alto a destra solo per foto non pagate
          const addCartBtn = document.createElement('button');
          addCartBtn.className = 'add-to-cart-btn';
          addCartBtn.dataset.photoId = photo.photo_id;
          addCartBtn.type = 'button';
          addCartBtn.innerHTML = '<span class="btn-icon">+</span><span class="btn-check">‚úì</span>';
          
          // Verifica se la foto √® gi√† nel carrello
          const isInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photo.photo_id);
          if(isInCart) {
            addCartBtn.classList.add('is-added');
            addCartBtn.setAttribute('aria-label', 'Rimuovi dal carrello');
          } else {
            addCartBtn.setAttribute('aria-label', 'Aggiungi al carrello');
          }
          
          // Click sull'icona fa toggle add/remove SENZA aprire viewer
          // Feedback visivo immediato (ottimistico update) con animazione "pop"
          addCartBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const wasInCart = addCartBtn.classList.contains('is-added');
            
            // Aggiungi animazione "pop"
            addCartBtn.classList.add('pop');
            setTimeout(() => {
              addCartBtn.classList.remove('pop');
            }, 160);
            
            // Aggiorna immediatamente lo stato visivo (ottimistico)
            if(wasInCart) {
              addCartBtn.classList.remove('is-added');
              addCartBtn.setAttribute('aria-label', 'Aggiungi al carrello');
            } else {
              addCartBtn.classList.add('is-added');
              addCartBtn.setAttribute('aria-label', 'Rimuovi dal carrello');
            }
            
            try {
              if(wasInCart) {
                // Rimuovi dal carrello
                await removeFromCart(photo.photo_id);
              } else {
                // Aggiungi al carrello
                await addToCart(photo.photo_id);
              }
            } catch(err) {
              console.error('Error toggling cart:', err);
              // In caso di errore, ripristina lo stato visivo
              if(wasInCart) {
                addCartBtn.classList.add('is-added');
                addCartBtn.setAttribute('aria-label', 'Rimuovi dal carrello');
              } else {
                addCartBtn.classList.remove('is-added');
                addCartBtn.setAttribute('aria-label', 'Aggiungi al carrello');
              }
            }
          });
          
          div.appendChild(addCartBtn);
        }
        
        div.appendChild(skeleton);
        div.appendChild(img);
        
        // Click sull'immagine apre SOLO il viewer (non aggiunge al carrello)
        img.addEventListener('click', (e) => {
          e.stopPropagation();
          openLightbox(index);
        });
        
        // Blocca long-press e salvataggio su immagini pre-acquisto
        img.style.webkitTouchCallout = 'none';
        img.style.webkitUserSelect = 'none';
        img.style.userSelect = 'none';
        albumGrid.appendChild(div);
      });
      
      // Inizializza observer dopo che tutti gli elementi sono nel DOM
      setTimeout(() => {
        initImageObserver();
        // Osserva tutte le immagini non ancora caricate
        albumGrid.querySelectorAll('img:not([data-loaded="true"])').forEach(img => {
          imageObserver.observe(img);
        });
      }, 100);
      
      // Fallback: nascondi overlay dopo max 2 secondi se non √® gi√† stato nascosto
      setTimeout(() => {
        if(loadingOverlay && loadingOverlay.classList.contains('active')) {
          loadingOverlay.classList.remove('active');
          enableAlbumInteractions();
        }
      }, 2000);
      
      // Aggiorna sticky bar e nudge bar
      updateStickyAllOffer();
      updateNudgeBar();
      
      // Mostra sticky bar se ci sono foto
      if(allPhotos.length > 0) {
        const stickyBar = document.getElementById('stickyOfferBar');
        if(stickyBar) {
          stickyBar.classList.add('active');
          stickyBar.style.display = 'flex';
        }
      } else {
        // Nascondi sticky bar se non ci sono foto
        const stickyBar = document.getElementById('stickyOfferBar');
        if(stickyBar) {
          stickyBar.classList.remove('active');
          stickyBar.style.display = 'none';
        }
      }
    }

    function showStickyOfferBar(photoCount) {
      const stickyBar = document.getElementById('stickyOfferBar');
      const stickyText = document.getElementById('stickyOfferText');
      const stickyPrice = document.getElementById('stickyOfferPrice');
      const stickyBuyBtn = document.getElementById('stickyOfferBuyBtn');
      const photoCountBanner = document.getElementById('albumPhotoCount');
      const photoCountNumber = document.getElementById('photoCountNumber');
      const albumScreen = document.getElementById('albumScreen');
      
      if(!stickyBar) {
        console.warn("Sticky offer bar non trovato");
        return;
      }
      
      // Verifica che lo schermo album sia attivo E le foto siano state renderizzate
      if(!albumScreen || !albumScreen.classList.contains('active')) {
        console.warn("Schermo album non attivo, aspetto...");
        setTimeout(() => showStickyOfferBar(photoCount), 200);
        return;
      }
      
      // Verifica che le foto siano state caricate
      if(!photosLoaded) {
        console.warn("Foto non ancora caricate, aspetto...");
        setTimeout(() => showStickyOfferBar(photoCount), 200);
        return;
      }
      
      // Mostra banner conteggio foto sopra la griglia
      if(photoCountBanner && photoCountNumber) {
        photoCountNumber.textContent = photoCount;
        const foundText = `You found ${photoCount} photos`;
        photoCountBanner.innerHTML = foundText;
        photoCountBanner.style.display = 'block';
      }
      
      // Calcola prezzo
      const priceCents = calculatePrice(photoCount);
      const priceEuros = (priceCents / 100).toFixed(2);
      
      // Messaggio personalizzato in base al numero di foto
      let message = "";
      if(photoCount === 1) {
        message = 'Prendi la tua foto';
      } else {
        message = `Prendi tutte le ${photoCount} foto`;
      }
      
      if(stickyText) {
        stickyText.textContent = message;
      }
      
      if(stickyPrice) {
        stickyPrice.textContent = `‚Ç¨${priceEuros}`;
      }
      
      if(stickyBuyBtn) {
        stickyBuyBtn.textContent = 'Sblocca tutte';
        stickyBuyBtn.style.padding = '10px 24px';
        stickyBuyBtn.style.fontSize = '14px';
        stickyBuyBtn.style.fontWeight = '700';
      }
      
      // Event listener per pulsante acquista (se non gi√† presente)
      if(stickyBuyBtn && !stickyBuyBtn.dataset.listenerAdded) {
        stickyBuyBtn.addEventListener('click', () => {
          startCheckoutForAllPhotos(); // Checkout per tutte le foto
        });
        stickyBuyBtn.dataset.listenerAdded = 'true';
      }
      
      // Pulsante chiudi rimosso - il banner rimane sempre visibile
      
      // Mostra banner con animazione
      stickyBar.style.display = 'flex';
      stickyBar.classList.add('active');
      
      // Mostra countdown banner se ci sono foto pagate
      showPaidCountdownBanner();
    }
    
    function showPaidCountdownBanner() {
      const countdownBanner = document.getElementById('paidCountdownBanner');
      const countdownText = document.getElementById('paidCountdownText');
      const countdownDays = document.getElementById('paidCountdownDays');
      
      if(!countdownBanner || paidPhotos.length === 0) {
      return;
    }

      // Calcola giorni rimanenti (30 giorni dalla data di pagamento)
      // Per ora usiamo una stima: assumiamo che le foto siano state pagate oggi
      // In futuro potremmo recuperare la data di scadenza dal server
      const daysRemaining = 30; // Default, in futuro recuperare da server
      
      if(daysRemaining > 0) {
        // Traduci il messaggio
        let message = "";
        if(currentLang === 'en') {
          message = `Your paid photos will expire in <strong>${daysRemaining}</strong> days`;
        } else if(currentLang === 'it') {
          message = `Le tue foto pagate scadranno tra <strong>${daysRemaining}</strong> giorni`;
        } else if(currentLang === 'fr') {
          message = `Vos photos pay√©es expireront dans <strong>${daysRemaining}</strong> jours`;
        } else if(currentLang === 'de') {
          message = `Ihre bezahlten Fotos laufen in <strong>${daysRemaining}</strong> Tagen ab`;
        } else if(currentLang === 'es') {
          message = `Tus fotos pagadas expirar√°n en <strong>${daysRemaining}</strong> d√≠as`;
        } else {
          message = `Le tue foto pagate scadranno tra <strong>${daysRemaining}</strong> giorni`;
        }
        
        if(countdownText) {
          countdownText.innerHTML = message;
        }
        if(countdownDays) {
          countdownDays.textContent = daysRemaining;
        }
        
        // Mostra banner con animazione
        setTimeout(() => {
          countdownBanner.classList.add('show');
        }, 500);
      }
    }

    function openLightbox(index) {
      // Previeni l'apertura se le foto stanno ancora caricando
      const loadingOverlay = document.getElementById('albumLoadingOverlay');
      if(loadingOverlay && loadingOverlay.classList.contains('active')) {
        return; // Non fare nulla se sta caricando
      }
      
      currentPhotoIndex = index;
      const photo = allPhotos[index];
      
      // Verifica che lightboxImage e photoLightbox esistano
      if(!lightboxImage || !photoLightbox) {
        console.error('Lightbox elements not found');
        return;
      }
      
      // Preload dell'immagine prima di mostrarla
      const img = new Image();
      img.onload = () => {
        if(lightboxImage) {
          lightboxImage.src = img.src;
        }
        updateLightboxCounter();
        if(photoLightbox) {
          photoLightbox.classList.add('active');
        }
      };
      img.onerror = () => {
        alert('Connection error. Check your internet connection and try again.');
      };
      
      // Usa wm_url per foto non pagate, paid_url per foto pagate
      const isPaid = paidPhotos.includes(photo.photo_id) || photo.paid === true;
      let photoUrl;
      if(isPaid) {
        // Foto pagata: usa paid_url se disponibile, altrimenti costruisci URL
        photoUrl = photo.paid_url || `/photo/${encodeURIComponent(photo.photo_id)}?paid=true`;
        if(userEmail) {
        photoUrl += `&email=${encodeURIComponent(userEmail)}`;
        }
      } else {
        // Foto non pagata: usa wm_url (precomputato, veloce)
        photoUrl = photo.wm_url || `/photo/${encodeURIComponent(photo.photo_id)}?variant=wm`;
      }
      img.src = photoUrl;
      
      // Mostra/nascondi frecce
      const prevBtn = document.getElementById('lightboxPrev');
      const nextBtn = document.getElementById('lightboxNext');
      const downloadBtn = document.getElementById('lightboxDownload');
      if(prevBtn) {
        prevBtn.style.display = allPhotos.length > 1 ? 'flex' : 'none';
      }
      if(nextBtn) {
        nextBtn.style.display = allPhotos.length > 1 ? 'flex' : 'none';
      }
      
      // Gestione download, istruzioni iOS e CTA carrello
      const iosInstruction = document.getElementById('lightboxIOSInstruction');
      const cartCTA = document.getElementById('lightboxCartCTA');
      const addCartBtnLightbox = document.getElementById('lightboxAddCartBtn');
      
      if(isPaid) {
        // Foto pagata: PERMETTI long-press iOS per salvare
        // Rimuovi blocchi CSS che impediscono long-press
        if(lightboxImage) {
          lightboxImage.style.webkitTouchCallout = 'default';
          lightboxImage.style.webkitUserSelect = 'auto';
          lightboxImage.style.userSelect = 'auto';
        }
        
        // Foto pagata: mostra download/istruzioni iOS come prima
        if(cartCTA) {
          cartCTA.style.display = 'none';
        }
        if(isIOS()) {
          if(downloadBtn) {
            downloadBtn.style.display = 'none';
          }
          if(iosInstruction) {
            iosInstruction.style.display = 'block';
          }
        } else {
          if(downloadBtn) {
            downloadBtn.style.display = 'block';
            downloadBtn.onclick = () => downloadPhoto(photo.photo_id);
          }
          if(iosInstruction) {
            iosInstruction.style.display = 'none';
          }
        }
      } else {
        // Foto NON pagata: BLOCCA long-press (watermark)
        if(lightboxImage) {
          lightboxImage.style.webkitTouchCallout = 'none';
          lightboxImage.style.webkitUserSelect = 'none';
          lightboxImage.style.userSelect = 'none';
        }
        // Foto NON pagata: mostra CTA carrello (pre-acquisto)
        if(downloadBtn) {
          downloadBtn.style.display = 'none';
        }
        if(iosInstruction) {
          iosInstruction.style.display = 'none';
        }
        if(cartCTA) {
          cartCTA.style.display = 'block';
          // Verifica se √® gi√† nel carrello
          const isInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photo.photo_id);
          if(addCartBtnLightbox) {
            if(isInCart) {
              addCartBtnLightbox.textContent = 'Rimuovi dal carrello';
              addCartBtnLightbox.style.background = '#ff4444';
              addCartBtnLightbox.style.color = 'white';
            } else {
              addCartBtnLightbox.textContent = 'Aggiungi al carrello';
              addCartBtnLightbox.style.background = 'white';
              addCartBtnLightbox.style.color = 'rgba(123, 116, 255, 1)';
            }
            addCartBtnLightbox.onclick = (e) => {
              e.stopPropagation();
              toggleCart(photo.photo_id, null);
              // Aggiorna il bottone dopo toggle
              setTimeout(() => {
                const newIsInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photo.photo_id);
                if(addCartBtnLightbox) {
                  if(newIsInCart) {
                    addCartBtnLightbox.textContent = 'Rimuovi dal carrello';
                    addCartBtnLightbox.style.background = '#ff4444';
                    addCartBtnLightbox.style.color = 'white';
                  } else {
                    addCartBtnLightbox.textContent = 'Aggiungi al carrello';
                    addCartBtnLightbox.style.background = 'white';
                    addCartBtnLightbox.style.color = 'rgba(123, 116, 255, 1)';
                  }
                }
              }, 100);
            };
          }
        }
      }
    }
    
    function updateLightboxCounter() {
      if(photoCounter) {
        photoCounter.textContent = `${currentPhotoIndex + 1}/${allPhotos.length}`;
      }
    }
    
    function nextPhoto() {
      if(!lightboxImage) return;
      if(currentPhotoIndex < allPhotos.length - 1) {
        currentPhotoIndex++;
        const photo = allPhotos[currentPhotoIndex];
        // Usa paid_url per foto pagate (senza watermark), wm_url per non pagate
        const isPaid = paidPhotos.includes(photo.photo_id) || photo.paid === true;
        let photoUrl;
        if(isPaid) {
          // Foto pagata: usa paid_url se disponibile (VELOCIT√Ä MASSIMA: originale R2)
          photoUrl = photo.paid_url || `/photo/${encodeURIComponent(photo.photo_id)}?paid=true`;
          if(userEmail && !photo.paid_url) {
            photoUrl += `&email=${encodeURIComponent(userEmail)}`;
          }
        } else {
          // Foto non pagata: usa wm_url (pre-generato, veloce)
          photoUrl = photo.wm_url || `/photo/${encodeURIComponent(photo.photo_id)}?variant=wm`;
        }
        lightboxImage.src = photoUrl;
        updateLightboxCounter();
        updateDownloadButton(photo.photo_id);
      }
    }
    
    function prevPhoto() {
      if(!lightboxImage) return;
      if(currentPhotoIndex > 0) {
        currentPhotoIndex--;
        const photo = allPhotos[currentPhotoIndex];
        // Usa paid_url per foto pagate (senza watermark), wm_url per non pagate
        const isPaid = paidPhotos.includes(photo.photo_id) || photo.paid === true;
        let photoUrl;
        if(isPaid) {
          // Foto pagata: usa paid_url se disponibile (VELOCIT√Ä MASSIMA: originale R2)
          photoUrl = photo.paid_url || `/photo/${encodeURIComponent(photo.photo_id)}?paid=true`;
          if(userEmail && !photo.paid_url) {
            photoUrl += `&email=${encodeURIComponent(userEmail)}`;
          }
        } else {
          // Foto non pagata: usa wm_url (pre-generato, veloce)
          photoUrl = photo.wm_url || `/photo/${encodeURIComponent(photo.photo_id)}?variant=wm`;
        }
        lightboxImage.src = photoUrl;
        updateLightboxCounter();
        updateDownloadButton(photo.photo_id);
      }
    }
    
    function updateDownloadButton(photoId) {
      const downloadBtn = document.getElementById('lightboxDownload');
      const iosInstruction = document.getElementById('lightboxIOSInstruction');
      const cartCTA = document.getElementById('lightboxCartCTA');
      const addCartBtnLightbox = document.getElementById('lightboxAddCartBtn');
      const isPaid = paidPhotos.includes(photoId);
      
      if(isPaid) {
        // Foto pagata: PERMETTI long-press iOS per salvare
        if(lightboxImage) {
          lightboxImage.style.webkitTouchCallout = 'default';
          lightboxImage.style.webkitUserSelect = 'auto';
          lightboxImage.style.userSelect = 'auto';
        }
        
        // Foto pagata: mostra download/istruzioni iOS
        if(cartCTA) {
          cartCTA.style.display = 'none';
        }
        if(isIOS()) {
          if(downloadBtn) {
            downloadBtn.style.display = 'none';
          }
          if(iosInstruction) {
            iosInstruction.style.display = 'block';
          }
        } else {
          if(downloadBtn) {
            downloadBtn.style.display = 'block';
            downloadBtn.onclick = () => downloadPhoto(photoId);
          }
          if(iosInstruction) {
            iosInstruction.style.display = 'none';
          }
        }
      } else {
        // Foto NON pagata: BLOCCA long-press (watermark)
        if(lightboxImage) {
          lightboxImage.style.webkitTouchCallout = 'none';
          lightboxImage.style.webkitUserSelect = 'none';
          lightboxImage.style.userSelect = 'none';
        }
        
        // Foto NON pagata: mostra CTA carrello
        if(downloadBtn) {
          downloadBtn.style.display = 'none';
        }
        if(iosInstruction) {
          iosInstruction.style.display = 'none';
        }
        if(cartCTA) {
          cartCTA.style.display = 'block';
          const isInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photoId);
          if(addCartBtnLightbox) {
            if(isInCart) {
              addCartBtnLightbox.textContent = 'Rimuovi dal carrello';
              addCartBtnLightbox.style.background = '#ff4444';
              addCartBtnLightbox.style.color = 'white';
            } else {
              addCartBtnLightbox.textContent = 'Aggiungi al carrello';
              addCartBtnLightbox.style.background = 'white';
              addCartBtnLightbox.style.color = 'rgba(123, 116, 255, 1)';
            }
          }
        }
      }
    }
    
    // Rileva se √® iOS
    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    }
    
    // Rileva se √® Android
    function isAndroid() {
      return /Android/i.test(navigator.userAgent);
    }
    
    async function downloadPhoto(photoId) {
      try {
        // Verifica che la foto sia pagata
        if(!paidPhotos.includes(photoId)) {
          alert("This photo has not been paid yet");
      return;
    }

        // Passa SEMPRE email per verifica backend (obbligatorio per foto pagate)
        if(!userEmail) {
          // Stateless: userEmail non persistente
        }
        
        if(!userEmail) {
          alert("Email not found. Please log in again.");
        return;
      }

        const filename = `${photoId}.jpg`;
        
        // Costruisci URL con paid=true, email e download=true per verifica backend e forzare download
        const photoUrl = `/photo/${encodeURIComponent(photoId)}?paid=true&email=${encodeURIComponent(userEmail)}&download=true`;
        
        // Su iOS: usa approccio semplice e diretto
        if(isIOS()) {
          try {
            // Prova prima con Web Share API (salva direttamente nella galleria)
            const response = await fetch(photoUrl);
            if(!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const blob = await response.blob();
            const file = new File([blob], filename, { type: 'image/jpeg' });
            
            if(navigator.share && navigator.canShare) {
              try {
                if(navigator.canShare({ files: [file] })) {
                  await navigator.share({
                    files: [file],
                    title: 'Salva foto',
                    text: 'Salva questa foto nella galleria'
                  });
                  return;
                }
              } catch(shareErr) {
                console.log('Web Share error:', shareErr);
              }
            }
          } catch(fetchError) {
            console.error('Errore fetch:', fetchError);
            alert('Error loading photo. Please try again.');
        return;
      }

          // Fallback: apri l'immagine direttamente usando l'URL
          // Su iOS Safari, questo permette all'utente di fare long-press e salvare
          const imgWindow = window.open(photoUrl, '_blank');
          
          if(imgWindow) {
            // Mostra istruzioni dopo un breve delay
            setTimeout(() => {
              alert('üì± Touch and hold the image, then select "Save to Photos" to save it to your gallery.');
            }, 800);
          } else {
            // Se popup bloccato, mostra istruzioni alternative
            alert('üì± Popup blocked. To save the photo:\n1. Touch and hold the image\n2. Select "Save to Photos"\n\nOr open this page in Safari.');
          }
        }
        // Su Android: download diretto (salva automaticamente nella galleria)
        else if(isAndroid()) {
          // photoUrl gi√† contiene download=true
          const link = document.createElement('a');
          link.href = photoUrl;
          link.download = filename;
          link.style.display = 'none';
          link.target = '_self';
          document.body.appendChild(link);
          link.click();
          
          setTimeout(() => {
            document.body.removeChild(link);
          }, 1000);
        }
        // Desktop: download normale
        else {
          // photoUrl gi√† contiene download=true
          const response = await fetch(photoUrl);
          if(!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const blob = await response.blob();
          const blobUrl = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = blobUrl;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(blobUrl);
        }
      } catch(e) {
        console.error("Error downloading photo:", e);
        alert("Error downloading photo. Please try again.");
      }
    }

    function toggleCart(photoId, buttonElement) {
        // Previeni l'aggiunta di foto pagate al carrello
        if(paidPhotos.includes(photoId)) {
          console.warn(`Photo ${photoId} is already paid, cannot add to cart`);
          alert("This photo has already been purchased. You can download it by clicking 'Download'.");
          return;
        }
        
        // Verifica se la foto √® gi√† nel carrello
        const isInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photoId);
        
        if(isInCart) {
        // Rimuovi dal carrello (istantaneo)
        removeFromCart(photoId);
        } else {
        // Aggiungi al carrello (istantaneo)
        addToCart(photoId);
      }
      
      // Aggiorna lo stato visivo del pulsante
          const btn = buttonElement || document.querySelector(`.add-to-cart-btn[data-photo-id="${photoId}"]`);
          if(btn) {
            if(isInCart) {
              // Foto rimossa dal carrello
              btn.classList.remove('is-added');
              btn.disabled = false;
              btn.setAttribute('aria-label', 'Add to cart');
            } else {
              // Foto aggiunta al carrello
              btn.classList.add('is-added');
          btn.disabled = false; // Non disabilitare, permettere rimozione
          btn.setAttribute('aria-label', 'Rimuovi dal carrello');
            }
          }
          
          // Aggiorna anche il bottone nel viewer se √® aperto
          const addCartBtnLightbox = document.getElementById('lightboxAddCartBtn');
          if(addCartBtnLightbox && photoLightbox && photoLightbox.classList.contains('active')) {
            const currentPhoto = allPhotos[currentPhotoIndex];
            if(currentPhoto && currentPhoto.photo_id === photoId) {
              const newIsInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photoId);
              if(newIsInCart) {
                addCartBtnLightbox.textContent = 'Rimuovi dal carrello';
                addCartBtnLightbox.style.background = '#ff4444';
                addCartBtnLightbox.style.color = 'white';
              } else {
                addCartBtnLightbox.textContent = 'Aggiungi al carrello';
                addCartBtnLightbox.style.background = 'white';
                addCartBtnLightbox.style.color = 'rgba(123, 116, 255, 1)';
              }
            }
      }
    }
    
    function addToCart(photoId) {
      // Previeni l'aggiunta di foto pagate al carrello
      if(paidPhotos.includes(photoId)) {
        console.warn(`Photo ${photoId} is already paid, cannot add to cart`);
        return;
      }
      
      // Aggiungi localmente (istantaneo)
      const updated = addToCartLocal(photoId);
      syncCart();
      
      // Aggiorna UI immediatamente
          const btn = document.querySelector(`.add-to-cart-btn[data-photo-id="${photoId}"]`);
          if(btn && !btn.classList.contains('is-added')) {
            btn.classList.add('is-added');
            btn.setAttribute('aria-label', 'Rimuovi dal carrello');
      }
    }

    function updateCart() {
      // Aggiorna solo se gli elementi esistono (sicuro anche se chiamato prima del DOM)
      try {
        if(albumCartCount) {
          albumCartCount.textContent = currentCart.count || 0;
        }
        if(albumCartPrice) {
          albumCartPrice.textContent = `‚Ç¨${(currentCart.price_euros || 0).toFixed(2)}`;
        }
        // buyAllPrice rimosso insieme al pulsante buyAllBtn
        if(buyAllPrice) {
          buyAllPrice.textContent = `‚Ç¨${(currentCart.price_euros || 0).toFixed(2)}`;
        }
      } catch(e) {
        // Ignora errori se elementi non esistono ancora
      }
    }
    
    function updateCartModal() {
      const cartItems = document.getElementById('cartItems');
      const cartTotal = document.getElementById('cartTotal');
      const checkoutBtn = document.getElementById('checkoutBtn');
      
      if(!cartItems || !cartTotal || !checkoutBtn) {
        console.warn('Cart modal elements not found');
        return;
      }
      
      if(currentCart.photo_ids && currentCart.photo_ids.length > 0) {
        cartItems.innerHTML = '';
        currentCart.photo_ids.forEach(photoId => {
          const div = document.createElement('div');
          div.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.1);';
          div.innerHTML = `
            <div style="display: flex; align-items: center; gap: 12px;">
              <img src="/photo/${encodeURIComponent(photoId)}?paid=false" style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px;" />
              <span style="font-size: 14px; color: var(--text-light);">${photoId}</span>
  </div>
            <button onclick="removeFromCart('${photoId}')" style="background: #ff4444; color: #fff; border: none; border-radius: 6px; padding: 6px 12px; cursor: pointer; font-size: 14px;">Rimuovi</button>
          `;
          cartItems.appendChild(div);
        });
        cartTotal.textContent = `‚Ç¨${currentCart.price_euros.toFixed(2)}`;
        checkoutBtn.disabled = false;
      } else {
        cartItems.innerHTML = '<p style="text-align: center; color: var(--text-muted);">Il carrello √® vuoto</p>';
        cartTotal.textContent = "‚Ç¨0.00";
        checkoutBtn.disabled = true;
      }
    }
    
    function removeFromCart(photoId) {
      // Rimuovi localmente (istantaneo)
      const updated = removeFromCartLocal(photoId);
      syncCart();
      updateNudgeBar(); // Aggiorna nudge bar quando si rimuove foto
      
      // Aggiorna UI immediatamente
          const btn = document.querySelector(`.add-to-cart-btn[data-photo-id="${photoId}"]`);
          if(btn && btn.classList.contains('is-added')) {
            btn.classList.remove('is-added');
            btn.setAttribute('aria-label', 'Aggiungi al carrello');
      }
    }

    // Funzione unica per calcolare prezzo in centesimi
    function computePrice(count) {
      if(count <= 0) return 0;
      if(count === 1) return 1800; // ‚Ç¨18.00
      if(count === 2) return 3600; // ‚Ç¨36.00
      if(count === 3) return 3900; // ‚Ç¨39.00
      if(count === 4) return 4200; // ‚Ç¨42.00
      if(count === 5) return 4500; // ‚Ç¨45.00
      if(count === 6) return 4700; // ‚Ç¨47.00
      if(count === 7) return 4800; // ‚Ç¨48.00
      if(count === 8) return 4900; // ‚Ç¨49.00
      if(count === 9) return 5000; // ‚Ç¨50.00
      if(count === 10) return 5100; // ‚Ç¨51.00
      if(count === 11) return 5200; // ‚Ç¨52.00
      if(count === 12) return 5300; // ‚Ç¨53.00
      if(count >= 13) return 5300 + 300 * (count - 12); // ‚Ç¨53 + ‚Ç¨3*(count-12)
      return 0;
    }
    
    // Mantieni calculatePrice per compatibilit√† (usa computePrice)
    function calculatePrice(count) {
      return computePrice(count);
    }
    
    // Logica nudge: trova il prossimo target conveniente
    function getNextOffer(k, N) {
      if(N <= 0) return null;
      
      const targets = [3, 6, 9, 12];
      
      // Se k >= 12 e N > k, target = N (completa album)
      if(k >= 12 && N > k) {
        return {
          target: N,
          add: N - k,
          delta: computePrice(N) - computePrice(k)
        };
      }
      
      // Trova il primo target > k e <= N
      for(const target of targets) {
        if(target > k && target <= N) {
          return {
            target: target,
            add: target - k,
            delta: computePrice(target) - computePrice(k)
          };
        }
      }
      
      // Nessun target disponibile
      return null;
    }
    
    // Aggiorna sticky bar con offerta "Prendile tutte"
    function updateStickyAllOffer() {
      if(!allPhotos || allPhotos.length <= 0) {
        const stickyBar = document.getElementById('stickyOfferBar');
        if(stickyBar) {
          stickyBar.classList.remove('active');
          stickyBar.style.display = 'none';
        }
        return;
      }
      
      const N = allPhotos.length;
      const priceCents = computePrice(N);
      const priceEuros = (priceCents / 100).toFixed(2);
      
      const stickyText = document.getElementById('stickyOfferText');
      const stickyPrice = document.getElementById('stickyOfferPrice');
      
      if(stickyText) {
        stickyText.textContent = 'Prendile tutte';
      }
      if(stickyPrice) {
        stickyPrice.textContent = `‚Ç¨${priceEuros}`;
      }
    }
    
    // Aggiorna nudge bar con suggerimento upgrade
    function updateNudgeBar() {
      const nudgeBar = document.getElementById('nudgeBar');
      const nudgeText = document.getElementById('nudgeText');
      const nudgeCheckoutBtn = document.getElementById('nudgeCheckoutBtn');
      
      if(!nudgeBar || !nudgeText || !nudgeCheckoutBtn) return;
      
      // Nascondi se non siamo nell'album o non ci sono foto
      if(currentScreen !== 'album' || !allPhotos || allPhotos.length <= 0) {
        nudgeBar.classList.remove('active');
        nudgeBar.style.display = 'none';
        return;
      }
      
      const k = cartPhotoIds.length;
      const N = allPhotos.length;
      
      // Caso A: k == 0
      if(k === 0) {
        const priceEuros = (computePrice(N) / 100).toFixed(2);
        nudgeText.innerHTML = `Seleziona le foto che vuoi. Offerta migliore: tutte a ‚Ç¨${priceEuros}`;
        nudgeCheckoutBtn.textContent = 'Vedi foto';
        nudgeCheckoutBtn.onclick = () => {
          // Scrolla alla griglia (non apre carrello se vuoto)
          const albumGrid = document.getElementById('albumGrid');
          if(albumGrid) {
            albumGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        };
        nudgeBar.classList.add('active');
        nudgeBar.style.display = 'flex';
        return;
      }
      
      // Caso B: 1 <= k < N e esiste target
      const offer = getNextOffer(k, N);
      if(offer && k < N) {
        const deltaEuros = (offer.delta / 100).toFixed(2);
        nudgeText.innerHTML = `Aggiungi ${offer.add} foto e arrivi a ${offer.target} foto per solo +‚Ç¨${deltaEuros}<small>oppure continua a selezionare</small>`;
        nudgeCheckoutBtn.textContent = 'Vai al checkout';
        nudgeCheckoutBtn.onclick = () => {
          // Apri carrello esistente
          const cartModal = document.getElementById('cartModal');
          if(cartModal) {
            cartModal.classList.add('active');
            updateCartModal();
          }
        };
        nudgeBar.classList.add('active');
        nudgeBar.style.display = 'flex';
        return;
      }
      
      // Caso C: k == N o k > 0 ma nessun target
      if(k === N || (k > 0 && !offer)) {
        const priceEuros = (computePrice(k) / 100).toFixed(2);
        nudgeText.innerHTML = `Perfetto: hai selezionato tutto. Totale ‚Ç¨${priceEuros}`;
        nudgeCheckoutBtn.textContent = 'Vai al checkout';
        nudgeCheckoutBtn.onclick = () => {
          // Apri carrello esistente
          const cartModal = document.getElementById('cartModal');
          if(cartModal) {
            cartModal.classList.add('active');
            updateCartModal();
          }
        };
        nudgeBar.classList.add('active');
        nudgeBar.style.display = 'flex';
        return;
      }
      
      // Caso D: nascondi se nessuna condizione soddisfatta
      nudgeBar.classList.remove('active');
      nudgeBar.style.display = 'none';
    }
    
    // Checkout per tutte le foto (indipendente dal carrello)
    async function startCheckoutForAllPhotos() {
      if(!allPhotos || allPhotos.length === 0) {
        alert('Nessuna foto disponibile!');
        return;
      }
      
      const allPhotoIds = allPhotos.map(p => p.photo_id || p.r2_key).filter(Boolean);
      if(allPhotoIds.length === 0) {
        alert('Nessuna foto valida disponibile!');
        return;
      }
      
      // Filtra foto gi√† pagate
      const paidPhotoIdsSet = new Set(paidPhotos);
      const unpaidPhotoIds = allPhotoIds.filter(photoId => !paidPhotoIdsSet.has(photoId));
      
      if(unpaidPhotoIds.length === 0) {
        alert('Tutte le foto sono gi√† state acquistate!');
        return;
      }
      
      const totalCount = unpaidPhotoIds.length;
      const totalPriceCents = computePrice(totalCount);
      
      try {
        const res = await fetch(`/create_checkout`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            photo_ids: unpaidPhotoIds,
            price_cents: totalPriceCents,
            currency: 'eur'
          })
        });
        
        if(!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        
        const data = await res.json();
        if(data.checkout_url) {
          window.location.href = data.checkout_url;
        } else {
          throw new Error('No checkout_url in response');
        }
      } catch(e) {
        console.error('Checkout error:', e);
        alert('Errore durante il checkout. Riprova.');
      }
    }

    async function checkout() {
      // Usa carrello in memoria (non persistente)
      const photoIds = cartPhotoIds;
      
      if(!photoIds || photoIds.length === 0) {
        alert('Cart is empty');
        return;
      }
      
      // FILTRA FOTO PAGATE: rimuovi foto gi√† pagate dal carrello prima del checkout
      let unpaidPhotoIds = photoIds;
      if(paidPhotos.length > 0) {
        const paidPhotoIdsSet = new Set(paidPhotos);
        unpaidPhotoIds = photoIds.filter(photoId => !paidPhotoIdsSet.has(photoId));
        
        if(unpaidPhotoIds.length !== photoIds.length) {
          console.log(`Rimosse ${photoIds.length - unpaidPhotoIds.length} foto pagate dal carrello prima del checkout`);
          
          // Aggiorna carrello in memoria rimuovendo foto pagate
          cartPhotoIds = unpaidPhotoIds;
          syncCart();
            
            // Se carrello vuoto dopo filtro, avvisa
          if(unpaidPhotoIds.length === 0) {
              alert("All selected photos have already been purchased. You can download them from the 'My Photos' page.");
        return;
          }
        }
      }
      
      const checkoutBtn = document.getElementById("checkoutBtn");
      if(checkoutBtn) {
        checkoutBtn.disabled = true;
        checkoutBtn.textContent = "‚è≥ Caricamento...";
      }
      
      try {
        console.log("Inizio checkout (stateless):", { photoCount: unpaidPhotoIds.length });
        
        // Stateless: usa /create_checkout con photo_ids dal localStorage
        const priceCents = calculatePrice(unpaidPhotoIds.length);
        
        let res = await fetch(`/create_checkout`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            photo_ids: unpaidPhotoIds,
            price_cents: priceCents,
            currency: "eur"
          })
        });
        
        console.log("Checkout response status:", res.status);
        
        // Se Stripe non √® configurato (503), mostra errore
        if(res.status === 503) {
          throw new Error("Stripe not configured. Please contact support.");
        }
        
        if(!res.ok) {
          const errorText = await res.text();
          console.error("Checkout error response:", errorText);
          let errorData;
          try {
            errorData = JSON.parse(errorText);
          } catch(e) {
            errorData = { detail: errorText || `Errore ${res.status}` };
          }
          throw new Error(errorData.detail || `Errore ${res.status}: ${res.statusText}`);
        }
        
        const data = await res.json();
        console.log("Checkout data:", data);
        
        // Gestisci sia checkout_url che url (per test mode)
        const redirectUrl = data.checkout_url || data.url;
        if(redirectUrl) {
          console.log("Redirecting to checkout:", redirectUrl);
          window.location.href = redirectUrl;
        } else {
          throw new Error("URL di checkout non ricevuto dal server");
        }
      } catch(err) {
        console.error("Checkout error:", err);
        alert("Error during payment: " + err.message + "\n\nCheck the console for details.");
        if(checkoutBtn) {
          checkoutBtn.disabled = false;
          checkoutBtn.textContent = "üí≥ Vai al Pagamento";
        }
      }
    }
    
    async function checkoutAllPhotos() {
      // Checkout per TUTTE le foto: ignora il carrello e usa tutte le foto trovate
      if(!allPhotos || allPhotos.length === 0) {
        alert("No photos available!");
    return;
  }

      // Crea un carrello temporaneo con TUTTE le foto
      const allPhotoIds = allPhotos.map(photo => photo.photo_id);
      const totalCount = allPhotoIds.length;
      const totalPriceCents = calculatePrice(totalCount);
      const totalPriceEuros = (totalPriceCents / 100).toFixed(2);
      
      // Aggiungi tutte le foto al carrello temporaneamente per il checkout
      // Usiamo una sessione separata o aggiungiamo direttamente tutte le foto
      try {
        // Prima, aggiungi tutte le foto al carrello (sovrascrive il carrello corrente)
        // Oppure crea una nuova sessione per questo checkout
        const checkoutSessionId = "checkout_all_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
        
        // Stateless: usa /create_checkout con photo_ids nel body
        const res = await fetch(`/create_checkout`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            photo_ids: allPhotoIds,
            price_cents: totalPriceCents,
            currency: "eur"
          })
        });
        
        const data = await res.json();
        if(data.checkout_url) {
          window.location.href = data.checkout_url;
        } else {
          alert("Error during checkout. Please try again.");
        }
      } catch(err) {
        console.error("Errore checkout tutte le foto:", err);
        alert("Error during checkout. Please try again.");
      }
    }

    // Lightbox controls (solo se elementi esistono)
    const lightboxClose = document.getElementById('lightboxClose');
    const lightboxPrev = document.getElementById('lightboxPrev');
    const lightboxNext = document.getElementById('lightboxNext');
    
    if(lightboxClose && photoLightbox) {
      lightboxClose.addEventListener('click', () => {
        photoLightbox.classList.remove('active');
      });
    }
    
    if(lightboxPrev) {
      lightboxPrev.addEventListener('click', prevPhoto);
    }
    
    if(lightboxNext) {
      lightboxNext.addEventListener('click', nextPhoto);
    }
    
    // Navigazione con tastiera
    document.addEventListener('keydown', (e) => {
      if(photoLightbox && photoLightbox.classList.contains('active')) {
        if(e.key === 'ArrowLeft') prevPhoto();
        if(e.key === 'ArrowRight') nextPhoto();
        if(e.key === 'Escape') photoLightbox.classList.remove('active');
      }
    });

    if(photoLightbox) {
      photoLightbox.addEventListener('click', (e) => {
        // Chiudi solo se si clicca sullo sfondo (photoLightbox stesso o il div container interno)
        // NON chiudere se si clicca sull'immagine, sui pulsanti o sulle istruzioni
        const containerDiv = photoLightbox.querySelector('div');
        if(e.target === photoLightbox || (e.target === containerDiv && e.target.tagName === 'DIV')) {
          photoLightbox.classList.remove('active');
        }
      });
    }
    
    // Blocca salvataggio foto NON pagate (solo se lightboxImage esiste)
    if(lightboxImage) {
      lightboxImage.addEventListener('contextmenu', (e) => {
        // Verifica se la foto √® pagata controllando se il lightbox mostra CTA carrello
        const cartCTA = document.getElementById('lightboxCartCTA');
        if(cartCTA && cartCTA.style.display !== 'none') {
          // Foto NON pagata: blocca
          e.preventDefault();
          return false;
        }
        // Foto pagata: permetti (non fare preventDefault)
      });
      
      lightboxImage.addEventListener('dragstart', (e) => {
        // Blocca drag solo per foto non pagate
        const cartCTA = document.getElementById('lightboxCartCTA');
        if(cartCTA && cartCTA.style.display !== 'none') {
          e.preventDefault();
          return false;
        }
      });
    }
    

    // Blocca long-press e salvataggio pre-acquisto (SOLO in index.html, NON in /my-photos)
    // Verifica che non siamo nella pagina post-acquisto
    if(!window.location.pathname.includes('/my-photos')) {
      // Blocca menu contestuale (long-press su immagini) SOLO per foto NON pagate
      document.addEventListener('contextmenu', (e) => {
        if (e.target && e.target.tagName === 'IMG') {
          // Se √® l'immagine nel lightbox, verifica se √® pagata
          if(e.target.id === 'lightboxImage') {
            const cartCTA = document.getElementById('lightboxCartCTA');
            // Se CTA carrello √® visibile, la foto NON √® pagata -> blocca
            if(cartCTA && cartCTA.style.display !== 'none') {
              e.preventDefault();
              return false;
            }
            // Se CTA carrello √® nascosta, la foto √® pagata -> PERMETTI (non bloccare)
            return;
          }
          // Per immagini nella griglia (non pagate), blocca sempre
          if(e.target.closest('.album-photo')) {
            e.preventDefault();
            return false;
          }
        }
      }, { passive: false });
      
      // Blocca drag (long-press drag su immagini) SOLO per foto NON pagate
      document.addEventListener('dragstart', (e) => {
        if (e.target && e.target.tagName === 'IMG') {
          if(e.target.id === 'lightboxImage') {
            const cartCTA = document.getElementById('lightboxCartCTA');
            if(cartCTA && cartCTA.style.display !== 'none') {
              e.preventDefault();
              return false;
            }
            return;
          }
          if(e.target.closest('.album-photo')) {
            e.preventDefault();
            return false;
          }
        }
      }, { passive: false });
      
      // Blocca anche select (doppio tap su iOS) SOLO per foto NON pagate
      document.addEventListener('selectstart', (e) => {
        if (e.target && e.target.tagName === 'IMG') {
          if(e.target.id === 'lightboxImage') {
            const cartCTA = document.getElementById('lightboxCartCTA');
            if(cartCTA && cartCTA.style.display !== 'none') {
              e.preventDefault();
              return false;
            }
            return;
          }
          if(e.target.closest('.album-photo')) {
            e.preventDefault();
            return false;
          }
        }
      }, { passive: false });
    }

    // Boot
    window.addEventListener('load', () => {
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("This browser does not support the camera.");
      }
    });
  </script>
</body>
</html>

