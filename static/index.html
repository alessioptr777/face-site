<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Tenerife Stars Pictures - Find your photos</title>
  <style>
    :root{
      --bg-dark: #0a0e27;
      --bg-dark2: #1a1f3a;
      --bg-gradient: linear-gradient(180deg, #1a1f3a 0%, #0a0e27 100%);
      --text-light: #ffffff;
      --text-muted: #a0a8c0;
      --accent: #6366f1;
      --accent-light: #818cf8;
      --purple: #a855f7;
      --pink: #ec4899;
      --radius: 16px;
      --shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    *{box-sizing:border-box; margin:0; padding:0}
    html, body{
      margin:0;
      padding:0;
      height: 100%;
      overflow: hidden;
    }
    body{
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;
      color:var(--text-light);
      height: 100dvh;
      height: 100vh; /* Fallback per browser che non supportano dvh */
      background: var(--bg-gradient);
      overflow: hidden;
      position: fixed;
      width: 100%;
    }
    
    /* Utility */
    .screen{
      height: 100dvh;
      height: 100vh; /* Fallback */
      display: none;
      flex-direction: column;
      overflow-y: auto; /* Permette scroll su mobile */
      overflow-x: hidden;
      position: relative;
    }
    .screen.active{
      display: flex;
    }
    
    /* Android Mobile Optimization - schermi piccoli */
    @media (max-height: 800px) {
      .screen {
        min-height: calc(100dvh - env(safe-area-inset-bottom, 0px));
        padding-bottom: env(safe-area-inset-bottom, 0px);
      }
    }
    
    /* Language Selection Screen */
    .language-screen{
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }
    
    @media (max-height: 800px) {
      .language-screen {
        padding: 20px 15px;
        justify-content: flex-start;
        padding-top: 30px;
      }
    }
    
    .language-title{
      font-size: 28px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 10px;
    }
    
    .language-subtitle{
      font-size: 16px;
      color: var(--text-muted);
      margin-bottom: 40px;
    }
    
    @media (max-height: 800px) {
      .language-title {
        font-size: 22px;
        margin-bottom: 8px;
      }
      .language-subtitle {
        font-size: 14px;
        margin-bottom: 20px;
      }
    }
    
    .language-grid{
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      max-width: 400px;
      width: 100%;
      margin: 0 auto;
    }
    
    .language-option{
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    
    @media (max-height: 800px) {
      .language-grid {
        gap: 12px;
        max-width: 100%;
      }
      .language-option {
        padding: 15px 12px;
        gap: 8px;
      }
      .language-flag {
        font-size: 36px;
      }
      .language-name {
        font-size: 14px;
      }
    }
    
    .language-option:hover{
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--accent);
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(99, 102, 241, 0.3);
    }
    
    .language-flag{
      font-size: 48px;
      line-height: 1;
    }
    
    .language-name{
      font-size: 18px;
      font-weight: 600;
      color: var(--text-light);
    }
    
    /* Email Screen */
    .email-screen{
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }
    
    .email-title{
      font-size: 28px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 10px;
    }
    
    .email-subtitle{
      font-size: 16px;
      color: var(--text-muted);
      margin-bottom: 30px;
    }
    
    @media (max-height: 800px) {
      .email-screen {
        padding: 20px 15px 80px 15px;
        justify-content: flex-start;
        padding-top: 30px;
      }
      .email-title {
        font-size: 22px;
        margin-bottom: 8px;
      }
      .email-subtitle {
        font-size: 14px;
        margin-bottom: 20px;
      }
      .email-input-container {
        margin-bottom: 20px;
      }
    }
    
    .email-input-container{
      max-width: 400px;
      width: 100%;
      margin: 0 auto 30px;
    }
    
    .email-input{
      width: 100%;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      color: var(--text-light);
      font-size: 16px;
      transition: all 0.3s ease;
    }
    
    .email-input:focus{
      outline: none;
      border-color: var(--accent);
      background: rgba(255, 255, 255, 0.08);
    }
    
    .email-input::placeholder{
      color: var(--text-muted);
    }
    
    .email-error{
      color: #ff4444;
      font-size: 14px;
      margin-top: 10px;
      display: none;
    }
    
    .email-error.show{
      display: block;
    }
    
    .email-loading{
      margin-top: 20px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    
    .email-loading p{
      color: var(--text-muted);
      font-size: 14px;
      margin: 0;
    }
    
    .loading-spinner{
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin{
      to { transform: rotate(360deg); }
    }
    
    /* Welcome Screen */
    .welcome-screen{
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }
    
    .welcome-icon{
      width: 120px;
      height: 120px;
      margin-bottom: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .welcome-icon svg{
      width: 100%;
      height: 100%;
      stroke: var(--accent-light);
      fill: none;
      stroke-width: 2;
    }
    
    .welcome-title{
      font-size: 32px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 20px;
    }
    
    .welcome-text{
      font-size: 16px;
      color: var(--text-muted);
      line-height: 1.6;
      max-width: 400px;
      margin: 0 auto 40px;
    }
    
    .welcome-privacy{
      font-size: 14px;
      color: var(--text-muted);
      max-width: 400px;
      margin: 20px auto 0;
    }
    
    .btn-primary{
      background: linear-gradient(135deg, var(--accent) 0%, var(--purple) 100%);
      color: white;
      border: none;
      padding: 16px 48px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .btn-primary:active{
      transform: scale(0.98);
    }
    
    /* Selfie Screen */
    .selfie-screen{
      padding: 10px;
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    @media (max-height: 800px) {
      .selfie-screen {
        padding: 8px 8px 80px 8px;
      }
      .selfie-header h2 {
        font-size: 18px;
      }
      .selfie-controls {
        margin-top: 10px;
        margin-bottom: 15px;
      }
      .camera-btn {
        width: 70px;
        height: 70px;
      }
    }
    
    .selfie-header{
      flex-shrink: 0;
      padding: 10px 0;
      text-align: center;
    }
    
    .selfie-header h2{
      font-size: 20px;
      font-weight: 600;
      color: var(--text-light);
      margin: 0;
    }
    
    .selfie-preview{
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      min-height: 0; /* Importante per flex */
      overflow: hidden;
    }
    
    .selfie-video{
      width: 100%;
      max-width: 100%;
      aspect-ratio: 3 / 4; /* Aspect ratio fisso 3:4 verticale */
      border-radius: 16px;
      overflow: hidden;
      background: #000;
      flex-shrink: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .selfie-video video{
      width: 100%;
      height: 100%;
      object-fit: cover; /* Copre tutto il contenitore senza bande nere */
      display: block;
      object-position: center center; /* Centra verticalmente sul volto */
    }
    
    .selfie-controls{
      flex-shrink: 0;
      margin-top: 15px;
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    
    /* Upload Status Area - sempre visibile */
    .upload-status{
      flex-shrink: 0;
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.3);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: none;
      flex-direction: column;
      gap: 8px;
    }
    
    .upload-status.active{
      display: flex;
    }
    
    .upload-status-text{
      font-size: 14px;
      color: var(--text-light);
      text-align: center;
      font-weight: 500;
    }
    
    .upload-progress-container{
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }
    
    .upload-progress-bar{
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--purple));
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 3px;
    }
    
    .upload-percentage{
      font-size: 12px;
      color: var(--text-muted);
      text-align: center;
    }
    
    /* Selfie Error Box */
    .selfie-error-box{
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }
    
    .selfie-error-content{
      background: var(--bg-dark);
      border-radius: 16px;
      padding: 32px 24px;
      max-width: 400px;
      width: 100%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .selfie-error-message{
      font-size: 16px;
      color: var(--text-light);
      margin: 0 0 24px 0;
      line-height: 1.5;
    }
    
    .btn-retake-selfie{
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 14px 28px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      transition: all 0.2s ease;
    }
    
    .btn-retake-selfie:hover{
      background: var(--accent-hover);
      transform: translateY(-1px);
    }
    
    .btn-retake-selfie:active{
      transform: translateY(0);
    }
    
    .upload-spinner{
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }
    
    .camera-btn{
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: white;
      border: 4px solid var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    .camera-btn svg{
      width: 40px;
      height: 40px;
      stroke: var(--accent);
      stroke-width: 2;
    }
    
    /* Confirm Selfie Screen */
    .confirm-screen{
      padding: 10px 20px;
      align-items: center;
      justify-content: center;
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    .confirm-title{
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 30px;
      text-align: center;
    }
    
    .confirm-preview{
      width: 100%;
      max-width: 300px;
      aspect-ratio: 3 / 4; /* Stesso aspect ratio del selfie catturato */
      border-radius: 20px;
      overflow: hidden;
      margin-bottom: 15px;
      box-shadow: var(--shadow);
      flex-shrink: 1;
      background: #000;
    }
    
    .confirm-preview img{
      width: 100%;
      height: 100%;
      object-fit: cover; /* Stesso comportamento del video */
      object-position: center center;
      display: block;
    }
    
    .confirm-privacy{
      max-width: 400px;
      text-align: center;
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 30px;
      line-height: 1.6;
    }
    
    .confirm-privacy a{
      color: var(--accent-light);
      text-decoration: underline;
    }
    
    .confirm-buttons{
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      max-width: 400px;
      margin-bottom: 20px; /* Spazio per navigation bar Android */
    }
    
    .btn-confirm{
      background: var(--accent);
      color: white;
      border: none;
      padding: 16px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }
    
    .btn-retake{
      background: transparent;
      color: var(--text-light);
      border: 2px solid var(--text-muted);
      padding: 16px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }
    
    /* Android Mobile: riduci dimensioni per far entrare tutto */
    @media (max-height: 800px) {
      .confirm-screen {
        padding: 15px 15px 80px 15px; /* Extra padding bottom per navigation bar */
        justify-content: flex-start;
        padding-top: 20px;
      }
      .confirm-title {
        font-size: 20px;
        margin-bottom: 15px;
      }
      .confirm-preview {
        max-width: 250px;
        margin-bottom: 12px;
      }
      .confirm-privacy {
        font-size: 12px;
        margin-bottom: 15px;
        padding: 0 10px;
      }
      .confirm-buttons {
        gap: 10px;
        margin-bottom: 30px;
      }
      .btn-confirm,
      .btn-retake {
        padding: 12px;
        font-size: 14px;
      }
    }
    
    /* Add People Screen */
    .add-people-screen{
      padding: 40px 20px;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    
    .add-people-title{
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 30px;
    }
    
    @media (max-height: 800px) {
      .add-people-screen {
        padding: 20px 15px 80px 15px;
        justify-content: flex-start;
        padding-top: 30px;
      }
      .add-people-title {
        font-size: 20px;
        margin-bottom: 20px;
      }
      .people-list {
        margin-bottom: 25px;
      }
      .person-avatar,
      .add-person-btn {
        width: 70px;
        height: 70px;
      }
    }
    
    .people-list{
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 40px;
      flex-wrap: wrap;
    }
    
    .person-avatar{
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--bg-dark2);
      border: 3px solid var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .person-avatar img{
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .add-person-btn{
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 32px;
      color: white;
    }
    
    .add-people-buttons{
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      max-width: 400px;
    }
    
    /* Album Screen */
    .album-screen{
      padding: 0;
      overflow-y: auto; /* Permetti scroll verticale */
      -webkit-overflow-scrolling: touch; /* Smooth scroll su iOS */
    }
    
    .album-header{
      position: sticky;
      top: 0;
      background: var(--bg-dark2);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      z-index: 999; /* Sotto il banner sticky ma sopra il contenuto */
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      overflow: visible; /* Evita clipping degli elementi figli */
    }
    
    .album-header-title{
      font-size: 13px;
      font-weight: 600;
      color: var(--text-light);
      flex: 1;
      text-align: center;
      display: block; /* Visibile su tutti i device */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .album-back{
      background: none;
      border: none;
      color: var(--text-light);
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      flex-shrink: 0;
    }
    
    .album-cart{
      background: var(--accent);
      color: white;
      border: none;
      padding: 8px 14px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      flex-shrink: 0;
    }
    
    /* Mini Banner Deal (sotto header) */
    .album-top-mini-bar{
      position: sticky;
      top: 44px; /* Altezza header mobile */
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(255,215,120,0.2);
      padding: 6px 12px;
      z-index: 998;
      display: none; /* Mostrato solo su mobile */
      overflow: visible; /* Evita clipping degli elementi figli */
    }
    
    .album-top-mini-bar .deal-pill{
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 3px;
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(0,0,0,0.3);
      border: 1.5px solid rgba(255,215,120,0.4);
      box-shadow:
        0 0 0 1px rgba(255,215,120,0.15) inset,
        0 4px 12px rgba(0,0,0,.3),
        0 0 8px rgba(255,215,120,0.1);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      width: 100%;
      max-width: 100%;
    }
    
    .album-top-mini-bar .deal-pill-top{
      font-size: 13px;
      font-weight: 800;
      line-height: 1.2;
      color: rgba(255,255,255,.95);
    }
    
    .album-top-mini-bar .deal-pill-bottom{
      font-size: 12px;
      font-weight: 700;
      line-height: 1.2;
      color: rgba(255,215,120,.95);
    }
    
    /* Member Chips Row - Cross-device (mobile + desktop) */
    .member-chip{
      position: relative;
    }
    
    .member-remove{
      position: absolute;
      top: -6px;
      right: -6px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid rgba(0,0,0,0.35);
      background: rgba(0,0,0,0.65);
      color: #fff;
      font-size: 14px;
      font-weight: 900;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      pointer-events: auto;
      -webkit-tap-highlight-color: transparent;
      z-index: 10;
    }
    .member-remove:active{
      transform: scale(0.96);
    }
    
    .member-chips-row,
    .members-bar{
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      gap: 12px;
      padding: 10px 16px 12px;
      min-height: 64px; /* Evita taglio degli avatar */
      overflow-x: auto;
      overflow-y: visible; /* IMPORTANT: niente clipping verticale */
      -webkit-overflow-scrolling: touch;
      background: rgba(0,0,0,0.1);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .member-chips-row::-webkit-scrollbar,
    .members-bar::-webkit-scrollbar{
      display: none;
    }
    
    .member-chip,
    .members-bar .member-avatar,
    .members-bar .member-add{
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.06);
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
      overflow: hidden;
      position: relative;
    }
    
    .member-chip img,
    .members-bar .member-avatar img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center; /* Centra l'immagine per evitare tagli */
      border-radius: 50%;
      display: block;
    }
    
    .member-chip.plus,
    .members-bar .member-add{
      font-size: 26px;
      font-weight: 800;
      color: white;
      background: rgba(99,102,241,0.25);
      border-color: rgba(99,102,241,0.65);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .member-chip.plus:active,
    .members-bar .member-add:active{
      transform: scale(0.95);
      background: rgba(99,102,241,0.5);
    }
    
    .deal-pill{
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 2px;
      padding: 8px 10px;
      border-radius: 14px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,215,120,.35);
      box-shadow:
        0 0 0 1px rgba(255,215,120,.14) inset,
        0 8px 18px rgba(0,0,0,.22),
        0 0 14px rgba(255,215,120,.14);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .deal-pill-top{
      font-size: 11px;
      font-weight: 800;
      line-height: 1.1;
      color: rgba(255,255,255,.95);
    }
    
    .deal-pill-bottom{
      font-size: 11px;
      font-weight: 800;
      line-height: 1.1;
      color: rgba(255,215,120,.95);
    }
    
    .album-profile{
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      overflow: visible; /* Evita clipping degli elementi figli */
    }
    
    /* Mobile-first: modifiche per schermi piccoli */
    @media (max-width: 480px){
      .album-header{
        padding: 8px 12px;
        min-height: 44px;
        max-height: 44px;
      }
      
      .album-header-title{
        display: block;
        font-size: 13px;
        font-weight: 600;
      }
      
      .album-back{
        font-size: 20px;
        padding: 4px 8px;
        min-width: 32px;
      }
      
      .album-cart{
        padding: 6px 10px;
        font-size: 11px;
        gap: 4px;
        border-radius: 16px;
        font-weight: 700;
      }
      
      .album-top-mini-bar{
        display: block;
        top: 44px; /* Altezza header mobile */
        padding: 6px 12px;
        border-bottom: 1px solid rgba(255,215,120,0.25);
        overflow: visible; /* Evita clipping degli elementi figli */
      }
      
      .album-top-mini-bar .deal-pill{
        padding: 8px 12px;
        gap: 2px;
      }
      
      .album-top-mini-bar .deal-pill-top{
        font-size: 12px;
        line-height: 1.3;
      }
      
      .album-top-mini-bar .deal-pill-bottom{
        font-size: 11px;
        line-height: 1.3;
      }
      
      /* Mobile: mantieni stili base per members bar, nessuna modifica necessaria */
      
      /* Nascondi deal pill desktop su mobile */
      #dealPillDesktop {
        display: none;
      }
      
      .album-profile{
        display: none; /* Nascondi su mobile */
      }
      
      .album-tabs{
        padding: 6px 12px 0;
        margin-top: 0;
        min-height: 40px;
      }
      
      .album-tab{
        padding: 8px 12px;
        font-size: 13px;
      }
      
      .album-grid{
        padding: 8px 12px;
        padding-top: 12px;
        padding-bottom: calc(250px + env(safe-area-inset-bottom, 0px));
      }
    }
    
    /* Desktop: mantieni layout originale */
    @media (min-width: 481px){
      .album-header{
        padding: 16px 20px;
      }
      
      /* Desktop: titolo sempre visibile (come mobile) */
      .album-header-title{
        display: block;
      }
      
      .album-top-mini-bar{
        display: none;
      }
      
      /* Desktop: micro-adattamenti per members bar */
      .member-chips-row,
      .members-bar{
        padding: 12px 20px 14px;
        min-height: 72px;
      }
      
      .member-chip,
      .members-bar .member-avatar,
      .members-bar .member-add{
        width: 52px;
        height: 52px;
      }
      
      .member-chip.plus,
      .members-bar .member-add{
        font-size: 28px;
      }
      
      .album-profile{
        display: none; /* Nascosto su desktop - solo Metaproos S.L nell'header */
      }
      
      /* Desktop: deal pill nell'header */
      .album-header .deal-pill{
        display: flex;
        max-width: 360px;
      }
      .album-header .deal-pill-top,
      .album-header .deal-pill-bottom{
        white-space: normal;
      }
    }
    
    .profile-avatar{
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-dark2);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .profile-avatar img{
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .profile-info h3{
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 2px;
      line-height: 1.2;
    }
    
    .profile-info p{
      font-size: 11px;
      color: var(--text-muted);
      line-height: 1.3;
      margin: 0;
    }
    
    .album-tabs{
      display: flex;
      padding: 0 20px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .album-tab{
      background: none;
      border: none;
      color: var(--text-muted);
      padding: 16px 20px;
      font-size: 16px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: color 0.2s, border-color 0.2s;
    }
    
    .album-tab.active{
      color: var(--accent-light);
      border-bottom-color: var(--accent-light);
    }
    
    .album-tab:hover{
      color: var(--text-light);
    }
    
    /* Listino prezzi */
    .prices-list{
      display: none;
      padding: 15px 20px;
      padding-bottom: calc(80px + env(safe-area-inset-bottom)); /* Spazio per banner sticky */
      max-width: 600px;
      margin: 0 auto;
      max-height: calc(100vh - 200px); /* Altezza massima per evitare overflow */
      overflow-y: auto;
    }
    
    .prices-list.active{
      display: block;
    }
    
    .prices-title{
      font-size: 20px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 8px;
      text-align: center;
    }
    
    .prices-subtitle{
      font-size: 12px;
      color: var(--text-muted);
      text-align: center;
      margin-bottom: 12px;
    }
    
    .price-item{
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      margin-bottom: 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: background 0.2s, transform 0.2s;
    }
    
    .price-item:hover{
      background: rgba(255, 255, 255, 0.08);
      transform: translateX(4px);
    }
    
    .price-item.highlight{
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.2) 0%, rgba(236, 72, 153, 0.2) 100%);
      border-color: var(--purple);
    }
    
    /* Premium / Top deal */
    .price-item.topdeal{
      background: linear-gradient(135deg, rgba(10,10,14,0.95) 0%, rgba(24,18,40,0.92) 55%, rgba(10,10,14,0.95) 100%);
      border: 1.5px solid rgba(255, 215, 120, 0.6);
      box-shadow:
        0 0 0 1px rgba(255, 215, 120, 0.18) inset,
        0 10px 26px rgba(0,0,0,.35),
        0 0 18px rgba(255, 215, 120, 0.22);
    }
    
    .price-item.topdeal .price-item-count{
      color: rgba(255,255,255,0.98);
    }
    
    .price-item.topdeal .price-item-desc{
      color: rgba(255, 215, 120, 0.92);
      font-weight: 600;
    }
    
    .price-item.topdeal .price-item-value{
      color: rgba(255, 215, 120, 0.98);
    }
    
    .price-item.topdeal .price-item-badge{
      background: linear-gradient(135deg, rgba(255, 235, 170, 0.98), rgba(255, 215, 120, 0.98));
      color: rgba(30, 18, 45, 1);
      font-weight: 800;
    }
    
    .price-item-info{
      flex: 1;
    }
    
    .price-item-count{
      font-size: 15px;
      font-weight: 600;
      color: var(--text-light);
      margin-bottom: 2px;
    }
    
    .price-item-desc{
      font-size: 11px;
      color: var(--text-muted);
    }
    
    .price-item-value{
      font-size: 20px;
      font-weight: 700;
      color: var(--accent-light);
    }
    
    .price-item-badge{
      display: inline-block;
      background: var(--purple);
      color: white;
      font-size: 10px;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      margin-left: 8px;
      text-transform: uppercase;
    }
    
    .album-tab.active{
      color: var(--text-light);
      border-bottom-color: var(--accent);
    }
    
    .album-grid{
      padding: 20px;
      padding-bottom: calc(200px + env(safe-area-inset-bottom, 0px));
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 20px;
    }
    
    /* Mobile: extra padding per vedere tutte le foto fino alla fine */
    @media (max-width: 767px) {
      .album-grid {
        padding-bottom: calc(250px + env(safe-area-inset-bottom, 0px));
      }
    }
    
    .album-photo{
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      aspect-ratio: 1;
      background: var(--bg-dark2);
      
      /* Bordo glass per foto non selezionate */
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 6px 18px rgba(0,0,0,.28);
      background: rgba(255,255,255,.03);
      
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    
    .album-photo:active{
      transform: scale(0.98);
    }
    
    .album-photo img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      transition: opacity 0.3s ease;
      
      /* Filtro per migliorare visibilitÃ  foto notturne */
      filter: brightness(1.05) contrast(1.08) saturate(1.06);
    }
    
    /* Stato selezionato: ring oro + glow */
    .album-photo:has(.add-to-cart-btn.is-added),
    .album-photo.selected{
      border-color: rgba(255,215,120,.55);
      box-shadow:
        0 0 0 1px rgba(255,215,120,.18) inset,
        0 10px 26px rgba(0,0,0,.30),
        0 0 18px rgba(255,215,120,.20);
    }
    
    .album-photo img.loaded{
      opacity: 1;
    }
    
    .album-photo .photo-skeleton{
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(255,255,255,0.05) 0%, 
        rgba(255,255,255,0.1) 50%, 
        rgba(255,255,255,0.05) 100%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s ease-in-out infinite;
    }
    
    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    .album-loading-overlay{
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(4px);
    }
    
    .album-loading-overlay.active{
      display: flex;
    }
    
    .album-loading-content{
      text-align: center;
      color: white;
    }
    
    .album-loading-spinner{
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255,255,255,0.3);
      border-top-color: var(--purple);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    .album-photo {
      position: relative;
    }
    
    .add-to-cart-btn{
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 5;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 34px;
      height: 34px;
      min-width: 34px;
      min-height: 34px;
      border-radius: 50%;
      border: 5px solid rgb(76, 175, 80); /* Bordo verde spesso - stesso colore del badge "Pagata" */
      background: rgba(76, 175, 80, 0.5); /* Sfondo verde trasparente al 50% */
      font-weight: 800;
      font-size: 18px;
      line-height: 1;
      color: #fff; /* "+" bianco */
      box-shadow: 0 2px 8px rgba(0,0,0,.25);
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      transition: transform 160ms ease, background-color 160ms ease, border-color 160ms ease, box-shadow 160ms ease;
      user-select: none;
    }
    
    /* Desktop: dimensioni leggermente piÃ¹ grandi */
    @media (min-width: 768px) {
      .add-to-cart-btn{
        width: 36px;
        height: 36px;
        min-width: 36px;
        min-height: 36px;
      }
    }
    
    .add-to-cart-btn:active{
      transform: scale(0.95);
    }
    
    .add-to-cart-btn .btn-icon{
      display: inline-block;
      font-weight: 800;
      font-size: 18px;
    }
    
    .add-to-cart-btn .btn-check{
      display: none;
      color: #fff; /* "âœ“" bianca quando Ã¨ nel carrello */
      font-weight: 800;
      font-size: 20px;
    }
    
    /* Stato: FOTO NEL carrello - cerchio pieno verde con âœ“ bianca */
    .add-to-cart-btn.is-added{
      background: rgb(76, 175, 80); /* Cerchio pieno verde - stesso colore del badge "Pagata" */
      border-color: rgb(76, 175, 80);
      box-shadow: 0 2px 8px rgba(0,0,0,.3);
    }
    
    .add-to-cart-btn.is-added .btn-icon{
      display: none;
    }
    
    .add-to-cart-btn.is-added .btn-check{
      display: inline-block;
    }
    
    /* Animazione "pop" quando cambia stato */
    @keyframes cartPop {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.12);
      }
      100% {
        transform: scale(1);
      }
    }
    
    .add-to-cart-btn.pop{
      animation: cartPop 160ms ease;
    }
    
    .album-buy-all{
      margin: 20px;
      background: linear-gradient(135deg, var(--purple) 0%, var(--pink) 100%);
      color: white;
      border: none;
      padding: 20px;
      border-radius: 16px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 4px 20px rgba(168, 85, 247, 0.4);
    }
    
    .album-buy-all .price{
      font-size: 24px;
    }
    
    .album-buy-all .subtitle{
      font-size: 14px;
      opacity: 0.9;
      margin-top: 4px;
    }
    
    /* Modal styles */
    .ios-share-modal{
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .ios-share-modal.active{
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    
    .ios-share-modal-content{
      background: var(--bg-dark2);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Sticky Offer Bar */
    /* Sticky Offer Bar (pill button) */
    .sticky-offer-bar{
      position: fixed;
      left: 12px;
      right: 12px;
      max-width: 650px;
      margin: 0 auto;
      bottom: calc(12px + env(safe-area-inset-bottom));

      background: linear-gradient(135deg, var(--purple) 0%, var(--pink) 100%);
      border-radius: 18px;
      padding: 12px 16px;

      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.12);

      z-index: 1000;
      display: none;
      transform: translateY(140%);
      transition: transform 0.28s ease-out;

      will-change: transform;
      -webkit-transform: translateZ(0);
      transform: translateZ(0) translateY(140%);

      min-height: 62px;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      pointer-events: auto;
      touch-action: manipulation;
    }

.sticky-offer-bar *{ pointer-events: none; }
    .sticky-offer-bar.active{
      transform: translateZ(0) translateY(0);
    }
    
    /* Mostra solo quando lo schermo album Ã¨ attivo */
    .album-screen.active ~ .sticky-offer-bar.active,
    body:has(.album-screen.active) .sticky-offer-bar.active{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
    }
    
    .sticky-offer-close{
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      flex-shrink: 0;
      transition: background 0.2s;
    }
    
    .sticky-offer-close:active{
      background: rgba(255, 255, 255, 0.3);
    }
    
    /* Nudge Bar: suggerisce upgrade al prossimo scaglione - Premium style */
    .nudge-bar{
      position: fixed;
      left: 12px;
      right: 12px;
      max-width: 650px;
      margin: 0 auto;
      bottom: calc(72px + env(safe-area-inset-bottom));
      z-index: 1100;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 16px;
      
      /* diverso dallo sticky - piÃ¹ scuro e meno saturo */
      background: linear-gradient(135deg, rgba(25,18,55,.92), rgba(60,20,70,.92));
      
      /* bordo oro premium */
      border: 1px solid rgba(255, 215, 120, .45);
      
      /* glow oro + glow viola */
      box-shadow:
        0 0 0 1px rgba(255, 215, 120, .18) inset,
        0 10px 26px rgba(0,0,0,.28),
        0 0 18px rgba(255, 215, 120, .22),
        0 0 26px rgba(168,85,247,.18);
      
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .nudge-bar.active{ display:flex !important; }
    
    /* Effetto "risplende" con pseudo-elemento */
    .nudge-bar::before{
      content:"";
      position:absolute;
      inset:-10px;
      border-radius: 22px;
      background: radial-gradient(circle at 30% 30%, rgba(255,215,120,.22), transparent 55%),
                  radial-gradient(circle at 70% 70%, rgba(168,85,247,.18), transparent 60%);
      filter: blur(10px);
      z-index:-1;
      pointer-events:none;
    }

    .nudge-text{ flex: 1; min-width: 0; }
    #nudgeLine1{ font-size: 14px; font-weight: 900; color:#fff; line-height: 1.2; }
    #nudgeLine2{ margin-top: 2px; font-size: 12px; font-weight: 700; color: rgba(255,255,255,.92); line-height: 1.2; }

    .nudge-cta{
      border:none;
      cursor:pointer;
      border-radius: 12px;
      padding: 10px 14px;
      
      /* CTA piÃ¹ premium: oro chiaro invece del bianco */
      background: linear-gradient(135deg, rgba(255, 235, 170, .98), rgba(255, 215, 120, .98));
      color: rgba(45, 20, 70, 1);
      
      font-weight: 900;
      font-size: 13px;
      white-space: nowrap;
      
      box-shadow: 0 6px 14px rgba(0,0,0,.18), 0 0 12px rgba(255,215,120,.18);
      transition: transform .15s ease, opacity .15s ease;
    }
    .nudge-cta:active{ transform: scale(.98); opacity:.9; }

    @keyframes nudgePop {
      0% { transform: translateY(10px); opacity: 0; }
      100% { transform: translateY(0); opacity: 1; }
    }
    .nudge-bar.pop{ animation: nudgePop .18s ease-out; }
    
    /* Paid Photos Countdown Banner */
    .paid-countdown-banner{
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      padding: 12px 20px;
      z-index: 90;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }
    
    .paid-countdown-banner.show{
      transform: translateY(0);
    }
    
    .paid-countdown-content{
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      max-width: 1200px;
      margin: 0 auto;
      font-size: 14px;
      font-weight: 500;
    }
    
    .paid-countdown-icon{
      font-size: 18px;
    }
    
    .paid-countdown-text{
      text-align: center;
    }
    
    .paid-countdown-text strong{
      font-weight: 700;
      font-size: 16px;
    }
    
    /* Album photo count banner sopra la griglia */
    .album-photo-count{
      padding: 12px 20px;
      background: rgba(168, 85, 247, 0.1);
      border-bottom: 1px solid rgba(168, 85, 247, 0.2);
      text-align: center;
      font-size: 16px;
      font-weight: 600;
      color: var(--accent-light);
    }
    
    /* Deal Unlocked Modal */
    .deal-modal{
      position: fixed;
      inset: 0;
      z-index: 3000;
      display: none;               /* default off */
      pointer-events: none;        /* IMPORTANT: quando off non blocca */
    }
    .deal-modal.show{
      display: block;
      pointer-events: auto;        /* quando on prende i tap */
    }
    
    .deal-modal-backdrop{
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.70);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      pointer-events: auto; /* Backdrop intercetta click per chiudere */
    }
    
    /* Quando modal non ha .show, backdrop non deve intercettare */
    .deal-modal:not(.show) .deal-modal-backdrop{
      pointer-events: none;
    }
    
    .deal-modal-card{
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(.96);
      width: min(92vw, 440px);
      background: linear-gradient(135deg, rgba(168,85,247,.30), rgba(236,72,153,.22));
      border: 1px solid rgba(255,215,120,.55);
      box-shadow: 0 18px 60px rgba(0,0,0,.55), 0 0 28px rgba(255,215,120,.20);
      border-radius: 22px;
      padding: 22px 18px 18px;
      text-align: center;
      color: #fff;
      animation: dealPopIn 260ms ease-out forwards;
      overflow: hidden;
    }
    
    .deal-title{
      font-weight: 900;
      font-size: 18px;
      line-height: 1.2;
      margin-top: 8px;
      margin-bottom: 10px;
    }
    .deal-subtitle{
      font-weight: 800;
      font-size: 14px;
      opacity: .95;
      line-height: 1.35;
      margin-bottom: 16px;
    }
    
    .deal-continue-btn{
      width: 100%;
      border: none;
      border-radius: 14px;
      padding: 14px 16px;
      font-size: 16px;
      font-weight: 900;
      cursor: pointer;
      background: linear-gradient(135deg, #f7c948, #f59e0b);
      color: #1a1f3a;
      box-shadow: 0 8px 24px rgba(245,158,11,.28);
      transition: transform .15s ease;
    }
    .deal-continue-btn:active{
      transform: scale(.98);
    }

    /* confetti burst */
    .deal-burst{
      position:absolute;
      inset:-60px;
      pointer-events:none;
    }
    .deal-burst::before,
    .deal-burst::after{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(circle, rgba(255,215,120,.95) 0 2px, transparent 3px) 10% 20%/40px 40px,
        radial-gradient(circle, rgba(255,255,255,.9) 0 2px, transparent 3px) 30% 10%/52px 52px,
        radial-gradient(circle, rgba(168,85,247,.95) 0 2px, transparent 3px) 55% 25%/46px 46px,
        radial-gradient(circle, rgba(236,72,153,.95) 0 2px, transparent 3px) 75% 15%/52px 52px,
        radial-gradient(circle, rgba(255,215,120,.9) 0 2px, transparent 3px) 90% 30%/48px 48px;
      opacity: 0;
      animation: burst 3700ms ease-out forwards;
    }
    .deal-burst::after{
      transform: rotate(18deg);
      animation-delay: 120ms;
    }
    @keyframes burst{
      0%{ opacity: 0; transform: translateY(-10px) scale(.95); }
      15%{ opacity: 1; }
      70%{ opacity: 1; }
      100%{ opacity: 0; transform: translateY(90px) scale(1.08); }
    }
    
    @keyframes dealPopIn{
      to { transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes slideUpBanner {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
  </style>
</head>
<body>
  <!-- Email Screen -->
  <div class="screen email-screen" id="emailScreen">
    <h1 class="email-title">ENTER YOUR EMAIL âœ… LIVE TEST</h1>
    <p class="email-subtitle">Your email is required to save and recover your photos</p>
    <div class="email-input-container">
      <input type="email" class="email-input" id="emailInput" placeholder="your@email.com">
      <p class="email-error" id="emailError">Invalid email address</p>
        </div>
    <button class="btn-primary" id="emailContinueBtn">CONTINUE âœ… LIVE</button>
    <div class="email-loading" id="emailLoading" style="display: none;">
      <div class="loading-spinner"></div>
      <p>Checking your photos...</p>
    </div>
      </div>

  <!-- Welcome Screen -->
  <div class="screen welcome-screen" id="welcomeScreen">
    <div class="welcome-icon">
      <svg viewBox="0 0 100 100">
        <rect x="20" y="25" width="60" height="50" rx="8"/>
        <circle cx="50" cy="45" r="12"/>
        <rect x="35" y="60" width="30" height="8" rx="4"/>
        <circle cx="70" cy="35" r="4"/>
      </svg>
        </div>
    <h1 class="welcome-title" data-i18n="welcome_title">Find your photos!</h1>
    <button class="btn-primary" id="welcomeContinueBtn" data-i18n="welcome_take_selfie">Take a selfie</button>
      </div>
  
  <!-- Language Selection Screen -->
  <div class="screen language-screen" id="languageScreen">
    <h1 class="language-title" data-i18n="language_title">Choose your language</h1>
    <p class="language-subtitle" data-i18n="language_subtitle">We're finding your photosâ€¦</p>
    <div class="language-grid">
      <button class="language-option" data-lang="en">
        <span class="language-flag">ðŸ‡¬ðŸ‡§</span>
        <span class="language-name">English</span>
      </button>
      <button class="language-option" data-lang="es">
        <span class="language-flag">ðŸ‡ªðŸ‡¸</span>
        <span class="language-name">EspaÃ±ol</span>
      </button>
      <button class="language-option" data-lang="it">
        <span class="language-flag">ðŸ‡®ðŸ‡¹</span>
        <span class="language-name">Italiano</span>
      </button>
      <button class="language-option" data-lang="fr">
        <span class="language-flag">ðŸ‡«ðŸ‡·</span>
        <span class="language-name">FranÃ§ais</span>
      </button>
      <button class="language-option" data-lang="de">
        <span class="language-flag">ðŸ‡©ðŸ‡ª</span>
        <span class="language-name">Deutsch</span>
      </button>
    </div>
    <div id="langFeedback" style="margin-top: 16px; display: none; text-align: center;">
      <p style="color: var(--accent); font-weight: 600; margin-bottom: 8px;" id="langFeedbackText"></p>
      <p style="color: var(--text-muted); font-size: 14px;" id="langFindingText" data-i18n="finding_photos">Finding your photosâ€¦</p>
    </div>
    <div id="langLoading" style="display: none; pointer-events: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 1000; align-items: center; justify-content: center; flex-direction: column; gap: 20px;">
      <div class="loading-spinner"></div>
      <p style="color: var(--text-light); font-size: 16px;" data-i18n="loading_photos">Loading photos...</p>
    </div>
    <div id="langErrorBox" style="display: none; pointer-events: none; margin-top: 20px; padding: 20px; background: rgba(255,68,68,0.1); border: 2px solid rgba(255,68,68,0.3); border-radius: 12px; text-align: center; max-width: 400px; margin-left: auto; margin-right: auto;">
      <p style="color: var(--text-light); margin-bottom: 15px;" data-i18n="no_photos_found">No photos found yet. They may still be processing.</p>
      <button class="btn-primary" id="langRetakeSelfieBtn" data-i18n="retake_selfie">Retake selfie</button>
    </div>
  </div>

  <!-- Selfie Screen -->
  <div class="screen selfie-screen" id="selfieScreen">
    <div class="selfie-header">
      <h2 id="selfieHeaderText" data-i18n="take_your_selfie">Take your selfie</h2>
    </div>
    <div class="selfie-preview">
      <div class="selfie-video">
        <video id="video" autoplay playsinline muted webkit-playsinline style="display:none;"></video>
        <canvas id="canvas" style="display:none;"></canvas>
        <div id="videoPlaceholder" style="display: none; text-align: center; padding: 20px; color: var(--text-muted);">
          <p style="font-size: 14px;" data-i18n="camera_not_available">Camera not available</p>
          <button class="btn-primary" id="retryCameraBtn" style="margin-top: 15px; padding: 12px 24px; font-size: 14px;" data-i18n="retry">Retry</button>
        </div>
        <div id="startCameraPrompt" style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px 20px; text-align: center; min-height: 300px;">
          <p style="font-size: 16px; color: var(--text-muted); margin-bottom: 20px;" data-i18n="enable_camera">Enable camera access to take your selfie</p>
          <button class="btn-primary" id="startCameraBtn" style="padding: 14px 28px; font-size: 16px;" data-i18n="start_camera">Start Camera</button>
        </div>
      </div>
      <div class="selfie-controls">
        <button class="camera-btn" id="captureBtn" disabled>
          <svg viewBox="0 0 24 24" fill="none">
            <circle cx="12" cy="12" r="10"/>
          </svg>
        </button>
        <button class="btn-retake" id="switchCameraBtn" style="display:none;" data-i18n="switch_camera">Switch camera</button>
      </div>
    </div>
    <!-- Upload Status Area - sempre visibile quando attiva -->
    <div class="upload-status" id="uploadStatus">
      <div class="upload-status-text">
        <span class="upload-spinner"></span>
        <span id="uploadStatusText">Loading photos...</span>
      </div>
      <div class="upload-progress-container">
        <div class="upload-progress-bar" id="uploadProgressBar"></div>
      </div>
      <div class="upload-percentage" id="uploadPercentage">0%</div>
        </div>
      </div>
    
    <!-- Selfie Error Box - mostra errore quando match_selfie fallisce -->
    <div class="selfie-error-box" id="selfieErrorBox" style="display: none;">
      <div class="selfie-error-content">
        <p class="selfie-error-message" id="selfieErrorMessage" data-i18n="no_photos_found">No photos found or still processing. Please try again.</p>
        <button class="btn-retake-selfie" id="retakeSelfieBtn" data-i18n="retake_selfie">Retake selfie</button>
      </div>
    </div>

  <!-- Confirm Selfie Screen -->
  <div class="screen confirm-screen" id="confirmScreen">
    <h2 class="confirm-title" data-i18n="confirm_selfie">Confirm selfie</h2>
    <div class="confirm-preview">
      <img id="confirmPreview" alt="Selfie preview">
    </div>
    <p class="confirm-privacy">
      By selecting "Confirm" you consent to the processing of biometric data for the purposes of Detection and Recognition as per Privacy Policy.
    </p>
    <div class="confirm-buttons">
      <button class="btn-confirm" id="confirmBtn" data-i18n="continue">Confirm</button>
      <button class="btn-retake" id="retakeBtn" data-i18n="take_again">Take again</button>
    </div>
    <!-- Loading indicator per ricerca foto -->
    <div id="confirmLoadingIndicator" style="display: none; text-align: center; margin-top: 20px;">
      <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: var(--purple); border-radius: 50%; animation: spin 1s linear infinite;"></div>
      <p style="color: var(--text-muted); margin-top: 15px;" data-i18n="loading_photos">Loading photos...</p>
    </div>
  </div>

  <!-- Add People Screen -->
  <div class="screen add-people-screen" id="addPeopleScreen">
    <h2 class="add-people-title">Great!</h2>
    <p style="color: var(--text-muted); margin-bottom: 30px;">Do you want to add family members to this album?</p>
    <div class="people-list" id="peopleList">
      <div class="person-avatar">
        <img id="mainPersonAvatar" alt="Persona principale">
      </div>
      <button class="add-person-btn" id="addPersonBtn">+</button>
    </div>
    <div class="add-people-buttons">
      <button class="btn-primary" id="addPersonConfirmBtn">Yes, add another person</button>
      <button class="btn-retake" id="skipAddPersonBtn">Not now, go to album</button>
    </div>
    <!-- Loading indicator -->
    <div id="loadingIndicator" style="display: none; text-align: center; margin-top: 20px;">
      <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: var(--purple); border-radius: 50%; animation: spin 1s linear infinite;"></div>
      <p style="color: var(--text-muted); margin-top: 15px;">Loading photos...</p>
    </div>
  </div>

  <!-- Album Screen -->
  <div class="screen album-screen" id="albumScreen">
    <div class="album-header">
      <button class="album-back" id="albumBackBtn">â†</button>
      <div class="album-header-title" id="albumHeaderTitle">Metaproos S.L</div>

      <!-- Deal pill (desktop/tablet) -->
      <div id="dealPillDesktop" class="deal-pill" aria-label="Deal" style="margin-left:10px;">
        <div class="deal-pill-top" data-i18n="dealpill_top">Sblocca la maxi offerta</div>
        <div class="deal-pill-bottom" data-i18n="dealpill_bottom">Scegli 6 foto, dalla 7Âª paghi â‚¬1 ciascuna</div>
      </div>

      <button class="album-cart" id="albumCartBtn">
        ðŸ›’ <span id="albumCartCount">0</span> - <span id="albumCartPrice">â‚¬0</span>
      </button>
    </div>
    
    <!-- Mini Banner Deal (sotto header, mobile) -->
    <div id="albumTopMiniBar" class="album-top-mini-bar">
      <div id="dealPill" class="deal-pill">
        <div class="deal-pill-top" data-i18n="dealpill_top">Sblocca la maxi offerta</div>
        <div class="deal-pill-bottom" data-i18n="dealpill_bottom">Scegli 6 foto, dalla 7Âª paghi â‚¬1 ciascuna</div>
      </div>
    </div>
    
    <!-- Member Chips Row (mobile) -->
    <div id="memberChipsRow" class="member-chips-row members-bar"></div>
    
    <!-- Album Profile (desktop, nascosto su mobile) -->
    <div class="album-profile">
      <div class="profile-avatar">
        <!-- Logo rimosso per evitare 404 - usa solo testo -->
      </div>
      <div class="profile-info">
        <h3>Tenerife Stars Pictures</h3>
        <p>Your photo session was taken by Metaproos</p>
      </div>
      <button class="btn-secondary" id="addFamilyBtn" style="padding: 8px 16px; font-size: 14px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 20px; margin-left: auto;" data-i18n="add_family_member">
        ðŸ‘¥ Add family member
        <span id="familyMembersCount" style="margin-left: 8px; font-size: 12px; opacity: 0.8;">(0/8)</span>
      </button>
    </div>
    
    <!-- Sezione Membri -->
    <div id="familyMembersSection" style="padding: 0 20px 20px; margin-bottom: 20px; display: none;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 style="color: white; font-size: 18px; margin: 0;" data-i18n="added_members">Added members</h3>
        <button class="btn-primary" id="addMemberBtn" style="padding: 10px 20px; font-size: 14px;" data-i18n="add_member">
          ðŸ‘¥ Add member
        </button>
      </div>
      <div id="familyMembersList" style="display: flex; flex-wrap: wrap; gap: 10px;">
        <!-- Membri verranno aggiunti qui -->
      </div>
    </div>
    <div class="album-tabs">
      <button class="album-tab active" id="myContentTab" data-i18n="album_my_content">My content</button>
      <button class="album-tab" id="pricesTab" data-i18n="album_price_list">Price list â†—</button>
    </div>
    <div class="album-photo-count" id="albumPhotoCount" style="display: none;">
      <span>You found <span id="photoCountNumber">0</span> photos</span>
    </div>
    
    <!-- Listino Prezzi -->
    <div class="prices-list" id="pricesList">
      <h2 class="prices-title" data-i18n="price_list_title">Price List</h2>
      <p class="prices-subtitle" data-i18n="price_list_subtitle">Choose the offer you prefer</p>
      
      <div class="price-item">
        <div class="price-item-info">
          <div class="price-item-count" data-i18n="price_1_title">1 photo</div>
          <div class="price-item-desc" data-i18n="price_1_desc">Single photo</div>
        </div>
        <div class="price-item-value">â‚¬18</div>
      </div>

      <div class="price-item highlight">
        <div class="price-item-info">
          <div class="price-item-count"><span data-i18n="price_3_title">3 photos</span> <span class="price-item-badge" data-i18n="badge_discount">DISCOUNT</span></div>
          <div class="price-item-desc" data-i18n="price_3_desc">Special offer</div>
        </div>
        <div class="price-item-value">â‚¬39</div>
      </div>
      
      <div class="price-item highlight">
        <div class="price-item-info">
          <div class="price-item-count"><span data-i18n="price_6_title">6 photos</span> <span class="price-item-badge" data-i18n="badge_most_chosen">MOST CHOSEN</span></div>
          <div class="price-item-desc" data-i18n="price_6_desc">Best choice</div>
        </div>
        <div class="price-item-value">â‚¬47</div>
      </div>
      
      <div class="price-item highlight topdeal">
        <div class="price-item-info">
          <div class="price-item-count"><span data-i18n="price_maxi_title">Maxi offerta</span> <span class="price-item-badge">TOP</span></div>
          <div class="price-item-desc" data-i18n="price_maxi_desc">Dalla 7Âª foto â‚¬1 ciascuna</div>
        </div>
        <div class="price-item-value">â‚¬1</div>
      </div>
    </div>
    
    <div class="album-grid" id="albumGrid">
      <!-- Foto verranno aggiunte qui -->
    </div>
    
    <!-- Overlay caricamento album -->
    <div class="album-loading-overlay" id="albumLoadingOverlay">
      <div class="album-loading-content">
        <div class="album-loading-spinner"></div>
        <p id="albumLoadingText">Loading photos...</p>
      </div>
    </div>
    
  </div>
  
  <!-- Nudge Bar: suggerisce upgrade al prossimo scaglione -->
  <div id="nudgeBar" class="nudge-bar" style="display:none;">
    <div class="nudge-text">
      <div id="nudgeLine1"></div>
      <div id="nudgeLine2"></div>
    </div>
    <button id="nudgeCheckoutBtn" class="nudge-cta" data-i18n="nudge_go_checkout">Vai al checkout</button>
  </div>
  
  <!-- Sticky Offer Bar -->
  <!-- Sticky Offer Bar (pill button) -->
  <div class="sticky-offer-bar" id="stickyOfferBar" role="button" aria-label="Buy all photos">
    <div class="sticky-offer-content" style="flex:1; display:flex; flex-direction:column; gap:4px; min-width:0;">
      <div id="stickyOfferFoundText"
           style="font-size:12px; font-weight:800; color:rgba(255,255,255,.95); line-height:1.15; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
        0 photos found
      </div>
      <div id="stickyOfferCtaText"
           style="font-size:14px; font-weight:900; color:#fff; line-height:1.15; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
        Buy all for â‚¬0
      </div>
    </div>
    <div aria-hidden="true" style="font-size:22px; font-weight:900; color:rgba(255,255,255,.9); line-height:1; padding-left:6px;">â€º</div>
  </div>
  
  <!-- Paid Photos Countdown Banner -->
  <div class="paid-countdown-banner" id="paidCountdownBanner" style="display: none;">
    <div class="paid-countdown-content">
      <span class="paid-countdown-icon">â°</span>
      <span class="paid-countdown-text" id="paidCountdownText">Your paid photos will expire in <strong id="paidCountdownDays">30</strong> days</span>
    </div>
  </div>

  <!-- Lightbox per foto -->
  <div class="ios-share-modal" id="photoLightbox" style="z-index: 2000;">
    <div style="position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
      <button id="lightboxClose" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.6); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 24px; cursor: pointer; z-index: 10;">âœ•</button>
      <div style="position: absolute; top: 20px; left: 20px; color: white; font-size: 16px; z-index: 10; background: rgba(0,0,0,0.6); padding: 8px 16px; border-radius: 20px;" id="photoCounter">1/1</div>
      <button id="lightboxPrev" style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.6); color: white; border: none; width: 50px; height: 50px; border-radius: 50%; font-size: 24px; cursor: pointer; z-index: 10; display: none;">â†</button>
      <button id="lightboxNext" style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.6); color: white; border: none; width: 50px; height: 50px; border-radius: 50%; font-size: 24px; cursor: pointer; z-index: 10; display: none;">â†’</button>
      <button id="lightboxDownload" style="position: absolute; bottom: 20px; right: 20px; background: rgba(123, 116, 255, 0.9); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; z-index: 10; display: none;" data-i18n="lightbox_download">ðŸ“¥ Download</button>
      <div id="lightboxIOSInstruction" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.85); color: white; padding: 14px 20px; border-radius: 12px; font-size: 15px; font-weight: 500; text-align: center; z-index: 10; pointer-events: none; display: none; max-width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.3);" data-i18n="lightbox_ios_hint">ðŸ“± Tieni premuto sull'immagine e tocca 'Salva in Foto'</div>
      <div id="lightboxCartCTA" style="position: fixed; bottom: calc(20px + env(safe-area-inset-bottom, 0px)); left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); color: #5f58ff; padding: 12px 24px; border-radius: 50px; text-align: center; z-index: 10; display: none; max-width: 85%; width: auto; min-width: 200px; box-shadow: 0 4px 20px rgba(95, 88, 255, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.5) inset, 0 8px 32px rgba(0, 0, 0, 0.15); border: 1px solid rgba(123, 116, 255, 0.2); pointer-events: auto; animation: slideUpBanner 0.4s ease-out;">
        <button id="lightboxAddCartBtn" style="background: linear-gradient(135deg, #7b74ff 0%, #5f58ff 100%); color: white; border: none; padding: 12px 24px; border-radius: 25px; font-size: 15px; font-weight: 600; cursor: pointer; white-space: nowrap; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(95, 88, 255, 0.3);" data-i18n="lightbox_add_to_cart">Aggiungi al carrello</button>
      </div>
      <img id="lightboxImage" style="max-width: 100%; max-height: 100%; object-fit: contain;" alt="Foto">
    </div>
  </div>
  
  <!-- Modal Carrello -->
  <div class="ios-share-modal" id="cartModal">
    <div class="ios-share-modal-content" style="max-width: 500px; width: 90%;">
      <h3 style="margin-top: 0; font-size: 20px; color: var(--text-light);" data-i18n="cart_title">ðŸ›’ Carrello</h3>
      <div id="cartItems" style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
        <p style="text-align: center; color: var(--text-muted);" data-i18n="cart_empty">Il carrello Ã¨ vuoto</p>
      </div>
      <div style="border-top: 2px solid rgba(255,255,255,0.1); padding-top: 15px; margin-top: 15px;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 15px; font-size: 18px; font-weight: 600; color: var(--text-light);">
          <span data-i18n="cart_total">Totale:</span>
          <span id="cartTotal">â‚¬0.00</span>
        </div>
        <button class="btn-primary" id="checkoutBtn" style="width: 100%; margin-bottom: 10px;" disabled data-i18n="cart_checkout">ðŸ’³ Checkout</button>
        <button class="btn-retake" id="closeCartBtn" style="width: 100%; margin-bottom: 10px;" data-i18n="cart_continue_selection">Continua la selezione</button>
        <button class="btn-retake" id="clearCartBtn" style="width: 100%; background: #ff4444; color: white; border: none;" data-i18n="cart_clear_all">ðŸ—‘ï¸ Svuota carrello</button>
      </div>
    </div>
  </div>

  <!-- Modal Offerte -->
  <div class="ios-share-modal" id="offersModal">
    <div class="ios-share-modal-content" style="max-width: 500px; width: 90%; background: var(--bg-dark2); border: 2px solid var(--accent);">
      <h3 style="margin-top: 0; font-size: 24px; color: var(--text-light); text-align: center;">ðŸŽ Offerta Speciale!</h3>
      <div id="offersContent" style="text-align: center; padding: 20px 0;">
        <p style="font-size: 18px; color: var(--text-light); margin-bottom: 15px;">
          Hai trovato <strong id="offersPhotoCount" style="color: var(--accent-light);">0</strong> foto!
        </p>
        <div id="offersMessage" style="font-size: 16px; color: var(--text-muted); margin-bottom: 20px;">
          <!-- Messaggio offerta dinamico -->
        </div>
        <div style="background: linear-gradient(135deg, var(--purple), var(--pink)); color: #fff; padding: 20px; border-radius: 12px; margin: 20px 0;">
          <div style="font-size: 32px; font-weight: 900; margin-bottom: 10px;" id="offersPrice">â‚¬0</div>
          <div style="font-size: 14px; opacity: 0.9;">per tutte le tue foto</div>
        </div>
        <button class="btn-primary" id="offersBuyBtn" style="width: 100%; margin-bottom: 10px; font-size: 18px; padding: 16px;">
          ðŸ’³ Buy All Photos
        </button>
        <button class="btn-retake" id="offersCloseBtn" style="width: 100%;">
          Choose Single Photos
        </button>
      </div>
    </div>
  </div>

  <script>
    // ========== SISTEMA TRADUZIONI ==========
    
    // Variabili globali lingua
    let currentLang = 'en';
    let selectedLanguage = null;
    let photosReady = false;
    let photosFailed = false;
    // Promise della ricerca foto avviata in background dopo il selfie
    let photosSearchPromise = null;

    // ========== DEBUG HELPERS (must never break the flow) ==========
    // Some mobile browsers throw if a debug helper is missing.
    // We define them here so any call to debugLog/debugSet cannot stop the app.
    function debugLog(message) {
      try {
        const msg = String(message);
        console.log('[DEBUG]', msg);

        // If a debug panel exists, append the line.
        const feed = document.getElementById('debugFeed') || document.getElementById('debugLog') || document.getElementById('debugLines');
        if (feed) {
          const line = document.createElement('div');
          line.textContent = msg;
          feed.appendChild(line);
          // keep it short
          while (feed.children.length > 60) feed.removeChild(feed.firstChild);
        }
      } catch (e) {
        // swallow on purpose
      }
    }

    function debugSet(key, value) {
      try {
        const v = (value === undefined || value === null) ? '-' : String(value);

        // Common patterns: id="debug_<key>" or data-debug-key="<key>"
        const byId = document.getElementById(`debug_${key}`);
        if (byId) byId.textContent = `${key}: ${v}`;

        const nodes = document.querySelectorAll(`[data-debug-key="${key}"]`);
        if (nodes && nodes.length) {
          nodes.forEach(n => {
            n.textContent = `${key}: ${v}`;
          });
        }

        // Also log it
        debugLog(`${key}: ${v}`);
      } catch (e) {
        // swallow on purpose
      }
    }
    
    // Oggetto traduzioni completo
    const I18N = {
      en: {
        welcome_title: "Find your photos!",
        welcome_take_selfie: "Take a selfie",
        language_title: "Choose your language",
        language_subtitle: "Choose a language to continue",
        language_selected: "âœ… {langName} selected",
        finding_photos: "Finding your photosâ€¦",
        loading_photos: "Loading photos...",
        no_photos_found: "No photos found yet. They may still be processing.",
        retake_selfie: "Retake selfie",
        take_your_selfie: "Take your selfie",
        family_member_selfie: "Family member selfie",
        confirm_selfie: "Confirm selfie",
        take_again: "Take again",
        camera_not_available: "Camera not available",
        retry: "Retry",
        enable_camera: "Enable camera access to take your selfie",
        start_camera: "Start Camera",
        switch_camera: "Switch camera",
        album_my_content: "My content",
        album_price_list: "Price list â†—",
        album_photo_count: "You found {count} photos",
        cart_title: "ðŸ›’ Cart",
        cart_empty: "Cart is empty",
        cart_total: "Total:",
        cart_checkout: "ðŸ’³ Checkout",
        cart_close: "Close",
        cart_continue_selection: "Continue selecting",
        cart_clear_all: "ðŸ—‘ï¸ Clear cart",
        cart_loading: "â³ Loading...",
        cart_go_payment: "ðŸ’³ Go to Payment",
        lightbox_download: "ðŸ“¥ Download",
        lightbox_add_to_cart: "Add to cart",
        lightbox_remove_from_cart: "Remove from cart",
        lightbox_ios_hint: "ðŸ“± Hold the image and tap 'Save to Photos'",
        lightbox_purchase_hint: "Purchase to download photos without watermark",
        deal_title: "Congratulations! You unlocked the maxi deal",
        deal_subtitle: "From the 7th photo you pay â‚¬1 each",
        deal_continue: "Continue selection",
        nudge_selected_all: "You selected everything",
        nudge_go_checkout: "Go to checkout",
        nudge_deal_unlocked: "From the 7th photo you pay â‚¬1 each",
        nudge_add_more: "Add more or go to checkout",
        nudge_add_one: "Add 1 photo: you pay only â‚¬{price}",
        nudge_add_many: "Add {count} photos: only â‚¬{price} each",
        nudge_unlock_package: "Unlock the {count} photo package",
        sticky_take_all: "Take them all",
        sticky_unlock_all: "Unlock all",
        sticky_found_photos: "{count} photos found",
        sticky_buy_all_for: "Buy all for â‚¬{price}",
        dealpill_top: "Unlock the maxi deal",
        dealpill_bottom: "Pick 6 photos, from the 7th you pay â‚¬1 each",
        add_family_member: "ðŸ‘¥ Add family member",
        added_members: "Added members",
        add_member: "ðŸ‘¥ Add member",
        price_list_title: "Price List",
        price_list_subtitle: "Choose the offer you prefer",
        photo: "photo",
        photos: "photos",
        single_photo: "Single photo",
        double: "Double",
        special_offer: "Special offer",
        package: "Package",
        complete_package: "Complete package",
        all_photos_best: "All photos at the best price",
        discount: "Discount",
        best: "Best",
        top: "Top",
        price_1_title: "1 photo",
        price_1_desc: "Single photo",
        price_3_title: "3 photos",
        price_3_desc: "Special offer",
        badge_discount: "DISCOUNT",
        price_6_title: "6 photos",
        price_6_desc: "Best choice",
        badge_most_chosen: "MOST CHOSEN",
        price_maxi_title: "Maxi deal",
        price_maxi_desc: "From the 7th photo â‚¬1 each",
        price_note_maxi: "Maxi deal: from the 7th photo â‚¬1 each",
        paid_countdown: "Your paid photos will expire in <strong>{days}</strong> days",
        error_download: "Error downloading photo. Please try again.",
        error_checkout: "Error during checkout. Please try again.",
        checkout_loading: "Loading...",
        no_face_detected: "No face detected in selfie. Please try again.",
        checking_photos: "Checking your photos...",
        continue: "Continue",
        close: "Close",
        next: "Next",
        prev: "Previous"
      },
      es: {
        welcome_title: "Â¡Encuentra tus fotos!",
        welcome_take_selfie: "Hazte un selfie",
        language_title: "Elige tu idioma",
        language_subtitle: "Elige un idioma para continuar",
        language_selected: "âœ… {langName} seleccionado",
        finding_photos: "Buscando tus fotosâ€¦",
        loading_photos: "Cargando fotos...",
        no_photos_found: "No se encontraron fotos todavÃ­a. Pueden estar procesÃ¡ndose.",
        retake_selfie: "Volver a hacer selfie",
        take_your_selfie: "Hazte un selfie",
        family_member_selfie: "Selfie de miembro de la familia",
        confirm_selfie: "Confirmar selfie",
        take_again: "Hacer de nuevo",
        camera_not_available: "CÃ¡mara no disponible",
        retry: "Reintentar",
        enable_camera: "Habilita el acceso a la cÃ¡mara para hacerte un selfie",
        start_camera: "Iniciar cÃ¡mara",
        switch_camera: "Cambiar cÃ¡mara",
        album_my_content: "Mi contenido",
        album_price_list: "Lista de precios â†—",
        album_photo_count: "Encontraste {count} fotos",
        cart_title: "ðŸ›’ Carrito",
        cart_empty: "El carrito estÃ¡ vacÃ­o",
        cart_total: "Total:",
        cart_checkout: "ðŸ’³ Pagar",
        cart_close: "Cerrar",
        cart_continue_selection: "Seguir seleccionando",
        cart_clear_all: "ðŸ—‘ï¸ Vaciar carrito",
        cart_loading: "â³ Cargando...",
        cart_go_payment: "ðŸ’³ Ir al pago",
        lightbox_download: "ðŸ“¥ Descargar",
        lightbox_add_to_cart: "AÃ±adir al carrito",
        lightbox_remove_from_cart: "Quitar del carrito",
        lightbox_ios_hint: "ðŸ“± MantÃ©n presionada la imagen y toca 'Guardar en Fotos'",
        lightbox_purchase_hint: "Compra para descargar fotos sin marca de agua",
        deal_title: "Â¡Felicidades! Has desbloqueado la maxi oferta",
        deal_subtitle: "Desde la 7Âª foto pagas â‚¬1 cada una",
        deal_continue: "Continuar selecciÃ³n",
        nudge_selected_all: "Seleccionaste todo",
        nudge_go_checkout: "Ir al pago",
        nudge_deal_unlocked: "Desde la 7Âª foto pagas â‚¬1 cada una",
        nudge_add_more: "AÃ±ade mÃ¡s o ve al pago",
        nudge_add_one: "AÃ±ade 1 foto: pagas solo â‚¬{price}",
        nudge_add_many: "AÃ±ade {count} fotos: solo â‚¬{price} cada una",
        nudge_unlock_package: "Desbloquea el paquete de {count} fotos",
        sticky_take_all: "TÃ³malas todas",
        sticky_unlock_all: "Desbloquear todas",
        sticky_found_photos: "{count} fotos encontradas",
        sticky_buy_all_for: "CÃ³mpralas todas por â‚¬{price}",
        dealpill_top: "Desbloquea la maxi oferta",
        dealpill_bottom: "Elige 6 fotos, desde la 7Âª pagas â‚¬1 cada una",
        add_family_member: "ðŸ‘¥ AÃ±adir miembro de la familia",
        added_members: "Miembros aÃ±adidos",
        add_member: "ðŸ‘¥ AÃ±adir miembro",
        price_list_title: "Lista de precios",
        price_list_subtitle: "Elige la oferta que prefieras",
        photo: "foto",
        photos: "fotos",
        single_photo: "Foto individual",
        double: "Doble",
        special_offer: "Oferta especial",
        package: "Paquete",
        complete_package: "Paquete completo",
        all_photos_best: "Todas las fotos al mejor precio",
        discount: "Descuento",
        best: "Mejor",
        top: "Top",
        price_1_title: "1 foto",
        price_1_desc: "Foto individual",
        price_3_title: "3 fotos",
        price_3_desc: "Oferta especial",
        badge_discount: "DISCOUNT",
        price_6_title: "6 fotos",
        price_6_desc: "Mejor opciÃ³n",
        badge_most_chosen: "MOST CHOSEN",
        price_maxi_title: "Maxi oferta",
        price_maxi_desc: "Desde la 7Âª foto â‚¬1 cada una",
        price_note_maxi: "Maxi oferta: desde la 7Âª foto â‚¬1 cada una",
        paid_countdown: "Tus fotos pagadas expirarÃ¡n en <strong>{days}</strong> dÃ­as",
        error_download: "Error al descargar la foto. Por favor, intÃ©ntalo de nuevo.",
        error_checkout: "Error durante el pago. Por favor, intÃ©ntalo de nuevo.",
        checkout_loading: "Cargando...",
        no_face_detected: "No se detectÃ³ cara en el selfie. Por favor, intÃ©ntalo de nuevo.",
        checking_photos: "Comprobando tus fotos...",
        continue: "Continuar",
        close: "Cerrar",
        next: "Siguiente",
        prev: "Anterior"
      },
      it: {
        welcome_title: "Trova le tue foto!",
        welcome_take_selfie: "Fai un selfie",
        language_title: "Scegli la tua lingua",
        language_subtitle: "Scegli una lingua per continuare",
        language_selected: "âœ… {langName} selezionato",
        finding_photos: "Cercando le tue fotoâ€¦",
        loading_photos: "Caricamento foto...",
        no_photos_found: "Nessuna foto trovata ancora. Potrebbero essere ancora in elaborazione.",
        retake_selfie: "Rifai il selfie",
        take_your_selfie: "Fai il tuo selfie",
        family_member_selfie: "Selfie membro famiglia",
        confirm_selfie: "Conferma selfie",
        take_again: "Rifai",
        camera_not_available: "Fotocamera non disponibile",
        retry: "Riprova",
        enable_camera: "Abilita l'accesso alla fotocamera per fare il selfie",
        start_camera: "Avvia fotocamera",
        switch_camera: "Cambia fotocamera",
        album_my_content: "I miei contenuti",
        album_price_list: "Listino prezzi â†—",
        album_photo_count: "Hai trovato {count} foto",
        cart_title: "ðŸ›’ Carrello",
        cart_empty: "Il carrello Ã¨ vuoto",
        cart_total: "Totale:",
        cart_checkout: "ðŸ’³ Checkout",
        cart_close: "Chiudi",
        cart_continue_selection: "Continua la selezione",
        cart_clear_all: "ðŸ—‘ï¸ Svuota carrello",
        cart_loading: "â³ Caricamento...",
        cart_go_payment: "ðŸ’³ Vai al Pagamento",
        lightbox_download: "ðŸ“¥ Download",
        lightbox_add_to_cart: "Aggiungi al carrello",
        lightbox_remove_from_cart: "Rimuovi dal carrello",
        lightbox_ios_hint: "ðŸ“± Tieni premuto sull'immagine e tocca 'Salva in Foto'",
        lightbox_purchase_hint: "Acquista per scaricare le foto senza watermark",
        deal_title: "Complimenti! Hai sbloccato la maxi offerta",
        deal_subtitle: "Dalla 7Âª foto paghi â‚¬1 ciascuna",
        deal_continue: "Continua la selezione",
        nudge_selected_all: "Hai selezionato tutto",
        nudge_go_checkout: "Vai al checkout",
        nudge_deal_unlocked: "Dalla 7Âª foto paghi â‚¬1 ciascuna",
        nudge_add_more: "Aggiungine altre o vai al checkout",
        nudge_add_one: "Aggiungi 1 foto: la paghi solo â‚¬{price}",
        nudge_add_many: "Aggiungi {count} foto: solo â‚¬{price} ciascuna",
        nudge_unlock_package: "Sblocchi il pacchetto da {count} foto",
        sticky_take_all: "Prendile tutte",
        sticky_unlock_all: "Sblocca tutte",
        sticky_found_photos: "{count} foto trovate",
        sticky_buy_all_for: "Acquistale tutte a â‚¬{price}",
        dealpill_top: "Sblocca la maxi offerta",
        dealpill_bottom: "Scegli 6 foto, dalla 7Âª paghi â‚¬1 ciascuna",
        add_family_member: "ðŸ‘¥ Aggiungi membro famiglia",
        added_members: "Membri aggiunti",
        add_member: "ðŸ‘¥ Aggiungi membro",
        price_list_title: "Listino Prezzi",
        price_list_subtitle: "Scegli l'offerta che preferisci",
        photo: "foto",
        photos: "foto",
        single_photo: "Foto singola",
        double: "Doppia",
        special_offer: "Offerta speciale",
        package: "Pacchetto",
        complete_package: "Pacchetto completo",
        all_photos_best: "Tutte le foto al miglior prezzo",
        discount: "Sconto",
        best: "Migliore",
        top: "Top",
        price_1_title: "1 foto",
        price_1_desc: "Foto singola",
        price_3_title: "3 foto",
        price_3_desc: "Offerta speciale",
        badge_discount: "DISCOUNT",
        price_6_title: "6 foto",
        price_6_desc: "Scelta migliore",
        badge_most_chosen: "MOST CHOSEN",
        price_maxi_title: "Maxi offerta",
        price_maxi_desc: "Dalla 7Âª foto â‚¬1 ciascuna",
        price_note_maxi: "Maxi offerta: dalla 7Âª foto â‚¬1 ciascuna",
        paid_countdown: "Le tue foto pagate scadranno tra <strong>{days}</strong> giorni",
        error_download: "Errore nel download della foto. Riprova.",
        error_checkout: "Errore durante il checkout. Riprova.",
        checkout_loading: "Caricamento...",
        no_face_detected: "Nessun volto rilevato nel selfie. Riprova.",
        checking_photos: "Controllo delle tue foto...",
        continue: "Continua",
        close: "Chiudi",
        next: "Successivo",
        prev: "Precedente"
      },
      fr: {
        welcome_title: "Trouvez vos photos!",
        welcome_take_selfie: "Prendre un selfie",
        language_title: "Choisissez votre langue",
        language_subtitle: "Choisissez une langue pour continuer",
        language_selected: "âœ… {langName} sÃ©lectionnÃ©",
        finding_photos: "Recherche de vos photosâ€¦",
        loading_photos: "Chargement des photos...",
        no_photos_found: "Aucune photo trouvÃ©e pour le moment. Elles peuvent encore Ãªtre en cours de traitement.",
        retake_selfie: "Refaire le selfie",
        take_your_selfie: "Prenez votre selfie",
        family_member_selfie: "Selfie membre famille",
        confirm_selfie: "Confirmer le selfie",
        take_again: "Reprendre",
        camera_not_available: "CamÃ©ra non disponible",
        retry: "RÃ©essayer",
        enable_camera: "Activez l'accÃ¨s Ã  la camÃ©ra pour prendre votre selfie",
        start_camera: "DÃ©marrer la camÃ©ra",
        switch_camera: "Changer de camÃ©ra",
        album_my_content: "Mon contenu",
        album_price_list: "Liste des prix â†—",
        album_photo_count: "Vous avez trouvÃ© {count} photos",
        cart_title: "ðŸ›’ Panier",
        cart_empty: "Le panier est vide",
        cart_total: "Total:",
        cart_checkout: "ðŸ’³ Paiement",
        cart_close: "Fermer",
        cart_continue_selection: "Continuer la sÃ©lection",
        cart_clear_all: "ðŸ—‘ï¸ Vider le panier",
        cart_loading: "â³ Chargement...",
        cart_go_payment: "ðŸ’³ Aller au paiement",
        lightbox_download: "ðŸ“¥ TÃ©lÃ©charger",
        lightbox_add_to_cart: "Ajouter au panier",
        lightbox_remove_from_cart: "Retirer du panier",
        lightbox_ios_hint: "ðŸ“± Maintenez l'image et appuyez sur 'Enregistrer dans Photos'",
        lightbox_purchase_hint: "Achetez pour tÃ©lÃ©charger les photos sans filigrane",
        deal_title: "FÃ©licitations! Tu as dÃ©bloquÃ© la maxi offre",
        deal_subtitle: "DÃ¨s la 7e photo tu paies â‚¬1 chacune",
        deal_continue: "Continuer la sÃ©lection",
        nudge_selected_all: "Vous avez tout sÃ©lectionnÃ©",
        nudge_go_checkout: "Aller au paiement",
        nudge_deal_unlocked: "DÃ¨s la 7e photo tu paies â‚¬1 chacune",
        nudge_add_more: "Ajoutez-en plus ou allez au paiement",
        nudge_add_one: "Ajoutez 1 photo: vous payez seulement â‚¬{price}",
        nudge_add_many: "Ajoutez {count} photos: seulement â‚¬{price} chacune",
        nudge_unlock_package: "DÃ©bloquez le pack de {count} photos",
        sticky_take_all: "Prenez-les toutes",
        sticky_unlock_all: "DÃ©bloquer toutes",
        sticky_found_photos: "{count} photos trouvÃ©es",
        sticky_buy_all_for: "Achetez-les toutes pour â‚¬{price}",
        dealpill_top: "DÃ©bloque la maxi offre",
        dealpill_bottom: "Choisis 6 photos, dÃ¨s la 7e tu paies 1â‚¬ chacune",
        add_family_member: "ðŸ‘¥ Ajouter un membre de la famille",
        added_members: "Membres ajoutÃ©s",
        add_member: "ðŸ‘¥ Ajouter un membre",
        price_list_title: "Liste des prix",
        price_list_subtitle: "Choisissez l'offre que vous prÃ©fÃ©rez",
        photo: "photo",
        photos: "photos",
        single_photo: "Photo unique",
        double: "Double",
        special_offer: "Offre spÃ©ciale",
        package: "Pack",
        complete_package: "Pack complet",
        all_photos_best: "Toutes les photos au meilleur prix",
        discount: "RÃ©duction",
        best: "Meilleur",
        top: "Top",
        price_1_title: "1 photo",
        price_1_desc: "Photo unique",
        price_3_title: "3 photos",
        price_3_desc: "Offre spÃ©ciale",
        badge_discount: "DISCOUNT",
        price_6_title: "6 photos",
        price_6_desc: "Meilleur choix",
        badge_most_chosen: "MOST CHOSEN",
        price_maxi_title: "Maxi offre",
        price_maxi_desc: "DÃ¨s la 7e photo â‚¬1 chacune",
        price_note_maxi: "Maxi offre: dÃ¨s la 7e photo â‚¬1 chacune",
        paid_countdown: "Vos photos payÃ©es expireront dans <strong>{days}</strong> jours",
        error_download: "Erreur lors du tÃ©lÃ©chargement de la photo. Veuillez rÃ©essayer.",
        error_checkout: "Erreur lors du paiement. Veuillez rÃ©essayer.",
        checkout_loading: "Chargement...",
        no_face_detected: "Aucun visage dÃ©tectÃ© dans le selfie. Veuillez rÃ©essayer.",
        checking_photos: "VÃ©rification de vos photos...",
        continue: "Continuer",
        close: "Fermer",
        next: "Suivant",
        prev: "PrÃ©cÃ©dent"
      },
      de: {
        welcome_title: "Finde deine Fotos!",
        welcome_take_selfie: "Ein Selfie machen",
        language_title: "WÃ¤hle deine Sprache",
        language_subtitle: "WÃ¤hle eine Sprache, um fortzufahren",
        language_selected: "âœ… {langName} ausgewÃ¤hlt",
        finding_photos: "Suche deine Fotosâ€¦",
        loading_photos: "Fotos werden geladen...",
        no_photos_found: "Noch keine Fotos gefunden. Sie werden mÃ¶glicherweise noch verarbeitet.",
        retake_selfie: "Selfie erneut aufnehmen",
        take_your_selfie: "Mach dein Selfie",
        family_member_selfie: "Familienmitglied Selfie",
        confirm_selfie: "Selfie bestÃ¤tigen",
        take_again: "Erneut aufnehmen",
        camera_not_available: "Kamera nicht verfÃ¼gbar",
        retry: "Erneut versuchen",
        enable_camera: "Kamerazugriff aktivieren, um dein Selfie zu machen",
        start_camera: "Kamera starten",
        switch_camera: "Kamera wechseln",
        album_my_content: "Meine Inhalte",
        album_price_list: "Preisliste â†—",
        album_photo_count: "Du hast {count} Fotos gefunden",
        cart_title: "ðŸ›’ Warenkorb",
        cart_empty: "Der Warenkorb ist leer",
        cart_total: "Gesamt:",
        cart_checkout: "ðŸ’³ Zur Kasse",
        cart_close: "SchlieÃŸen",
        cart_continue_selection: "Auswahl fortsetzen",
        cart_clear_all: "ðŸ—‘ï¸ Warenkorb leeren",
        cart_loading: "â³ Wird geladen...",
        cart_go_payment: "ðŸ’³ Zur Zahlung",
        lightbox_download: "ðŸ“¥ Herunterladen",
        lightbox_add_to_cart: "In den Warenkorb",
        lightbox_remove_from_cart: "Aus Warenkorb entfernen",
        lightbox_ios_hint: "ðŸ“± Bild gedrÃ¼ckt halten und 'In Fotos speichern' tippen",
        lightbox_purchase_hint: "Kaufen, um Fotos ohne Wasserzeichen herunterzuladen",
        deal_title: "GlÃ¼ckwunsch! Du hast das Maxi-Angebot freigeschaltet",
        deal_subtitle: "Ab dem 7. Foto zahlst du â‚¬1 pro StÃ¼ck",
        deal_continue: "Auswahl fortsetzen",
        nudge_selected_all: "Du hast alles ausgewÃ¤hlt",
        nudge_go_checkout: "Zur Kasse",
        nudge_deal_unlocked: "Ab dem 7. Foto zahlst du â‚¬1 pro StÃ¼ck",
        nudge_add_more: "FÃ¼ge mehr hinzu oder gehe zur Kasse",
        nudge_add_one: "FÃ¼ge 1 Foto hinzu: du zahlst nur â‚¬{price}",
        nudge_add_many: "FÃ¼ge {count} Fotos hinzu: nur â‚¬{price} pro StÃ¼ck",
        nudge_unlock_package: "Schalte das {count} Fotos Paket frei",
        sticky_take_all: "Nimm sie alle",
        sticky_unlock_all: "Alle freischalten",
        sticky_found_photos: "{count} Fotos gefunden",
        sticky_buy_all_for: "Kaufe alle fÃ¼r â‚¬{price}",
        dealpill_top: "Schalte das Maxi-Angebot frei",
        dealpill_bottom: "WÃ¤hle 6 Fotos, ab dem 7. zahlst du â‚¬1 pro Foto",
        add_family_member: "ðŸ‘¥ Familienmitglied hinzufÃ¼gen",
        added_members: "HinzugefÃ¼gte Mitglieder",
        add_member: "ðŸ‘¥ Mitglied hinzufÃ¼gen",
        price_list_title: "Preisliste",
        price_list_subtitle: "WÃ¤hle das Angebot, das dir gefÃ¤llt",
        photo: "Foto",
        photos: "Fotos",
        single_photo: "Einzelfoto",
        double: "Doppel",
        special_offer: "Sonderangebot",
        package: "Paket",
        complete_package: "Komplettpaket",
        all_photos_best: "Alle Fotos zum besten Preis",
        discount: "Rabatt",
        best: "Beste",
        top: "Top",
        price_1_title: "1 Foto",
        price_1_desc: "Einzelfoto",
        price_3_title: "3 Fotos",
        price_3_desc: "Sonderangebot",
        badge_discount: "DISCOUNT",
        price_6_title: "6 Fotos",
        price_6_desc: "Beste Wahl",
        badge_most_chosen: "MOST CHOSEN",
        price_maxi_title: "Maxi-Angebot",
        price_maxi_desc: "Ab dem 7. Foto â‚¬1 pro StÃ¼ck",
        price_note_maxi: "Maxi-Angebot: ab dem 7. Foto â‚¬1 pro StÃ¼ck",
        paid_countdown: "Deine bezahlten Fotos laufen in <strong>{days}</strong> Tagen ab",
        error_download: "Fehler beim Herunterladen des Fotos. Bitte versuche es erneut.",
        error_checkout: "Fehler beim Checkout. Bitte versuche es erneut.",
        checkout_loading: "Wird geladen...",
        no_face_detected: "Kein Gesicht im Selfie erkannt. Bitte versuche es erneut.",
        checking_photos: "ÃœberprÃ¼fe deine Fotos...",
        continue: "Weiter",
        close: "SchlieÃŸen",
        next: "Weiter",
        prev: "ZurÃ¼ck"
      },
      nl: {
        welcome_title: "Vind je foto's!",
        welcome_take_selfie: "Maak een selfie",
        language_title: "Kies je taal",
        language_subtitle: "Kies een taal om door te gaan",
        language_selected: "âœ… {langName} geselecteerd",
        finding_photos: "Je foto's zoekenâ€¦",
        loading_photos: "Foto's laden...",
        no_photos_found: "Nog geen foto's gevonden. Ze worden mogelijk nog verwerkt.",
        retake_selfie: "Selfie opnieuw maken",
        take_your_selfie: "Maak je selfie",
        family_member_selfie: "Familielid selfie",
        confirm_selfie: "Bevestig selfie",
        take_again: "Opnieuw maken",
        camera_not_available: "Camera niet beschikbaar",
        retry: "Opnieuw proberen",
        enable_camera: "Schakel cameratoegang in om je selfie te maken",
        start_camera: "Start camera",
        switch_camera: "Wissel camera",
        album_my_content: "Mijn inhoud",
        album_price_list: "Prijslijst â†—",
        album_photo_count: "Je hebt {count} foto's gevonden",
        cart_title: "ðŸ›’ Winkelwagen",
        cart_empty: "Winkelwagen is leeg",
        cart_total: "Totaal:",
        cart_checkout: "ðŸ’³ Afrekenen",
        cart_close: "Sluiten",
        cart_continue_selection: "Verder selecteren",
        cart_clear_all: "ðŸ—‘ï¸ Winkelwagen legen",
        cart_loading: "â³ Laden...",
        cart_go_payment: "ðŸ’³ Ga naar betaling",
        lightbox_download: "ðŸ“¥ Downloaden",
        lightbox_add_to_cart: "Toevoegen aan winkelwagen",
        lightbox_remove_from_cart: "Verwijderen uit winkelwagen",
        lightbox_ios_hint: "ðŸ“± Houd de afbeelding ingedrukt en tik op 'Opslaan in Foto's'",
        lightbox_purchase_hint: "Koop om foto's zonder watermerk te downloaden",
        deal_title: "Gefeliciteerd! Je hebt de maxi-deal ontgrendeld",
        deal_subtitle: "Vanaf de 7e foto betaal je â‚¬1 per stuk",
        deal_continue: "Verder selecteren",
        nudge_selected_all: "Je hebt alles geselecteerd",
        nudge_go_checkout: "Ga naar afrekenen",
        nudge_deal_unlocked: "Vanaf de 7e foto betaal je â‚¬1 per stuk",
        nudge_add_more: "Voeg meer toe of ga naar afrekenen",
        nudge_add_one: "Voeg 1 foto toe: je betaalt slechts â‚¬{price}",
        nudge_add_many: "Voeg {count} foto's toe: slechts â‚¬{price} per stuk",
        nudge_unlock_package: "Ontgrendel het {count} foto's pakket",
        sticky_take_all: "Neem ze allemaal",
        sticky_unlock_all: "Alles ontgrendelen",
        sticky_found_photos: "{count} foto's gevonden",
        sticky_buy_all_for: "Koop alle voor â‚¬{price}",
        dealpill_top: "Ontgrendel de maxi-deal",
        dealpill_bottom: "Selecteer 6 foto's, vanaf de 7e betaal je â‚¬1 per foto",
        add_family_member: "ðŸ‘¥ Familielid toevoegen",
        added_members: "Toegevoegde leden",
        add_member: "ðŸ‘¥ Lid toevoegen",
        price_list_title: "Prijslijst",
        price_list_subtitle: "Kies het aanbod dat je bevalt",
        photo: "Foto",
        photos: "Foto's",
        single_photo: "Enkele foto",
        double: "Dubbel",
        special_offer: "Speciale aanbieding",
        package: "Pakket",
        complete_package: "Compleet pakket",
        all_photos_best: "Alle foto's tegen de beste prijs",
        discount: "Korting",
        best: "Beste",
        top: "Top",
        price_1_title: "1 foto",
        price_1_desc: "Enkele foto",
        price_3_title: "3 foto's",
        price_3_desc: "Speciale aanbieding",
        badge_discount: "DISCOUNT",
        price_6_title: "6 foto's",
        price_6_desc: "Beste keuze",
        badge_most_chosen: "MOST CHOSEN",
        price_maxi_title: "Maxi-deal",
        price_maxi_desc: "Vanaf de 7e foto â‚¬1 per stuk",
        price_note_maxi: "Maxi-deal: vanaf de 7e foto â‚¬1 per stuk",
        paid_countdown: "Je betaalde foto's verlopen over <strong>{days}</strong> dagen",
        error_download: "Fout bij het downloaden van de foto. Probeer het opnieuw.",
        error_checkout: "Fout bij het afrekenen. Probeer het opnieuw.",
        checkout_loading: "Laden...",
        no_face_detected: "Geen gezicht gedetecteerd in de selfie. Probeer het opnieuw.",
        checking_photos: "Je foto's controleren...",
        continue: "Doorgaan",
        close: "Sluiten",
        next: "Volgende",
        prev: "Vorige"
      }
    };
    
    // Funzione traduzione con sostituzione variabili
    function t(key, vars = {}) {
      const translation = I18N[currentLang]?.[key] || I18N['en'][key] || key;
      let result = translation;
      for(const [k, v] of Object.entries(vars)) {
        result = result.replace(new RegExp(`\\{${k}\\}`, 'g'), v);
      }
      return result;
    }
    
    // Helper traduzione con sostituzione variabili (alias per compatibilitÃ )
    function tr(key, vars = {}) {
      const dict = (I18N && I18N[currentLang]) ? I18N[currentLang] : (I18N && I18N.en ? I18N.en : {});
      const fallback = (I18N && I18N.en) ? I18N.en : {};
      let s = (dict && dict[key]) || (fallback && fallback[key]) || key;
      return String(s).replace(/\{(\w+)\}/g, (_, k) => (vars[k] !== undefined ? vars[k] : `{${k}}`));
    }
    
    // Applica traduzioni a elementi con data-i18n
    function applyTranslations() {
      // Testi normali
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if(key) {
          el.textContent = t(key);
        }
      });
      
      // Placeholder
      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if(key) {
          el.placeholder = t(key);
        }
      });
      
      // HTML (solo se necessario)
      document.querySelectorAll('[data-i18n-html]').forEach(el => {
        const key = el.getAttribute('data-i18n-html');
        if(key) {
          el.innerHTML = t(key);
        }
      });
    }
    
    // Aggiorna testi dinamici generati da JS
    function refreshDynamicTexts() {
      // Nudge bar
      updateNudgeBar();
      
      // Sticky bar (aggiorna anche quando cambia lingua)
      updateStickyAllOffer();
      
      // Cart modal
      updateCartModal();
      
      // Deal pill (aggiorna sia mobile che desktop)
      document.querySelectorAll('.deal-pill-top').forEach(el => {
        el.textContent = t('dealpill_top');
      });
      document.querySelectorAll('.deal-pill-bottom').forEach(el => {
        el.textContent = t('dealpill_bottom');
      });
      
      // Deal modal (celebrativo)
      const dealTitle = document.querySelector('.deal-title');
      const dealSubtitle = document.querySelector('.deal-subtitle');
      if(dealTitle) dealTitle.textContent = t('deal_title');
      if(dealSubtitle) dealSubtitle.textContent = t('deal_subtitle');
      
      // Album photo count
      const photoCountNumber = document.getElementById('photoCountNumber');
      if(photoCountNumber && allPhotos.length > 0) {
        const countEl = photoCountNumber.parentElement;
        if(countEl) countEl.textContent = t('album_photo_count', { count: allPhotos.length });
      }
      
      // Lightbox texts (se aperto)
      updateLightboxTexts();
      
      // Selfie header
      const selfieHeaderText = document.getElementById('selfieHeaderText');
      if(selfieHeaderText) {
        selfieHeaderText.textContent = activeFamilyMode ? t('family_member_selfie') : t('take_your_selfie');
      }
    }
    
    // Aggiorna testi lightbox
    function updateLightboxTexts() {
      const downloadBtn = document.getElementById('lightboxDownload');
      const iosInstruction = document.getElementById('lightboxIOSInstruction');
      const addCartBtn = document.getElementById('lightboxAddCartBtn');
      
      if(downloadBtn && downloadBtn.style.display !== 'none') {
        downloadBtn.textContent = t('lightbox_download');
      }
      if(iosInstruction && iosInstruction.style.display !== 'none') {
        iosInstruction.textContent = t('lightbox_ios_hint');
      }
      if(addCartBtn) {
        const isInCart = cartPhotoIds.includes(currentPhotoIndex >= 0 && allPhotos[currentPhotoIndex] ? allPhotos[currentPhotoIndex].photo_id : '');
        addCartBtn.textContent = isInCart ? t('lightbox_remove_from_cart') : t('lightbox_add_to_cart');
      }
    }
    
    // Imposta lingua e applica traduzioni
    function setLanguage(lang) {
      currentLang = lang;
      selectedLanguage = lang;
      // Salva in localStorage per persistenza (usato anche dalla success page)
      localStorage.setItem('selectedLanguage', lang);
      applyTranslations();
      refreshDynamicTexts();
    }
    
    // Nomi lingue per feedback
    const langNames = {
      en: 'English',
      es: 'EspaÃ±ol',
      it: 'Italiano',
      fr: 'FranÃ§ais',
      de: 'Deutsch'
    };

    // BLOCCA qualsiasi "auto-search" senza selfie
    // NON chiamare /match_selfie in automatico all'avvio della pagina
    function startPhotosSearchInBackground(){
      // GUARD: NON partire se non c'Ã¨ capturedBlob
      if(!capturedBlob) {
        console.warn('[PHOTOS_SEARCH] BLOCKED: capturedBlob is null - cannot start search without selfie');
        updateMinimalDebug('BLOCKED', 0, '-', undefined, 'no selfie');
        return Promise.resolve(false);
      }
      
      if(photosSearchPromise) return photosSearchPromise;

      photosReady = false;
      photosFailed = false;

      // IMPORTANT: qui richiamiamo la stessa logica che prima partiva al click di Confirm
      // senza mostrare overlay di loading.
      photosSearchPromise = (async () => {
        try {
          await matchAndLoadPhotosAfterSelfie();
          photosReady = true;
          return true;
        } catch (e) {
          console.warn('[PHOTOS_SEARCH] failed', e);
          photosFailed = true;
          return false;
        }
      })();

      return photosSearchPromise;
    }

    // Dopo scelta lingua: mostra loading SOLO se serve e poi vai in album
    async function proceedAfterLanguageSelection(){
      const langLoading = document.getElementById('langLoading');
      const langErrorBox = document.getElementById('langErrorBox');
      if(langErrorBox) langErrorBox.style.display = 'none';

      // BLOCCA: NON partire ricerca automatica senza selfie
      // Se la ricerca non e' mai partita E c'Ã¨ capturedBlob, la facciamo partire ora.
      if(!photosSearchPromise && capturedBlob) {
        startPhotosSearchInBackground();
      } else if(!capturedBlob) {
        console.warn('[LANGUAGE] Cannot start search: no selfie captured');
        updateMinimalDebug('BLOCKED', 0, '-', undefined, 'no selfie');
      }

      // Se gia' pronta, non mostriamo nessun loading
      if(photosReady) {
        if(langLoading) langLoading.style.display = 'none';
        goToAlbumScreen();
        return;
      }

      // Altrimenti: loading overlay dopo scelta lingua
      if(langLoading) {
        langLoading.style.display = 'flex';
      }

      const ok = await photosSearchPromise;

      if(langLoading) {
        langLoading.style.display = 'none';
      }

      if(ok && !photosFailed) {
        goToAlbumScreen();
      } else {
        if(langErrorBox) langErrorBox.style.display = 'block';
      }
    }

    // Variabili globali
    let currentScreen = 'email';
    let stream = null;
    // Usa anche window._cameraStream per compatibilitÃ 
    if(typeof window._cameraStream === 'undefined') {
      window._cameraStream = null;
    }
    
    // Stato globale camera (robusto)
    let cameraStream = null;
    let cameraReady = false;
    let cameraStarting = false;
    let useFront = true;
    let capturedBlob = null;
    // Stateless mode: genera session_id ogni volta (non persistente)
    let sessionId = "session_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
    let currentCart = { photo_ids: [], count: 0, price_euros: 0 };
    let allPhotos = [];
    let currentPhotoIndex = 0;
    let paidPhotos = []; // Array di photo_id pagate
    let selfieCompleted = false; // Flag per tracciare se il selfie Ã¨ stato completato
    let photosLoaded = false; // Flag per tracciare se le foto sono state caricate

    // ========== MATCH & LOAD PHOTOS AFTER SELFIE ==========
    // Sposta la logica di ricerca foto (chiamata /match_selfie, riempie allPhotos ecc.) qui
    async function matchAndLoadPhotosAfterSelfie(){
      // move here the exact code that was previously executed on Confirm
      // that calls match_selfie (or similar) and fills allPhotos / prepares album.
      // Do NOT show any loading UI here.
      // --- BEGIN MOVED LOGIC ---
      // Ricerca foto backend dopo selfie
      // (Questa funzione deve essere popolata con la logica esistente, qui solo esempio)
      // Esempio:
      // const response = await fetch('/match_selfie', { ... });
      // allPhotos = response.photos || [];
      // photosLoaded = true;
      // (Assicurati che allPhotos venga popolato come prima)
      // --- END MOVED LOGIC ---
      // (Sostituisci questa funzione con la tua logica reale)
      // Qui solo placeholder:
      if(typeof _matchAndLoadPhotosAfterSelfieImpl === 'function') {
        // Per test: consenti override
        await _matchAndLoadPhotosAfterSelfieImpl();
      }
    }
    
    // Carrello solo in memoria - SEMPRE VUOTO ad ogni refresh (non persistente)
    let cartPhotoIds = []; // Array in memoria, si svuota automaticamente ad ogni refresh
    
    // ========== EVENT HANDLERS ==========

    // Conferma selfie: mostra subito la schermata lingua e avvia ricerca foto in background
    document.getElementById('confirmBtn').addEventListener('click', async () => {
      try {
        // Se stiamo aggiungendo un membro, salta la lingua e vai direttamente al match
        if(isAddingFamilyMember) {
          // Avvia ricerca foto in background (usa currentLang giÃ  selezionata)
          startPhotosSearchInBackground();
          
          // Aspetta che matchPhotos finisca
          if(photosSearchPromise) {
            await photosSearchPromise;
          }
          
          // Gestisci il risultato dopo che matchPhotos Ã¨ completato
          if(photosReady && allPhotos.length > 0) {
            const confirmPreview = document.getElementById('confirmPreview');
            if(confirmPreview && confirmPreview.src) {
              // Trova le foto nuove aggiunte (quelle che erano in newPhotos prima del merge)
              const beforeCount = albumPhotosAll.length - allPhotos.length;
              const newPhotosForMember = allPhotos.slice(beforeCount < 0 ? 0 : beforeCount);
              
              // Crea nuovo membro e aggiungilo (NON sovrascrivere members[0])
              const memberPhotos = newPhotosForMember.map(p => p.photo_id || p.id || p.url || p.filename).filter(Boolean);
              const newMember = {
                id: 'member_' + Date.now(),
                avatarDataUrl: confirmPreview.src,
                timestamp: Date.now(),
                photoKeys: memberPhotos
              };
              members.push(newMember);
              
              // Aggiorna anche familyMembers per compatibilitÃ 
              const memberAvatar = {
                id: newMember.id,
                avatar: confirmPreview.src,
                timestamp: newMember.timestamp,
                photos: memberPhotos
              };
              familyMembers.push(memberAvatar);
              
              // Ricostruisci album da tutti i membri
              rebuildAlbumFromMembers();
              
              // Aggiorna barra membri
              renderMemberChips();
            }
            
            // Reset flag
            isAddingFamilyMember = false;
            activeFamilyMode = false;
            
            // Aggiorna header
            const headerText = document.getElementById('selfieHeaderText');
            if(headerText) headerText.textContent = t('take_your_selfie');
            
            // Mostra album con foto merge
            showScreen('album');
            await displayPhotos();
            updateCart();
            if(allPhotos.length > 0) {
              showStickyOfferBar();
            }
          } else {
            // Errore: nessuna foto trovata
            alert('No photos found. Please try again.');
            isAddingFamilyMember = false;
            activeFamilyMode = false;
            const headerText = document.getElementById('selfieHeaderText');
            if(headerText) headerText.textContent = t('take_your_selfie');
          }
          return;
        }
        
        // Flow normale per il primo selfie: vai alla lingua
        // Vai subito alla lingua (piu' logico per l'utente)
        showScreen('language');

        // BLOCCA: NON avviare ricerca automatica - aspetta che l'utente selezioni lingua
        // La ricerca partirÃ  solo quando l'utente seleziona la lingua (se capturedBlob esiste)
        // startPhotosSearchInBackground(); // DISATTIVATO - parte solo dopo selezione lingua

        // Se l'utente aveva gia' scelto una lingua in questa sessione, non chiedere di nuovo
        if(selectedLanguage){
          setLanguage(selectedLanguage);
          proceedAfterLanguageSelection();
        }
      } catch (e) {
        console.warn('[CONFIRM] error', e);
        // fallback: mostra errore selfie classico (se gia' esiste nel codice)
        const selfieErrorBox = document.getElementById('selfieErrorBox');
        if(selfieErrorBox) selfieErrorBox.style.display = 'flex';
      }
    });

    // Lingua scelta: aggiungi proceedAfterLanguageSelection dopo setLanguage
    document.querySelectorAll('.language-option').forEach(btn => {
      btn.addEventListener('click', function() {
        const lang = this.getAttribute('data-lang');
        setLanguage(lang);
        // Mostra feedback selezione (giÃ  esistente)
        const feedback = document.getElementById('langFeedback');
        const feedbackText = document.getElementById('langFeedbackText');
        if(feedback && feedbackText){
          feedback.style.display = 'block';
          feedbackText.textContent = t('language_selected', { langName: langNames[lang] || lang });
        }
        // Avvia flusso dopo selezione lingua
        proceedAfterLanguageSelection();
      });
    });


    // ========== NAVIGATION HELPERS ==========
    // showScreen: mostra la schermata richiesta
    function showScreen(name){
      document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
      // id convenzione: #languageScreen, #albumScreen, ecc.
      const el = document.getElementById(name + 'Screen');
      if(el) el.classList.add('active');
      currentScreen = name;
    }

    // goToAlbumScreen: nascondi lingua, mostra album, renderizza album se serve
    async function goToAlbumScreen(){
      showScreen('album');
      // Chiama displayPhotos per renderizzare la griglia
      if(typeof displayPhotos === 'function'){
        await displayPhotos();
        updateCart();
        if(allPhotos.length > 0) {
          showStickyOfferBar();
        }
      }
      // Chiama funzione di render album se esiste (retrocompatibilitÃ )
      if(typeof renderAlbum === 'function'){
        renderAlbum();
      }
    }

    // Inizializza sempre carrello vuoto
    function initCart() {
      cartPhotoIds = [];
      currentCart = { photo_ids: [], count: 0, price_euros: 0 };
      // Aggiorna UI solo se gli elementi DOM esistono (evita errori all'avvio)
      try {
        if (document.readyState === 'loading') {
          // DOM non ancora caricato, aggiorna dopo
          return;
        }
        updateCart();
        updateCartModal();
      } catch(e) {
        console.warn('initCart: DOM not ready yet, skipping UI update');
      }
    }
    
    function loadCart() {
      // Sempre ritorna array vuoto - carrello non persistente
      return [];
    }
    
    function saveCart(ids) {
      // Aggiorna solo la variabile in memoria, NON salva nulla
      cartPhotoIds = ids || [];
    }
    
    function addToCartLocal(photoId) {
      // Aggiungi solo in memoria (si perde ad ogni refresh)
      if (!cartPhotoIds.includes(photoId)) {
        cartPhotoIds.push(photoId);
      }
      return [...cartPhotoIds];
    }
    
    function removeFromCartLocal(photoId) {
      // Rimuovi solo dalla memoria
      cartPhotoIds = cartPhotoIds.filter(id => id !== photoId);
      return [...cartPhotoIds];
    }
    
    function syncCart() {
      // Sincronizza carrello in memoria con currentCart
      const photoIds = cartPhotoIds;
      const count = photoIds.length;
      const priceEuros = computePrice(count);
      currentCart = {
        photo_ids: photoIds,
        count: count,
        price_cents: Math.round(priceEuros * 100),
        price_euros: priceEuros
      };
      updateCart();
      updateCartModal();
      updateNudgeBar(); // Aggiorna nudge bar quando carrello cambia
      
      // Trigger modal celebrativo: transizione 5 -> 6 (una volta sola)
      const newCount = currentCart.count;
      const totalAvailable = (allPhotos && allPhotos.length) ? allPhotos.length : 0;
      const hasMoreThanSix = totalAvailable > 6;
      
      if(!dealUnlockedShown && hasMoreThanSix && prevCartCountForDeal === 5 && newCount === 6){
        dealUnlockedShown = true;
        openDealModal();
      }
      prevCartCountForDeal = newCount;
    }
    
    // Funzioni per modal celebrativo "Deal Unlocked"
    function openDealModal(){
      const modal = document.getElementById('dealModal');
      if(!modal) return;
      modal.classList.add('show');
      // Assicura che sia visibile e interattivo
      modal.style.display = 'block';
      modal.style.pointerEvents = 'auto';
    }

    function closeDealModal(){
      const modal = document.getElementById('dealModal');
      if(!modal) return;

      // Chiudi davvero (1 sola sorgente di veritÃ )
      modal.classList.remove('show');
      modal.style.display = 'none';
      modal.style.pointerEvents = 'none';
      modal.style.visibility = 'hidden';

      // Ripristina eventuali modifiche a backdrop/card
      const backdrop = modal.querySelector('.deal-modal-backdrop');
      const card = modal.querySelector('.deal-modal-card');
      if(backdrop){
        backdrop.style.display = '';
        backdrop.style.pointerEvents = '';
      }
      if(card){
        card.style.pointerEvents = '';
      }

      // Sblocca scroll/tap del body
      document.body.style.overflow = '';
    }

    // Bind robusto (cosÃ¬ il bottone chiude SEMPRE anche se il binding non parte)
    (function bindDealContinue(){
      document.addEventListener('click', (e) => {
        const t = e.target;
        if(t && t.id === 'dealContinueBtn'){
          e.preventDefault();
          e.stopPropagation();
          closeDealModal();
        }
      }, true);
    })();
    
    // NON chiamare initCart() qui - viene chiamato in bootApp() quando il DOM Ã¨ pronto
    let fromStripeSuccess = false; // Flag per tracciare se arrivo da Stripe success
    let dealUnlockedShown = false; // Flag per modal celebrativo (una volta sola)
    let prevCartCountForDeal = 0; // Contatore precedente per rilevare transizione 5 -> 6

    // Elementi DOM
    const welcomeScreen = document.getElementById("welcomeScreen");
    const selfieScreen = document.getElementById("selfieScreen");
    const confirmScreen = document.getElementById("confirmScreen");
    const addPeopleScreen = document.getElementById("addPeopleScreen");
    const albumScreen = document.getElementById("albumScreen");
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const confirmPreview = document.getElementById("confirmPreview");
    const mainPersonAvatar = document.getElementById("mainPersonAvatar");
    const albumGrid = document.getElementById("albumGrid");
    const albumCartBtn = document.getElementById("albumCartBtn");
    const albumCartCount = document.getElementById("albumCartCount");
    const albumCartPrice = document.getElementById("albumCartPrice");
    // buyAllBtn rimosso - ora si usa solo il banner sticky
    const buyAllPrice = document.getElementById("buyAllPrice"); // Mantenuto per compatibilitÃ  se usato altrove
    const photoLightbox = document.getElementById("photoLightbox");
    const lightboxImage = photoLightbox ? photoLightbox.querySelector("img") : null;
    const photoCounter = document.getElementById("photoCounter");

    // Funzioni screen management
    function showScreen(screenName) {
      console.log('showScreen called with:', screenName);
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      const screen = document.getElementById(screenName + 'Screen');
      console.log('Screen element found:', screen ? 'YES' : 'NO', 'ID:', screenName + 'Screen');
      if(screen) {
        screen.classList.add('active');
        console.log('Screen activated:', screenName);
      } else {
        console.error('Screen not found:', screenName + 'Screen');
      }
      currentScreen = screenName;
      
      // Gestione stickyOfferBar e nudgeBar: visibili SOLO quando albumScreen Ã¨ attivo
      const stickyOfferBar = document.getElementById('stickyOfferBar');
      const nudgeBar = document.getElementById('nudgeBar');
      
      if(stickyOfferBar) {
        if(screenName !== 'album') {
          stickyOfferBar.classList.remove('active');
          stickyOfferBar.style.display = 'none';
        }
        // Se Ã¨ album, verrÃ  mostrato dopo che le foto sono renderizzate
      }
      
      if(nudgeBar) {
        if(screenName !== 'album') {
          nudgeBar.classList.remove('active');
          nudgeBar.style.display = 'none';
        }
        // Se Ã¨ album, verrÃ  mostrato dopo che le foto sono renderizzate
      }
      
      // Aggiorna padding quando si cambia schermata
      if(screenName === 'album') {
        setTimeout(() => {
          updateStickyAllOffer(); // Aggiorna sticky bar quando si mostra l'album
          updateNudgeBar();
          updateBottomPadding();
        }, 100);
      } else {
        updateBottomPadding();
      }
      
      // Gestione selfieErrorBox: nascondi quando non siamo in selfieScreen
      const selfieErrorBox = document.getElementById('selfieErrorBox');
      if(selfieErrorBox) {
        if(screenName !== 'selfie') {
          selfieErrorBox.style.display = 'none';
        }
      }
      
      // Aggiorna header selfie in base a activeFamilyMode
      if(screenName === 'selfie') {
        const headerText = document.getElementById('selfieHeaderText');
        if(headerText) {
          headerText.textContent = activeFamilyMode ? 'Family member selfie' : 'Take your selfie';
        }
        // Mostra/nascondi prompt start camera
        const startCameraPrompt = document.getElementById('startCameraPrompt');
        const video = document.getElementById('video');
        if(startCameraPrompt && video) {
          if(cameraReady || cameraStarting) {
            startCameraPrompt.style.display = 'none';
            if(video.srcObject && video.videoWidth > 0) {
              video.style.display = 'block';
            }
        } else {
            startCameraPrompt.style.display = 'flex';
            video.style.display = 'none';
          }
        }
      } else if(screenName === 'album') {
        // Carica membri quando si entra nell'album
        if(userEmail) {
          loadFamilyMembersOnce();
        }
        // Stop camera quando esci dalla selfie screen
        stopCamera();
      } else if(screenName === 'confirm') {
        // Stop camera quando vai a confirm screen
        stopCamera();
      } else if(screenName !== 'selfie') {
        // Stop camera quando esci dalla selfie screen (qualsiasi altro screen)
        stopCamera();
      }
    }

    // Variabile globale per email utente (stateless: non persistente)
    let userEmail = null;
    let familyMembers = []; // Lista membri famiglia (stateless: sempre vuoto)
    let activeFamilyMode = false; // ModalitÃ  aggiunta membro famiglia (disabilitata)
    let isAddingFamilyMember = false; // Flag per aggiunta membro senza email
    let albumPhotosAll = []; // Array completo di tutte le foto (merge di tutti i selfie)
    let members = []; // Array di membri: members[0] Ã¨ il main member, gli altri sono aggiunti
    
    // Funzione per merge unico di foto (evita duplicati)
    function mergeUnique(existingPhotos, newPhotos) {
      const existingIds = new Set(existingPhotos.map(p => p.photo_id || p.photoId || p.r2_key));
      const merged = [...existingPhotos];
      
      newPhotos.forEach(newPhoto => {
        const newId = newPhoto.photo_id || newPhoto.photoId || newPhoto.r2_key;
        if(newId && !existingIds.has(newId)) {
          merged.push(newPhoto);
          existingIds.add(newId);
        }
      });
      
      return merged;
    }
    
    // ========== INIZIALIZZAZIONE SEMPLIFICATA ==========
    // Separazione netta tra flusso base e flusso post-pagamento
    
    // Funzione helper per verificare parametri Stripe success
    function hasStripeSuccessParams() {
      const p = new URLSearchParams(window.location.search);
      const success = p.get('success');
      const sessionId = p.get('session_id');
      const token = p.get('download_token');
      return success === '1' && (!!sessionId || !!token);
    }
    
    // Flag globale per bloccare flusso normale durante post-pagamento
    let IS_STRIPE_SUCCESS_FLOW = false;
    
    // Funzione per tornare al flusso normale (welcome/selfie)
    function goToNormalFlowStart() {
      console.log('[StripeSuccess] Returning to normal flow (welcome screen)');
      IS_STRIPE_SUCCESS_FLOW = false; // Reset flag
      showScreen('welcome');
    }
    
    // Bootstrap app: mostra sempre welcome/selfie screen (stateless)
    async function bootApp() {
      console.log('bootApp() called (stateless mode)');
      
      // Applica traduzioni iniziali (default: inglese per welcome screen)
      applyTranslations();
      
      // Carrello sempre vuoto all'inizio (si svuota ad ogni refresh)
      initCart();
      
      // TODO: DISATTIVATO TEMPORANEAMENTE - riattivare dopo fix flusso selfie->galleria
      // 0. PERSISTENZA: Se esiste purchase_token in localStorage, verifica prima di redirectare
      /*
      const purchaseToken = localStorage.getItem('purchase_token');
      if (purchaseToken && !hasStripeSuccessParams()) {
        console.log('[BOOTAPP] Found purchase_token in localStorage, verifying...');
        try {
          // Ping leggero per verificare se il token Ã¨ valido
          const verifyRes = await fetch(`/api/checkout/status?purchase_token=${encodeURIComponent(purchaseToken)}`);
          if (verifyRes.ok) {
            const verifyData = await verifyRes.json();
            if (verifyData.ok && verifyData.purchased_photo_ids && verifyData.purchased_photo_ids.length > 0) {
              // Token valido: redirect a success page
              console.log('[BOOTAPP] Token valido, redirecting to success page...');
              const successUrl = `/checkout/success?purchase_token=${encodeURIComponent(purchaseToken)}`;
              window.location.replace(successUrl);
              return; // Esci subito, non continuare il flusso
            } else {
              // Token invalido: cancella e resta in home
              console.log('[BOOTAPP] Token invalido, cancelling...');
              localStorage.removeItem('purchase_token');
            }
          } else {
            // Errore: cancella token e resta in home
            console.log('[BOOTAPP] Errore verifica token, cancelling...');
            localStorage.removeItem('purchase_token');
          }
        } catch (e) {
          // Errore: cancella token e resta in home
          console.error('[BOOTAPP] Errore verifica token:', e);
          localStorage.removeItem('purchase_token');
        }
      }
      */
      
      // 1. Controlla se Ã¨ ritorno dopo pagamento Stripe (success=1 e session_id)
      // REDIRECT AUTOMATICO alla pagina success dedicata
      if (hasStripeSuccessParams()) {
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('session_id');
        const token = urlParams.get('download_token');
        const sid = sessionId || token;
        
        if (sid) {
          // Reindirizza automaticamente alla pagina success dedicata
          console.log('[StripeSuccess] Redirecting to dedicated success page...');
          const successUrl = `/checkout/success?session_id=${encodeURIComponent(sid)}`;
          window.location.replace(successUrl);
          return; // Esci subito, non continuare il flusso
        }
      }
      
      // 2. Se ci sono remaining_photo_ids in sessionStorage, selezionale automaticamente
      const remainingPhotoIdsStr = sessionStorage.getItem('remaining_photo_ids');
      if (remainingPhotoIdsStr) {
        try {
          const remainingPhotoIds = JSON.parse(remainingPhotoIdsStr);
          console.log('[BOOTAPP] Found remaining_photo_ids in sessionStorage:', remainingPhotoIds.length);
          // Salva in variabile globale per uso futuro (quando le foto vengono caricate)
          window.remainingPhotoIds = remainingPhotoIds;
          // Rimuovi da sessionStorage dopo averlo letto
          sessionStorage.removeItem('remaining_photo_ids');
        } catch (e) {
          console.warn('[BOOTAPP] Error parsing remaining_photo_ids:', e);
        }
      }
      
      // 3. Mostra sempre schermata welcome (poi selfie)
      console.log('Mostrando schermata welcome');
      try {
        showScreen('welcome');
        console.log('Schermata welcome mostrata correttamente');
      } catch(e) {
        console.error('Errore mostrando schermata welcome:', e);
        // Fallback: mostra welcome direttamente
        const welcomeEl = document.getElementById('welcomeScreen');
        if(welcomeEl) {
          document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
          welcomeEl.classList.add('active');
          console.log('Schermata welcome mostrata con fallback');
        }
      }
    }
    
    // Funzione separata per caricare album dopo pagamento (stateless: usa session_id)
    async function loadAlbumAfterPayment(sessionId) {
      console.log('[StripeSuccess] loadAlbumAfterPayment called with sessionId:', sessionId);
      
      // Stateless mode: usa session_id per recuperare foto pagate da Stripe
      if (!sessionId) {
        console.error('[StripeSuccess] No session_id provided');
        IS_STRIPE_SUCCESS_FLOW = false; // Reset flag se errore
        goToNormalFlowStart();
        return;
      }
      
      // Controlla se questo session_id Ã¨ giÃ  stato "consumato" (anti-refresh)
      const consumedKey = "stripe_consumed_" + sessionId;
      if (sessionStorage.getItem(consumedKey) === "1") {
        console.log('[StripeSuccess] Session ID already consumed, going to normal flow');
        goToNormalFlowStart();
        return;
      }
      
      try {
        console.log('[StripeSuccess] Fetching /stripe/verify...');
        const res = await fetch(`/stripe/verify?session_id=${encodeURIComponent(sessionId)}`);
        
        if (!res.ok) {
          console.error('[StripeSuccess] /stripe/verify failed:', res.status, res.statusText);
          IS_STRIPE_SUCCESS_FLOW = false; // Reset flag se errore
          goToNormalFlowStart();
          return;
        }
        
        const data = await res.json();
        console.log('[StripeSuccess] /stripe/verify response:', data);
        
        if(data.ok && data.photo_ids && data.photo_ids.length > 0) {
          console.log('[StripeSuccess] Found', data.photo_ids.length, 'paid photos');
          
          allPhotos = [];
          paidPhotos = data.photo_ids;
          userEmail = data.customer_email || null;
          
          // Prepara foto pagate da mostrare con URL corretti per download senza watermark
          const photosToShow = data.photo_ids.map(photoId => {
            // Costruisci URL per foto pagate (senza watermark) - VELOCITÃ€ MASSIMA: usa originale R2
            const paidUrl = userEmail 
              ? `/photo/${encodeURIComponent(photoId)}?paid=true&email=${encodeURIComponent(userEmail)}`
              : `/photo/${encodeURIComponent(photoId)}?paid=true`;
            const thumbUrl = `/photo/${encodeURIComponent(photoId)}?variant=thumb`;
            const wmUrl = `/photo/${encodeURIComponent(photoId)}?variant=wm`;
            
            return {
              photo_id: photoId,
              score: 0,
              has_face: true,
              paid: true,
              paid_url: paidUrl,  // URL per foto originale senza watermark (VELOCITÃ€ MASSIMA)
              thumb_url: thumbUrl, // URL per thumbnail (pre-generato, veloce)
              wm_url: wmUrl        // URL per preview con watermark (pre-generato, veloce)
            };
          });
            
          allPhotos = photosToShow;
          
          console.log('[StripeSuccess] Showing album with', allPhotos.length, 'paid photos');
          showScreen('album');
          await displayPhotos();
          
          // Non mostrare sticky bar per foto pagate (sono giÃ  tutte pagate)
          const stickyBar = document.getElementById('stickyOfferBar');
          if(stickyBar) {
            stickyBar.style.display = 'none';
          }
          
          // IMPORTANTE: marca questo session_id come "consumato" (anti-refresh)
          sessionStorage.setItem(consumedKey, "1");
          console.log('[StripeSuccess] Marked session_id as consumed in sessionStorage');
          
          // IMPORTANTE: pulisci URL immediatamente (cosÃ¬ refresh non rilancia il success flow)
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, "", cleanUrl);
          console.log('[StripeSuccess] Cleaned URL, removed success params');
          
          console.log('[StripeSuccess] Post-payment page displayed successfully');
          // Mantieni IS_STRIPE_SUCCESS_FLOW = true per bloccare altri flussi
        } else {
          console.error('[StripeSuccess] No photos found in Stripe session');
          IS_STRIPE_SUCCESS_FLOW = false; // Reset flag se errore
          goToNormalFlowStart();
        }
      } catch(e) {
        console.error('[StripeSuccess] Error loading album after payment:', e);
        IS_STRIPE_SUCCESS_FLOW = false; // Reset flag se errore
        goToNormalFlowStart();
      }
    }
    
    // Setup bottone "Rifai selfie" (una volta sola)
    function setupRetakeSelfieButton() {
        const retakeSelfieBtn = document.getElementById('retakeSelfieBtn');
        if(retakeSelfieBtn) {
          retakeSelfieBtn.addEventListener('click', function() {
            resetSelfieState();
          });
        }
    }
    
    // Avvia bootstrap quando DOM Ã¨ pronto
    function initializeApp() {
      console.log('Script loaded, document.readyState:', document.readyState);
      
      if(document.readyState === 'loading') {
        console.log('Waiting for DOMContentLoaded...');
        document.addEventListener('DOMContentLoaded', () => {
          console.log('DOMContentLoaded fired');
          setupRetakeSelfieButton();
          try {
            bootApp();
        } catch(e) {
            console.error('Error in bootApp():', e);
          // Fallback: mostra sempre la schermata welcome in caso di errore
          showScreen('welcome');
        }
      });
    } else {
        console.log('DOM already ready, calling bootApp() immediately');
        setupRetakeSelfieButton();
      try {
          bootApp();
      } catch(e) {
          console.error('Error in bootApp():', e);
        // Fallback: mostra sempre la schermata email in caso di errore
        showScreen('email');
      }
    }
    }
    
    // Avvia inizializzazione
    initializeApp();
    
    // Event listener per email screen
    const emailInput = document.getElementById('emailInput');
    const emailError = document.getElementById('emailError');
    const emailContinueBtn = document.getElementById('emailContinueBtn');
    
    // Funzione per controllare lo stato dell'utente (disabilitata in stateless mode)
    async function checkUserState(email, forceAlbum = false) {
      // Stateless: non controllare stato utente, sempre ritorna "no photos"
      console.log('checkUserState called (stateless: always returns no photos)');
      return { hasPaid: false, hasFound: false };
      
      // Codice vecchio disabilitato (stateless mode):
      if(false) {
      try {
        // 1. Salva l'utente solo con email
        try {
          await fetch(`/user/register?email=${encodeURIComponent(email)}`, {
            method: 'POST'
          });
          console.log('User registered/updated with email:', email);
        } catch(e) {
          console.error('Error registering user:', e);
          // Continua comunque
        }
        
        // 2. Controlla foto dell'utente
        const res = await fetch(`/user/photos?email=${encodeURIComponent(email)}`);
        const data = await res.json();
        
        console.log('checkUserState - API response:', data);
        console.log('checkUserState - paid_photos:', data.paid_photos);
        console.log('checkUserState - found_photos:', data.found_photos);
        console.log('checkUserState - forceAlbum:', forceAlbum);
        
        if(!data.ok) {
          console.log('checkUserState - API returned !ok');
          return { hasPaid: false, hasFound: false }; // Nessuna foto
        }
        
        const hasPaid = data.paid_photos && data.paid_photos.length > 0;
        const hasFound = data.found_photos && data.found_photos.length > 0;
        
        // Controlla anche se ci sono foto trovate con status='paid'
        const hasPaidInFound = data.found_photos && data.found_photos.some(p => p.status === 'paid');
        const hasAnyPaid = hasPaid || hasPaidInFound;
        
        // PULISCI CARRELLO: Se ha foto pagate, rimuovi tutte le foto dal carrello
        // (potrebbero essere rimaste da una sessione precedente)
        if(hasAnyPaid) {
          // Carrello sempre vuoto all'inizio - non persiste tra sessioni
          cartPhotoIds = [];
          syncCart();
        }
        
        // 3. Se ha foto trovate â†’ mostra album (SEMPRE, anche se ha foto pagate)
        // Le foto pagate vengono mostrate nella griglia con badge "paid" e sono scaricabili
        if(hasFound) {
          userEmail = email;
          // Stateless: non salvare email
          
          // Mostra TUTTE le foto trovate (pagate e non pagate) nella griglia
          // Le foto pagate avranno badge "paid" e saranno scaricabili
          let photosToShow = data.found_photos.map(p => ({
              photo_id: p.photo_id,
              score: 0,
              has_face: true,
              paid: p.status === 'paid'
            }));
          
          // Aggiungi anche le foto pagate che non sono in found_photos
          if(data.paid_photos && data.paid_photos.length > 0) {
            const foundPhotoIds = new Set(photosToShow.map(p => p.photo_id));
            data.paid_photos.forEach(photoId => {
              if(!foundPhotoIds.has(photoId)) {
                photosToShow.push({
                  photo_id: photoId,
              score: 0,
              has_face: true,
                  paid: true
                });
              }
            });
          }
          
          console.log(`Showing ${photosToShow.length} photos in album (${photosToShow.filter(p => p.paid).length} paid, ${photosToShow.filter(p => !p.paid).length} unpaid)`);
          
          if(photosToShow.length > 0) {
            allPhotos = photosToShow;
            
            // Mostra album
            showScreen('album');
            await displayPhotos();
            loadFamilyMembersOnce(); // Carica membri famiglia
            
            // Mostra sticky bar solo con conteggio foto NON pagate
            const unpaidCount = photosToShow.filter(p => !p.paid).length;
            if(unpaidCount > 0) {
              showStickyOfferBar(unpaidCount);
            } else {
              // Nascondi sticky bar se tutte le foto sono pagate
              const stickyBar = document.getElementById('stickyOfferBar');
              if(stickyBar) {
                stickyBar.style.display = 'none';
              }
            }
            
            return { hasPaid: hasAnyPaid, hasFound: true, shown: true };
          } else {
            // Nessuna foto trovata (tutte pagate o nessuna foto)
            // Se forceAlbum=true, mostra messaggio nell'album invece del selfie
            if(forceAlbum) {
              console.log('No unpaid photos found, showing message in album');
              userEmail = email;
              // Stateless: non salvare email
              
              // Mostra album con messaggio
              showScreen('album');
              
              // Pulisci griglia e mostra messaggio
              const albumGrid = document.getElementById('albumGrid');
              if(albumGrid) {
                albumGrid.innerHTML = '';
                
                // Crea messaggio
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 60px 20px; background: rgba(255, 255, 255, 0.05); border-radius: 16px; margin: 40px 0;';
                
                const icon = document.createElement('div');
                icon.textContent = 'âœ…';
                icon.style.cssText = 'font-size: 64px; margin-bottom: 20px;';
                
                const title = document.createElement('h2');
                title.textContent = 'You\'ve purchased all available photos!';
                title.style.cssText = 'color: white; font-size: 24px; font-weight: 700; margin-bottom: 12px;';
                
                const subtitle = document.createElement('p');
                subtitle.textContent = 'There are no more photos available for purchase at the moment.';
                subtitle.style.cssText = 'color: rgba(255, 255, 255, 0.8); font-size: 16px; line-height: 1.6;';
                
                messageDiv.appendChild(icon);
                messageDiv.appendChild(title);
                messageDiv.appendChild(subtitle);
                albumGrid.appendChild(messageDiv);
              }
              
              // Nascondi sticky bar
              const stickyBar = document.getElementById('stickyOfferBar');
              if(stickyBar) {
                stickyBar.style.display = 'none';
              }
              
              return { hasPaid: hasAnyPaid, hasFound: false, shown: true };
            } else {
              // Se ha foto pagate ma non found_photos, mostra album con solo foto pagate
              // NON richiedere selfie se ha foto pagate
              if(hasAnyPaid) {
                // Prepara foto pagate da mostrare
                let paidPhotosToShow = [];
                
                // Aggiungi foto pagate da paid_photos
                if(data.paid_photos && data.paid_photos.length > 0) {
                  paidPhotosToShow = data.paid_photos.map(photoId => ({
                    photo_id: photoId,
                    score: 0,
                    has_face: true,
                    paid: true
                  }));
                }
                
                // Se abbiamo foto pagate da mostrare, mostra la griglia
                if(paidPhotosToShow.length > 0) {
                  console.log('No found photos but has paid photos, showing album with paid photos (no selfie required)');
      userEmail = email;
                  // Stateless: non salvare email
                  
                  allPhotos = paidPhotosToShow;
                  showScreen('album');
                  await displayPhotos();
                  loadFamilyMembersOnce(); // Carica membri famiglia
                  
                  // Nascondi sticky bar (tutte le foto sono pagate)
                  const stickyBar = document.getElementById('stickyOfferBar');
                  if(stickyBar) {
                    stickyBar.style.display = 'none';
                  }
                  
                  return { hasPaid: true, hasFound: false, shown: true };
                }
              }
              
              // Solo se NON ha foto (nÃ© trovate nÃ© pagate) â†’ richiedi selfie
              console.log('No photos found (neither found nor paid), showing selfie');
                showScreen('selfie');
                await startCamera();
                return { hasPaid: false, hasFound: false, shown: false };
            }
          }
        }
        
        // 5. Non ha nulla â†’ flusso normale
        console.log('checkUserState - No photos found, continuing with normal flow');
        return { hasPaid: false, hasFound: false };
      } catch(e) {
        console.error('Error checking user state:', e);
        return { hasPaid: false, hasFound: false };
      }
      } // Fine if(false) - codice vecchio disabilitato
    }
    
    // Stateless: emailContinueBtn disabilitato - non piÃ¹ usato come primo step
    // Se viene ancora chiamato (es. da codice legacy), va direttamente al selfie
    if(emailContinueBtn) {
      emailContinueBtn.addEventListener('click', async () => {
        // Stateless: vai direttamente al selfie senza email o API calls
        console.log('Email Continue clicked (stateless: going to selfie)');
        showScreen('selfie');
        // Camera verrÃ  avviata quando l'utente clicca "Start Camera"
      });
      }
    
    // Funzione per caricare album di test (salta camera)
    async function loadTestAlbum() {
      const email = emailInput.value.trim();
      
      // Validazione email
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if(!email || !emailRegex.test(email)) {
        emailError.classList.add('show');
        emailInput.style.borderColor = '#ff4444';
        return;
      }

      // Salva email
      userEmail = email;
      localStorage.setItem('userEmail', email);
      emailError.classList.remove('show');
      emailInput.style.borderColor = 'rgba(255, 255, 255, 0.1)';
      
      // Mostra loading
      const testBtn = document.getElementById('testAlbumBtn');
      if(testBtn) {
        testBtn.disabled = true;
        testBtn.textContent = 'â³ Caricamento...';
      }
      
      try {
        // Chiama endpoint test-album
        const res = await fetch(`/test-album?email=${encodeURIComponent(email)}`);
        const data = await res.json();
        
        if(data.ok && data.results && data.results.length > 0) {
          console.log(`Test album: trovate ${data.results.length} foto`);
          
          allPhotos = data.results;
          photosLoadedCount = 0;
          
          // Carica anche le foto giÃ  acquistate
          if(userEmail) {
            try {
              const paidRes = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
              const paidData = await paidRes.json();
              
              if(paidData.ok && paidData.paid_photos && paidData.paid_photos.length > 0) {
                paidPhotos = [...paidData.paid_photos];
                console.log(`Caricate ${paidPhotos.length} foto pagate`);
                
                // Marca come pagate le foto nell'album
                allPhotos.forEach(photo => {
                  if(paidData.paid_photos.includes(photo.photo_id)) {
                    photo.paid = true;
                    if(!paidPhotos.includes(photo.photo_id)) {
                      paidPhotos.push(photo.photo_id);
                    }
                  }
                });
              }
            } catch(e) {
              console.error('Errore caricamento foto pagate:', e);
            }
          }
          
          // Mostra album
          showScreen('album');
          await displayPhotos();
          showStickyOfferBar(allPhotos.length);
          applyTranslations();
        } else {
          alert('No photos found for test. Make sure there are photos in the photos folder.');
        }
      } catch(e) {
        console.error('Errore caricamento test album:', e);
        alert('Error loading test album: ' + e.message);
      } finally {
        if(testBtn) {
          testBtn.disabled = false;
          testBtn.textContent = 'ðŸ§ª Test Album (salta camera)';
        }
      }
    }
    
    
    // Enter key su input email
    emailInput.addEventListener('keypress', (e) => {
      if(e.key === 'Enter') {
        emailContinueBtn.click();
      }
    });

    // Event listeners
    // Rimosso pulsante "Continua" - vai direttamente al selfie quando si inserisce email
    // Bottone Continue nella welcome screen: va al selfie e RICHIEDE permesso camera
    const welcomeContinueBtn = document.getElementById("welcomeContinueBtn");
    if(welcomeContinueBtn) {
      welcomeContinueBtn.addEventListener("click", async () => {
        // Stateless: vai direttamente al selfie senza email o check utente
        console.log('Welcome Continue clicked - going to selfie screen and requesting camera');
      showScreen('selfie');
        // QUI e SOLO QUI richiediamo permesso camera
      await startCamera();
      });
    }
    
    // Event listeners per language screen
    document.querySelectorAll('.language-option[data-lang]').forEach(btn => {
      btn.addEventListener('click', () => {
        const lang = btn.getAttribute('data-lang');
        if(!lang) return;
        
        // Imposta lingua
        setLanguage(lang);
        
        // Procedi dopo la selezione della lingua
        proceedAfterLanguageSelection();
      });
    });
    
    // Event listener per "Retake selfie" nella language screen
    const langRetakeSelfieBtn = document.getElementById('langRetakeSelfieBtn');
    if(langRetakeSelfieBtn) {
      langRetakeSelfieBtn.addEventListener('click', () => {
        // Reset promise e stati
        photosSearchPromise = null;
        photosReady = false;
        photosFailed = false;
        
        // NON resettare selectedLanguage (mantiene la scelta)
        resetSelfieState();
        
        // Nascondi error box e loading
        const langErrorBox = document.getElementById('langErrorBox');
        const langLoading = document.getElementById('langLoading');
        if(langErrorBox) {
          langErrorBox.style.display = 'none';
          langErrorBox.style.pointerEvents = 'none';
        }
        if(langLoading) {
          langLoading.style.display = 'none';
          langLoading.style.pointerEvents = 'none';
        }
      });
    }
    
    // RIMOSSO: Auto-avanzamento automatico dopo 2 secondi
    // La camera deve essere avviata SOLO quando l'utente clicca "Continue"

    document.getElementById("captureBtn").addEventListener("click", async () => {
      console.log("captureBtn clicked, cameraReady:", cameraReady);
      // captureSelfie() ha giÃ  il guard interno, ma verifichiamo comunque
      if(!cameraReady) {
        console.warn("Camera not ready, ignoring click");
        return;
      }
      captureSelfie();
    });
    document.getElementById("confirmBtn").addEventListener("click", confirmSelfie);
    document.getElementById("retakeBtn").addEventListener("click", async () => {
      showScreen('selfie');
      await startCamera();
    });
    document.getElementById("retryCameraBtn")?.addEventListener("click", async () => {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked retryCameraBtn click - post-payment flow active');
        return;
      }
      
      const placeholder = document.getElementById('videoPlaceholder');
      const retryCameraBtn = document.getElementById('retryCameraBtn');
      if(placeholder) placeholder.style.display = 'none';
      if(retryCameraBtn) retryCameraBtn.style.display = 'none';
      await startCamera();
    });
    // Bottone "Start Camera" - avvia la camera quando l'utente clicca
    const startCameraBtn = document.getElementById('startCameraBtn');
    if(startCameraBtn) {
      startCameraBtn.addEventListener('click', async () => {
        // Guardia: blocca se siamo in flusso post-pagamento
        if (IS_STRIPE_SUCCESS_FLOW) {
          console.log('[StripeSuccess] Blocked startCameraBtn click - post-payment flow active');
          return;
        }
        
        console.log('[CAM] Start camera button clicked');
        const startCameraPrompt = document.getElementById('startCameraPrompt');
        if(startCameraPrompt) {
          startCameraPrompt.style.display = 'none';
        }
        await startCamera();
      });
    }
    document.getElementById("skipAddPersonBtn").addEventListener("click", async () => {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked skipAddPersonBtn click - post-payment flow active');
        return;
      }
      
      // Se le foto sono giÃ  state caricate, mostra direttamente l'album
      if(allPhotos && allPhotos.length > 0) {
        await displayPhotos();
        updateCart();
        showScreen('album');
      } else {
        matchPhotos();
      }
    });
    document.getElementById("addPersonConfirmBtn").addEventListener("click", async () => {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked addPersonConfirmBtn click - post-payment flow active');
        return;
      }
      
      // Per ora salta, poi implementeremo aggiunta persone
      // Se le foto sono giÃ  state caricate, mostra direttamente l'album
      if(allPhotos && allPhotos.length > 0) {
        await displayPhotos();
        updateCart();
        showScreen('album');
      } else {
        matchPhotos();
      }
    });
    // Pulsante buyAllBtn rimosso - ora si usa solo il banner sticky
    const albumBackBtn = document.getElementById("albumBackBtn");
    if(albumBackBtn) {
      albumBackBtn.addEventListener("click", () => {
        // Controlla se siamo nel tab "Listino prezzi"
        const pricesTab = document.getElementById("pricesTab");
        const pricesList = document.getElementById("pricesList");
        const myContentTab = document.getElementById("myContentTab");
        const albumGrid = document.getElementById("albumGrid");
        
        const isInPricesList = (pricesTab && pricesTab.classList.contains('active')) || 
                               (pricesList && pricesList.classList.contains('active'));
        
        if(isInPricesList) {
          // Se siamo nel listino, torna alla griglia foto invece di uscire dall'album
          if(pricesList) pricesList.classList.remove('active');
          if(albumGrid) albumGrid.style.display = 'grid';
          if(myContentTab) myContentTab.classList.add('active');
          if(pricesTab) pricesTab.classList.remove('active');
          // Mostra sticky e nudge quando si torna alla griglia foto
          showStickyOfferBarIfAllowed();
          showNudgeBarIfAllowed();
          // Richiama le funzioni esistenti per aggiornare UI/checkout/nudge/sticky
          updateStickyAllOffer();
          updateNudgeBar();
          updateBottomPadding();
          return; // Non chiamare showScreen('welcome')
        }
        
        // Comportamento normale: esci dall'album
        showScreen('welcome');
      });
    }
    
    // Sticky offer click: add ALL photos to cart, open cart, then go to checkout if possible
    // Flag per evitare doppio trigger su mobile/iOS (esposto in window per accesso cross-scope)
    window.stickyClickLock = false;
    
    // Funzione robusta per gestire click sticky bar (cross-device)
    // Aggiunge TUTTE le foto non pagate al carrello, poi apre il carrello
    // FIX: Usa addToCartLocal() per aggiungere tutte le foto in batch, poi syncCart() una volta
    function onStickyOfferClick() {
      console.log('[STICKY] onStickyOfferClick called');
      // Previeni doppio trigger
      if(window.stickyClickLock) {
        console.log('[STICKY] Click locked, ignoring');
        return;
      }
      window.stickyClickLock = true;
      setTimeout(() => {
        window.stickyClickLock = false;
      }, 300);
      
      // Aggiungi TUTTE le foto non pagate al carrello in batch (senza chiamare syncCart() per ogni foto)
      if(allPhotos && allPhotos.length > 0) {
        const paidPhotoIdsSet = new Set(paidPhotos);
        let addedCount = 0;
        allPhotos.forEach(photo => {
          const photoId = photo.photo_id || photo.r2_key;
          if(photoId && !paidPhotoIdsSet.has(photoId) && !cartPhotoIds.includes(photoId)) {
            // Usa addToCartLocal() invece di addToCart() per evitare chiamate multiple a syncCart()
            addToCartLocal(photoId);
            addedCount++;
            
            // Aggiorna UI immediatamente per ogni foto
            const btn = document.querySelector(`.add-to-cart-btn[data-photo-id="${photoId}"]`);
            if(btn && !btn.classList.contains('is-added')) {
              btn.classList.add('is-added');
              btn.setAttribute('aria-label', 'Rimuovi dal carrello');
              const card = btn.closest('.album-photo');
              if(card) card.classList.add('selected');
            }
          }
        });
        
        // Sincronizza il carrello UNA SOLA VOLTA dopo aver aggiunto tutte le foto
        if(addedCount > 0) {
          syncCart();
          console.log(`[STICKY] Added ${addedCount} photos to cart`);
        }
      }
      
      // Apri il carrello (dopo che syncCart() ha aggiornato currentCart)
      const cartModal = document.getElementById('cartModal');
      if(cartModal) {
        cartModal.classList.add('active');
        // Assicurati che updateCartModal() venga chiamato per mostrare le foto appena aggiunte
        if(typeof updateCartModal === 'function') {
          updateCartModal();
        }
        updateNudgeBar(); // Nascondi nudge bar quando si apre il carrello
        console.log('[STICKY] Cart modal opened with', currentCart.count, 'photos');
      } else {
        // Fallback: usa il bottone carrello
        const cartBtn = document.getElementById('albumCartBtn');
        if(cartBtn) {
          cartBtn.click();
          console.log('[STICKY] Cart opened via button click');
        }
      }
    }
    
    // Esponi la funzione in window per compatibilitÃ 
    window.onStickyOfferClick = onStickyOfferClick;
    console.log('[STICKY] onStickyOfferClick function defined and exposed to window');
    
    if(albumCartBtn) {
      albumCartBtn.addEventListener("click", () => {
        const cartModal = document.getElementById('cartModal');
        if(cartModal) {
          cartModal.classList.add('active');
          updateCartModal();
          updateNudgeBar(); // Nascondi nudge bar quando si apre il carrello
        }
      });
      
      // Event listener robusto per sticky offer bar (cross-device)
      const stickyOfferBar = document.getElementById('stickyOfferBar');
      if(stickyOfferBar) {
        console.log('[STICKY] Sticky bar found, attaching event listeners');
        // Wrapper function che chiama onStickyOfferClick se disponibile
        const handleStickyClick = (e) => {
          console.log('[STICKY] handleStickyClick triggered', e.type);
          if(typeof window.onStickyOfferClick === 'function') {
            window.onStickyOfferClick();
          } else if(typeof onStickyOfferClick === 'function') {
            onStickyOfferClick();
          } else {
            console.warn('[STICKY] onStickyOfferClick not available');
          }
        };
        
        // Binding click (desktop e mobile)
        stickyOfferBar.addEventListener('click', handleStickyClick, { passive: true });
        console.log('[STICKY] Click listener attached');
        
        // Binding touchend per mobile/iOS (evita doppio trigger con flag)
        let touchStartTime = 0;
        stickyOfferBar.addEventListener('touchstart', (e) => {
          touchStartTime = Date.now();
        }, { passive: true });
        
        stickyOfferBar.addEventListener('touchend', (e) => {
          const touchDuration = Date.now() - touchStartTime;
          // Solo se il touch Ã¨ stato breve (< 300ms) per evitare scroll
          if(touchDuration < 300) {
            const lock = window.stickyClickLock || false;
            if(!lock) {
              e.preventDefault();
              handleStickyClick(e);
            }
          }
        }, { passive: false });
        console.log('[STICKY] Touch listeners attached');
      } else {
        console.warn('[STICKY] Sticky bar element not found!');
      }
      
      // Event listener per nudge checkout button (se non giÃ  presente)
      const nudgeCheckoutBtn = document.getElementById('nudgeCheckoutBtn');
      if(nudgeCheckoutBtn && !nudgeCheckoutBtn.dataset.listenerAdded) {
        // L'onclick viene impostato dinamicamente in updateNudgeBar()
        nudgeCheckoutBtn.dataset.listenerAdded = 'true';
      }
      
      // Event listener per resize/orientationchange per aggiornare padding
      let resizeTimeout;
      function handleResize() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if(currentScreen === 'album') {
            updateBottomPadding();
          }
        }, 150);
      }
      window.addEventListener('resize', handleResize);
      window.addEventListener('orientationchange', handleResize);
    }
    
    // Event listener per bottone modal celebrativo (collegato dopo DOM ready)
    (function bindDealModal(){
      const btn = document.getElementById('dealContinueBtn');
      if(btn && !btn.dataset.bound){
        btn.dataset.bound = '1';
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('[DEAL_MODAL] Bottone cliccato, chiudo modal');
          closeDealModal();
          // Forza un piccolo delay per assicurarsi che il DOM si aggiorni
          setTimeout(() => {
            // Verifica che il modal sia chiuso
            const modal = document.getElementById('dealModal');
            if(modal) {
              if(modal.classList.contains('show')) {
                console.warn('[DEAL_MODAL] Modal ancora aperto, forzo chiusura');
                modal.classList.remove('show');
              }
              // Forza rimozione completa
              modal.style.display = 'none';
              modal.style.pointerEvents = 'none';
              modal.style.visibility = 'hidden';
              
              // Rimuovi anche da backdrop e card
              const backdrop = modal.querySelector('.deal-modal-backdrop');
              const card = modal.querySelector('.deal-modal-card');
              if(backdrop) {
                backdrop.style.pointerEvents = 'none';
                backdrop.style.display = 'none';
              }
              if(card) {
                card.style.pointerEvents = 'none';
              }
              
              // Assicura che body non abbia overflow hidden
              if(document.body) {
                document.body.style.overflow = '';
              }
            }
          }, 10);
        });
      }
    })();
    
    // Bottone "Aggiungi membro famiglia"
    const addFamilyBtn = document.getElementById('addFamilyBtn');
    if(addFamilyBtn) {
      addFamilyBtn.addEventListener('click', async () => {
        // Verifica limite membri
        if(familyMembers.length >= 8) {
          alert('You have already added the maximum number of members (8).');
          return;
        }
        
        // Attiva modalitÃ  aggiunta membro (senza email)
        isAddingFamilyMember = true;
        activeFamilyMode = true;
        
        // Aggiorna header
        const headerText = document.getElementById('selfieHeaderText');
        if(headerText) headerText.textContent = t('family_member_selfie');
        
        // Mostra schermata selfie
        showScreen('selfie');
        
        // Avvia camera (parte di un gesto utente)
        try {
          await startCamera();
        } catch(e) {
          console.error('Error starting camera for family member:', e);
          alert('Error accessing camera');
          isAddingFamilyMember = false;
          activeFamilyMode = false;
          const headerText2 = document.getElementById('selfieHeaderText');
          if(headerText2) headerText2.textContent = t('take_your_selfie');
        }
      });
    }
    
    // Gestione tab album
    const myContentTab = document.getElementById("myContentTab");
    const pricesTab = document.getElementById("pricesTab");
    const pricesList = document.getElementById("pricesList");
    const closeCartBtn = document.getElementById("closeCartBtn");
    const cartModal = document.getElementById('cartModal');
    
    if(myContentTab && pricesTab && albumGrid && pricesList) {
      myContentTab.addEventListener("click", () => {
        myContentTab.classList.add('active');
        pricesTab.classList.remove('active');
        if(albumGrid) albumGrid.style.display = 'grid';
        pricesList.classList.remove('active');
        // Mostra sticky e nudge quando si torna alla griglia foto
        showStickyOfferBarIfAllowed();
        showNudgeBarIfAllowed();
        // Richiama le funzioni esistenti per aggiornare UI/checkout/nudge/sticky
        updateStickyAllOffer();
        updateNudgeBar();
        updateBottomPadding();
      });
      
      pricesTab.addEventListener("click", () => {
        pricesTab.classList.add('active');
        myContentTab.classList.remove('active');
        if(albumGrid) albumGrid.style.display = 'none';
        pricesList.classList.add('active');
        // Nascondi sticky e nudge quando si va al listino prezzi
        hideStickyOfferBar();
        hideNudgeBar();
        updateBottomPadding();
      });
    }
    
    if(closeCartBtn && cartModal) {
      closeCartBtn.addEventListener("click", () => {
        cartModal.classList.remove('active');
        updateNudgeBar(); // Mostra nudge bar quando si chiude il carrello (se siamo nella schermata album)
      });
    }
    const checkoutBtn = document.getElementById("checkoutBtn");
    if(checkoutBtn) {
      checkoutBtn.addEventListener("click", checkout);
    }
    const clearCartBtn = document.getElementById("clearCartBtn");
    if(clearCartBtn) {
      clearCartBtn.addEventListener("click", clearCart);
    }
    
    // Chiudi modal cliccando fuori
    if(cartModal) {
      cartModal.addEventListener('click', (e) => {
        if(e.target.id === 'cartModal') {
          cartModal.classList.remove('active');
          updateNudgeBar(); // Mostra nudge bar quando si chiude il carrello (se siamo nella schermata album)
        }
      });
    }
    
    document.getElementById('offersModal').addEventListener('click', (e) => {
      if(e.target.id === 'offersModal') {
        document.getElementById('offersModal').classList.remove('active');
      }
    });

    // ========== FAMILY MEMBERS MANAGEMENT ==========
    let memberStream = null;
    let memberCapturedBlob = null;
    
    // Funzione per mostrare album da foto giÃ  caricate (senza fetch)
    async function showAlbumFromCachedPhotos(email, foundPhotos, paidPhotos) {
      if(!email) {
        console.error("showAlbumFromCachedPhotos: email is required");
          return;
        }

      console.log(`showAlbumFromCachedPhotos: found=${foundPhotos.length}, paid=${paidPhotos.length}`);
      
      // Unisci found+paid per photo_id senza duplicati
      let photosToShow = [];
      const photoIdsSet = new Set();
      
      // Aggiungi found_photos
      if(foundPhotos && foundPhotos.length > 0) {
        foundPhotos.forEach(p => {
          const photoId = typeof p === 'string' ? p : p.photo_id;
          if(photoId && !photoIdsSet.has(photoId)) {
            photosToShow.push({
              photo_id: photoId,
              score: 0,
              has_face: true,
              paid: (typeof p === 'object' && p.status === 'paid') || false
            });
            photoIdsSet.add(photoId);
          }
        });
      }
      
      // Aggiungi paid_photos che non sono giÃ  in found
      if(paidPhotos && paidPhotos.length > 0) {
        paidPhotos.forEach(photoId => {
          const pid = typeof photoId === 'string' ? photoId : photoId.photo_id;
          if(pid && !photoIdsSet.has(pid)) {
            photosToShow.push({
              photo_id: pid,
              score: 0,
              has_face: true,
              paid: true
            });
            photoIdsSet.add(pid);
          }
        });
      }
      
      // Aggiorna paidPhotos array globale per il carrello (array di stringhe)
      if(paidPhotos && paidPhotos.length > 0) {
        paidPhotos = paidPhotos.map(p => typeof p === 'string' ? p : p.photo_id).filter(Boolean);
      }
      
      if(photosToShow.length > 0) {
        allPhotos = photosToShow;
        photosLoadedCount = 0;
        
        // Salva step
        // Stateless: non salvare step
        
        // Mostra schermata album
        showScreen('album');
        
        // Carica membri famiglia in background
        loadFamilyMembersOnce().catch(e => console.error('Error loading family members:', e));
        
      // Aggiorna carrello
      updateCart();
      
      // Carica le foto (con lazy loading)
      await displayPhotos();
      
      // Renderizza chip membri su mobile
      renderMemberChips();
        
        // Mostra banner dopo che lo schermo Ã¨ visibile
        setTimeout(() => {
          const unpaidCount = photosToShow.filter(p => !p.paid).length;
          if(unpaidCount > 0) {
            showStickyOfferBar(unpaidCount);
          } else {
            // Nascondi sticky bar se tutte le foto sono pagate
            const stickyBar = document.getElementById('stickyOfferBar');
            if(stickyBar) {
              stickyBar.style.display = 'none';
            }
          }
        }, 100);
      } else {
        console.log("No photos to show in showAlbumFromCachedPhotos");
      }
    }
    
    // Funzione unica per andare alla gallery: carica /family/members e /user/photos
    async function goToGallery(email) {
      console.log("STEP match->load photos");
      if(!email) {
        console.error("goToGallery: email is required");
        return;
      }
      
      // Salva step corrente
      localStorage.setItem('step', 'gallery');
      
      // Carica membri famiglia in background (non bloccare)
      loadFamilyMembersOnce().catch(e => console.error('Error loading family members:', e));
      
      // Carica foto utente con funzione centralizzata
      try {
        const data = await fetchUserPhotos(email);
        
        if(data.ok) {
          let photosToShow = [];
          
          // Aggiungi found_photos
          if(data.found_photos && data.found_photos.length > 0) {
            photosToShow = data.found_photos.map(p => ({
              photo_id: p.photo_id,
              score: 0,
              has_face: true,
              paid: p.status === 'paid'
            }));
          }
          
          // Aggiungi anche le foto pagate che non sono in found_photos
          if(data.paid_photos && data.paid_photos.length > 0) {
            const foundPhotoIds = new Set(photosToShow.map(p => p.photo_id));
            data.paid_photos.forEach(photoId => {
              if(!foundPhotoIds.has(photoId)) {
                photosToShow.push({
                  photo_id: photoId,
                  score: 0,
                  has_face: true,
                  paid: true
                });
              }
            });
          }
          
          // Aggiorna paidPhotos array per il carrello
          if(data.paid_photos && data.paid_photos.length > 0) {
            paidPhotos = [...data.paid_photos];
          }
          
          if(photosToShow.length > 0) {
            allPhotos = photosToShow;
            photosLoadedCount = 0; // Reset counter
            
            // Nascondi upload status se presente
            const uploadStatus = document.getElementById('uploadStatus');
            const captureBtn = document.getElementById('captureBtn');
            if(uploadStatus) uploadStatus.classList.remove('active');
            if(captureBtn) {
              captureBtn.disabled = false;
              captureBtn.style.opacity = '1';
            }
            
            // Schermata album giÃ  mostrata sopra, ora aggiorna carrello
            updateCart();
            
            // Carica le foto (con lazy loading)
            await displayPhotos();
            
            // Mostra banner dopo che lo schermo Ã¨ visibile
                setTimeout(() => {
              const unpaidCount = photosToShow.filter(p => !p.paid).length;
              if(unpaidCount > 0) {
                showStickyOfferBar(unpaidCount);
              } else {
                // Nascondi sticky bar se tutte le foto sono pagate
                const stickyBar = document.getElementById('stickyOfferBar');
                if(stickyBar) {
                  stickyBar.style.display = 'none';
                }
              }
            }, 100);
                } else {
            console.log("No photos found in goToGallery");
          }
        } else {
          console.log("No photos found in goToGallery");
        }
      } catch(e) {
        console.error('Error loading photos in goToGallery:', e);
        // Mostra errore se timeout o altro
        if(e.message && e.message.includes('timeout')) {
          alert('Request timeout. Please check your connection and try again.');
        } else {
          alert('Error loading photos. Please try again.');
        }
      }
    }
    
    // Carica membri quando l'album viene mostrato
    // Guard per evitare doppia chiamata a /family/members
    let familyMembersLoaded = false;
    let familyMembersLoading = false;
    
    async function loadFamilyMembersOnce() {
      if (familyMembersLoaded || familyMembersLoading) {
        return;
      }
      familyMembersLoading = true;
      try {
        await loadFamilyMembers();
        familyMembersLoaded = true;
      } finally {
        familyMembersLoading = false;
      }
    }
    
    async function loadFamilyMembers() {
      if(!userEmail) return;
      
      try {
        // Prova prima localStorage
        // Stateless: non caricare da localStorage
        familyMembers = [];
        
        // Poi carica dal backend (sorgente preferita)
        const res = await fetch(`/family/members?email=${encodeURIComponent(userEmail)}`);
        const data = await res.json();
        
          if(data.ok && data.members) {
          familyMembers = data.members;
          // Salva in localStorage
          // Stateless: non salvare family members
          
          // Aggiorna contatore e chip
          updateFamilyMembersCount();
          
          if(data.members.length > 0) {
            const membersSection = document.getElementById('familyMembersSection');
            const membersList = document.getElementById('familyMembersList');
            
            if(membersSection) membersSection.style.display = 'block';
            if(membersList) {
              membersList.innerHTML = '';
              data.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.style.cssText = 'background: rgba(255,255,255,0.1); padding: 12px 16px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; min-width: 200px;';
                memberDiv.innerHTML = `
                  <span style="color: white; font-size: 14px;">${member.name || 'Membro ' + member.id}</span>
                  <button class="btn-retake" data-member-id="${member.id}" style="padding: 6px 12px; font-size: 12px; margin-left: 10px;">Rimuovi</button>
                `;
                membersList.appendChild(memberDiv);
                
                // Event listener per rimuovere membro
                const removeBtn = memberDiv.querySelector('button');
                removeBtn.addEventListener('click', async () => {
                  if(confirm('Remove this member? Their photos will be removed from the album.')) {
                    try {
                      const deleteRes = await fetch(`/family/members/${member.id}?email=${encodeURIComponent(userEmail)}`, {
                        method: 'DELETE'
                      });
                      const deleteData = await deleteRes.json();
                      if(deleteData.ok) {
                        // Refresh album
                        const photosRes = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
                        const photosData = await photosRes.json();
                        if(photosData.ok) {
                          const hasFound = photosData.found_photos && photosData.found_photos.length > 0;
                          const hasPaid = photosData.paid_photos && photosData.paid_photos.length > 0;
                          let photosToShow = [];
                          if(hasFound) {
                            photosToShow = photosData.found_photos.map(p => ({
                              photo_id: p.photo_id,
                              score: 0,
                              has_face: true,
                              paid: p.status === 'paid'
                            }));
                          }
                          if(hasPaid && photosData.paid_photos) {
                            const foundIds = new Set(photosToShow.map(p => p.photo_id));
                            photosData.paid_photos.forEach(id => {
                              if(!foundIds.has(id)) {
                                photosToShow.push({photo_id: id, score: 0, has_face: true, paid: true});
                              }
                            });
                          }
                          allPhotos = photosToShow;
                          photosLoaded = false;
                          await displayPhotos();
                          loadFamilyMembersOnce(); // Ricarica lista membri
                        }
                      }
                    } catch(e) {
                      console.error('Error deleting member:', e);
                      alert('Error removing member');
                    }
                  }
                });
              });
            }
          } else {
            const membersSection = document.getElementById('familyMembersSection');
            if(membersSection) membersSection.style.display = 'none';
          }
        }
      } catch(e) {
        console.error('Error loading family members:', e);
      }
    }
    
    function updateFamilyMembersCount() {
      const countEl = document.getElementById('familyMembersCount');
      if(countEl) {
        countEl.textContent = `(${familyMembers.length}/8)`;
      }
      
      // Aggiorna anche i chip su mobile
      renderMemberChips();
    }
    
    // Funzione per renderizzare i chip membri su mobile
    function renderMemberChips() {
      const memberChipsRow = document.getElementById('memberChipsRow');
      if(!memberChipsRow) return;
      
      // Pulisci contenuto
      memberChipsRow.innerHTML = '';
      
      // Array di membri da mostrare (max 4 totali: principale + 3 aggiunti)
      const membersToShow = [];
      
      // Aggiungi main member (members[0]) se presente
      if(members.length > 0 && members[0] && members[0].avatarDataUrl) {
        const mainChip = document.createElement('div');
        mainChip.className = 'member-chip';
        mainChip.setAttribute('data-member-index', '0');
        const img = document.createElement('img');
        img.src = members[0].avatarDataUrl;
        img.alt = 'Main person';
        mainChip.appendChild(img);
        memberChipsRow.appendChild(mainChip);
        membersToShow.push({ type: 'main', avatar: members[0].avatarDataUrl });
      } else {
        // Fallback: usa mainPersonAvatar se members[0] non esiste
        const mainPersonAvatar = document.getElementById('mainPersonAvatar');
        if(mainPersonAvatar && mainPersonAvatar.src && mainPersonAvatar.src !== window.location.href) {
          const mainChip = document.createElement('div');
          mainChip.className = 'member-chip';
          mainChip.setAttribute('data-member-index', '0');
          const img = document.createElement('img');
          img.src = mainPersonAvatar.src;
          img.alt = 'Main person';
          mainChip.appendChild(img);
          memberChipsRow.appendChild(mainChip);
          membersToShow.push({ type: 'main', avatar: mainPersonAvatar.src });
        }
      }
      
      // Aggiungi membri aggiunti (dal secondo in poi, max 3 per arrivare a 4 totali)
      const maxAdditional = 3;
      const membersToAdd = members.slice(1, maxAdditional + 1); // Salta members[0], prendi i successivi
      
      membersToAdd.forEach((member, index) => {
        // index qui Ã¨ relativo a membersToAdd (0-based), ma l'indice reale Ã¨ index + 1 (perchÃ© saltiamo members[0])
        const realIndex = index + 1;
        const chip = document.createElement('div');
        chip.className = 'member-chip';
        chip.setAttribute('data-member-index', realIndex);
        
        // Se il membro ha un avatarDataUrl o avatar, usalo
        const avatarUrl = member.avatarDataUrl || member.avatar || member.avatar_url;
        if(avatarUrl) {
          const img = document.createElement('img');
          img.src = avatarUrl;
          img.alt = member.name || `Member ${realIndex + 1}`;
          chip.appendChild(img);
        } else {
          // Placeholder con iniziale o icona
          chip.textContent = (member.name && member.name.charAt(0).toUpperCase()) || '?';
          chip.style.fontSize = '16px';
          chip.style.fontWeight = '600';
          chip.style.color = 'rgba(255,255,255,0.8)';
        }
        
        // Aggiungi bottone rimozione (tutti i membri aggiunti sono rimovibili, members[0] no)
        const removeBtn = document.createElement('button');
        removeBtn.className = 'member-remove';
        removeBtn.type = 'button';
        removeBtn.setAttribute('aria-label', 'Remove member');
        removeBtn.setAttribute('data-remove-index', realIndex);
        removeBtn.textContent = 'Ã—';
        chip.appendChild(removeBtn);
        
        memberChipsRow.appendChild(chip);
      });
      
      // Aggiungi chip "+" per aggiungere membro (solo se non abbiamo raggiunto il limite UI di 4)
      const totalChips = (members.length > 0 && members[0] ? 1 : 0) + membersToAdd.length;
      if(totalChips < 4 && members.length < 8) {
        const plusChip = document.createElement('div');
        plusChip.className = 'member-chip plus';
        plusChip.textContent = '+';
        plusChip.title = t('add_family_member');
        plusChip.addEventListener('click', () => {
          // Chiama lo stesso handler di addFamilyBtn
          const addFamilyBtn = document.getElementById('addFamilyBtn');
          if(addFamilyBtn) {
            addFamilyBtn.click();
          }
        });
        memberChipsRow.appendChild(plusChip);
      }
      
      // Event delegation per rimozione membri
      if(!memberChipsRow.dataset.removeListenerAttached) {
        memberChipsRow.dataset.removeListenerAttached = '1';
        memberChipsRow.addEventListener('click', (e) => {
          const btn = e.target?.closest?.('.member-remove');
          if(!btn) return;
          
          e.preventDefault();
          e.stopPropagation();
          
          const idx = parseInt(btn.getAttribute('data-remove-index') || '', 10);
          if(!Number.isFinite(idx) || idx <= 0) return; // membro 0 non cancellabile
          
          removeMemberAndRefresh(idx);
        });
      }
    }
    
    // Ricostruisce l'album dall'unione delle foto di tutti i membri (con dedupe)
    function rebuildAlbumFromMembers() {
      const seen = new Set();
      const merged = [];
      
      for(const m of members) {
        if(!m || !m.photoKeys) continue;
        const photoKeys = m.photoKeys;
        
        for(const key of photoKeys) {
          if(!key || seen.has(key)) continue;
          seen.add(key);
          
          // Trova l'oggetto foto completo da allPhotos o albumPhotosAll
          const photoObj = allPhotos.find(p => {
            const pKey = p.photo_id || p.id || p.url || p.filename;
            return pKey === key;
          }) || albumPhotosAll.find(p => {
            const pKey = p.photo_id || p.id || p.url || p.filename;
            return pKey === key;
          });
          
          if(photoObj) {
            merged.push(photoObj);
          } else {
            // Se non trovato, crea un oggetto minimo
            merged.push({
              photo_id: key,
              id: key,
              score: 0,
              has_face: true,
              paid: false
            });
          }
        }
      }
      
      // Assegna alla variabile reale che usa la griglia
      albumPhotosAll = merged;
      allPhotos = merged;
      
      console.log(`[REBUILD] Album ricostruito: ${merged.length} foto da ${members.length} membri`);
    }
    
    // Rimuove un membro e aggiorna griglia/carrello
    function removeMemberAndRefresh(idx) {
      try {
        console.log('[REMOVE_MEMBER] Removing member at index', idx);
        
        // 1) Rimuovi membro dall'array
        if(idx < 0 || idx >= familyMembers.length) {
          console.warn('[REMOVE_MEMBER] Invalid index:', idx);
          return;
        }
        
        const removed = familyMembers.splice(idx, 1)[0];
        if(!removed) {
          console.warn('[REMOVE_MEMBER] No member found at index:', idx);
          return;
        }
        
        // 2) Ricava le foto del membro rimosso
        const removedPhotos = removed.photos || [];
        const removedKeys = new Set(removedPhotos.filter(Boolean));
        
        console.log('[REMOVE_MEMBER] Removed member photos:', removedKeys.size);
        
        // 3) Rimuovi dalla lista che alimenta la griglia
        if(removedKeys.size > 0) {
          const beforeCount = allPhotos.length;
          allPhotos = allPhotos.filter(p => {
            const key = p.photo_id || p.id || p.url || p.filename;
            return !removedKeys.has(key);
          });
          const removedCount = beforeCount - allPhotos.length;
          console.log('[REMOVE_MEMBER] Removed', removedCount, 'photos from grid');
          
          // Aggiorna anche albumPhotosAll
          albumPhotosAll = albumPhotosAll.filter(p => {
            const key = p.photo_id || p.id || p.url || p.filename;
            return !removedKeys.has(key);
          });
        }
        
        // 4) Rimuovi dal carrello le foto eliminate (se presenti)
        if(currentCart && currentCart.photo_ids) {
          const beforeCartCount = currentCart.photo_ids.length;
          currentCart.photo_ids = currentCart.photo_ids.filter(photoId => {
            return !removedKeys.has(photoId);
          });
          const removedFromCart = beforeCartCount - currentCart.photo_ids.length;
          
          if(removedFromCart > 0) {
            console.log('[REMOVE_MEMBER] Removed', removedFromCart, 'photos from cart');
            // Ricalcola totale carrello
            updateCart();
          }
        }
        
        // 5) Aggiorna UI: chips + griglia + carrello
        renderMemberChips();
        displayPhotos().then(() => {
          updateCart();
          updateStickyAllOffer();
          updateNudgeBar();
        });
        
        console.log('[REMOVE_MEMBER] Member removed successfully');
      } catch(err) {
        console.error('[REMOVE_MEMBER] Error removing member:', err);
        alert('Error removing member. Please try again.');
      }
    }
    
    // Bottone "Aggiungi membro"
    const addMemberBtn = document.getElementById('addMemberBtn');
    const addMemberModal = document.getElementById('addMemberModal');
    const closeAddMemberModalBtn = document.getElementById('closeAddMemberModalBtn');
    const startMemberSelfieBtn = document.getElementById('startMemberSelfieBtn');
    const memberSelfieArea = document.getElementById('memberSelfieArea');
    const memberVideo = document.getElementById('memberVideo');
    const memberCanvas = document.getElementById('memberCanvas');
    const memberCaptureBtn = document.getElementById('memberCaptureBtn');
    const memberNameInput = document.getElementById('memberNameInput');
    const memberUploadStatus = document.getElementById('memberUploadStatus');
    
    if(addMemberBtn && addMemberModal) {
      addMemberBtn.addEventListener('click', () => {
        addMemberModal.classList.add('active');
        memberSelfieArea.style.display = 'none';
        memberNameInput.value = '';
        memberCapturedBlob = null;
      });
    }
    
    if(closeAddMemberModalBtn && addMemberModal) {
      closeAddMemberModalBtn.addEventListener('click', () => {
        addMemberModal.classList.remove('active');
        if(memberStream) {
          memberStream.getTracks().forEach(track => track.stop());
          memberStream = null;
        }
      });
    }
    
    if(startMemberSelfieBtn) {
      startMemberSelfieBtn.addEventListener('click', async () => {
        memberSelfieArea.style.display = 'block';
        startMemberSelfieBtn.style.display = 'none';
        
        // Avvia camera per membro
        try {
          memberStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user' }
          });
          if(memberVideo) {
            memberVideo.srcObject = memberStream;
            memberCaptureBtn.disabled = false;
            memberCaptureBtn.style.opacity = '1';
          }
        } catch(e) {
          console.error('Error starting member camera:', e);
          alert('Error accessing camera');
        }
      });
    }
    
    if(memberCaptureBtn) {
      memberCaptureBtn.addEventListener('click', async () => {
        if(!memberVideo || !memberCanvas) return;
        
        const ctx = memberCanvas.getContext('2d');
        memberCanvas.width = memberVideo.videoWidth;
        memberCanvas.height = memberVideo.videoHeight;
        ctx.drawImage(memberVideo, 0, 0);
        
        memberCanvas.toBlob(async (blob) => {
          memberCapturedBlob = blob;
          
          // Ferma camera
          if(memberStream) {
            memberStream.getTracks().forEach(track => track.stop());
            memberStream = null;
          }
          
          // Mostra loading
          memberUploadStatus.style.display = 'block';
          memberCaptureBtn.disabled = true;
          
          // Invia a backend
          try {
            const formData = new FormData();
            formData.append('selfie', memberCapturedBlob, 'member_selfie.jpg');
            const memberName = memberNameInput.value.trim();
            if(memberName) {
              formData.append('member_name', memberName);
            }
            
            const res = await fetch(`/family/add_member?email=${encodeURIComponent(userEmail)}`, {
              method: 'POST',
              body: formData
            });
            
            const data = await res.json();
            
            if(data.ok) {
              // Successo: mostra toast e refresh album
              alert(`Membro aggiunto: +${data.matched_count} foto`);
              
              // Refresh album
              const photosRes = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
              const photosData = await photosRes.json();
              if(photosData.ok) {
                const hasFound = photosData.found_photos && photosData.found_photos.length > 0;
                const hasPaid = photosData.paid_photos && photosData.paid_photos.length > 0;
                let photosToShow = [];
                if(hasFound) {
                  photosToShow = photosData.found_photos.map(p => ({
                    photo_id: p.photo_id,
                    score: 0,
                    has_face: true,
                    paid: p.status === 'paid'
                  }));
                }
                if(hasPaid && photosData.paid_photos) {
                  const foundIds = new Set(photosToShow.map(p => p.photo_id));
                  photosData.paid_photos.forEach(id => {
                    if(!foundIds.has(id)) {
                      photosToShow.push({photo_id: id, score: 0, has_face: true, paid: true});
                    }
                  });
                }
                allPhotos = photosToShow;
                photosLoaded = false;
                await displayPhotos();
                loadFamilyMembersOnce(); // Ricarica lista membri
              }
              
              // Chiudi modal
              addMemberModal.classList.remove('active');
              memberSelfieArea.style.display = 'none';
              memberUploadStatus.style.display = 'none';
          } else {
              alert(data.detail || 'Error adding member');
              memberUploadStatus.style.display = 'none';
              memberCaptureBtn.disabled = false;
            }
          } catch(e) {
            console.error('Error adding member:', e);
            alert('Error adding member');
            memberUploadStatus.style.display = 'none';
            memberCaptureBtn.disabled = false;
          }
        }, 'image/jpeg', 0.9);
      });
    }
    
    // Chiudi modal cliccando fuori
    if(addMemberModal) {
      addMemberModal.addEventListener('click', (e) => {
        if(e.target.id === 'addMemberModal') {
          addMemberModal.classList.remove('active');
          if(memberStream) {
            memberStream.getTracks().forEach(track => track.stop());
            memberStream = null;
          }
        }
      });
    }

    // Funzioni camera
    async function startCamera() {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked startCamera() - post-payment flow active');
        return;
      }
      
      // Se giÃ  in avvio, ritorna
      if(cameraStarting) {
        console.log('[CAM] Camera already starting, skipping');
        return;
      }
      
      // Se giÃ  pronta, ritorna
      if(cameraReady && cameraStream) {
        console.log('[CAM] Camera already ready, skipping');
        return;
      }

      const video = document.getElementById('video');
        const captureBtn = document.getElementById('captureBtn');
      const placeholder = document.getElementById('videoPlaceholder');
      const retryCameraBtn = document.getElementById('retryCameraBtn');

      if (!video) {
        console.error('[CAM] Video element not found');
        return;
      }

      // Imposta stato iniziale
      cameraStarting = true;
      cameraReady = false;
      if(captureBtn) {
        captureBtn.disabled = true;
      }
      
      // Nascondi placeholder e retry button inizialmente
      if(placeholder) {
        placeholder.style.display = 'none';
      }
      if(retryCameraBtn) {
        retryCameraBtn.style.display = 'none';
      }

      try {
        // Verifica supporto camera
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('Camera non supportata dal browser');
        }

        console.log('[CAM] Richiesta accesso camera...');
        const constraints = { 
          video: { facingMode: 'user' }, 
          audio: false 
        };
        
        const newStream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log('[CAM] getUserMedia success, stream ottenuto');
        
        // Salva stream
        cameraStream = newStream;
        stream = newStream;
        window._cameraStream = newStream;

        // Assegna stream al video
        video.srcObject = newStream;
        
        // Nascondi prompt start camera
        const startCameraPrompt = document.getElementById('startCameraPrompt');
        if(startCameraPrompt) {
          startCameraPrompt.style.display = 'none';
        }
        
        // Mostra video
        video.style.display = 'block';
        
        // Event listeners per verificare quando il video Ã¨ pronto
        const onVideoReady = () => {
          if(video.videoWidth > 0 && video.videoHeight > 0) {
            console.log('[CAM] Video ready:', video.videoWidth, 'x', video.videoHeight);
            cameraReady = true;
            cameraStarting = false;
            
            // Abilita captureBtn
        if(captureBtn) {
      captureBtn.disabled = false;
        }
        
            // Nascondi placeholder
        if(placeholder) {
          placeholder.style.display = 'none';
            }
            
            // Rimuovi listeners (una volta pronta, non servono piÃ¹)
            video.removeEventListener('loadedmetadata', onVideoReady);
            video.removeEventListener('playing', onVideoReady);
          }
        };
        
        video.addEventListener('loadedmetadata', onVideoReady);
        video.addEventListener('playing', onVideoReady);
        
        // Prova a far partire il video
        try {
          await video.play();
          console.log('[CAM] Video play() success');
        } catch(playErr) {
          console.warn('[CAM] Video play() error (non critico):', playErr);
          // Il video potrebbe partire comunque, aspetta loadedmetadata/playing
        }
        
      } catch (err) {
        console.error('[CAM] Errore accesso camera:', err);
        
        cameraReady = false;
        cameraStarting = false;
        
        // Mostra placeholder e retry button
        if(placeholder) {
          placeholder.style.display = 'block';
        }
        if(retryCameraBtn) {
          retryCameraBtn.style.display = 'block';
        }
        if(video) {
          video.style.display = 'none';
        }
        
        // Disabilita pulsante cattura
        if(captureBtn) {
          captureBtn.disabled = true;
        }
        
        // Pulisci stream se era stato creato
        if(cameraStream) {
          cameraStream.getTracks().forEach(track => track.stop());
          cameraStream = null;
        }
        if(stream) {
          stream.getTracks().forEach(track => track.stop());
          stream = null;
        }
        if(window._cameraStream) {
          window._cameraStream.getTracks().forEach(track => track.stop());
          window._cameraStream = null;
        }
      }
    }
    
    function stopCamera() {
      console.log('[CAM] Stopping camera...');
      if(cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
      if(stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      if(window._cameraStream) {
        window._cameraStream.getTracks().forEach(track => track.stop());
        window._cameraStream = null;
      }
      cameraReady = false;
      cameraStarting = false;
      
      const video = document.getElementById('video');
      if(video) {
        video.srcObject = null;
      }
      
      const captureBtn = document.getElementById('captureBtn');
      if(captureBtn) {
        captureBtn.disabled = true;
    }
  }

  function captureSelfie() {
      const video = document.getElementById('video');
      
      // GUARD: Blocca se camera non pronta
      if(!cameraReady || !video || !video.srcObject || video.videoWidth === 0 || video.videoHeight === 0) {
        console.warn("Camera not ready:", {
          cameraReady,
            video: !!video,
          srcObject: !!video?.srcObject,
            width: video?.videoWidth,
          height: video?.videoHeight
          });
        return; // Non fare nulla, nessun canvas draw, nessuna preview
    }
      
      try {

        console.log("Cattura selfie, dimensioni video:", video.videoWidth, "x", video.videoHeight);
        
        // Aspect ratio fisso 3:4 (verticale) - stesso del contenitore video
        const targetAspectRatio = 3 / 4;
        const videoAspectRatio = video.videoWidth / video.videoHeight;
        
        let sourceX = 0;
        let sourceY = 0;
        let sourceWidth = video.videoWidth;
        let sourceHeight = video.videoHeight;
        
        // Calcola dimensioni canvas con aspect ratio 3:4
        let canvasWidth, canvasHeight;
        
        if(videoAspectRatio > targetAspectRatio) {
          // Video piÃ¹ largo: crop ai lati, mantieni altezza
          canvasHeight = video.videoHeight;
          canvasWidth = Math.round(canvasHeight * targetAspectRatio);
          sourceX = Math.round((video.videoWidth - canvasWidth) / 2);
          sourceY = 0;
          sourceWidth = canvasWidth;  // Usa la larghezza del crop, non quella del video
          sourceHeight = canvasHeight; // Usa l'altezza del crop
        } else {
          // Video piÃ¹ alto: crop sopra/sotto, mantieni larghezza
          canvasWidth = video.videoWidth;
          canvasHeight = Math.round(canvasWidth / targetAspectRatio);
          sourceX = 0;
          sourceY = Math.round((video.videoHeight - canvasHeight) / 2);
          sourceWidth = canvasWidth;  // Usa la larghezza del crop
          sourceHeight = canvasHeight; // Usa l'altezza del crop
        }
        
        // Imposta dimensioni canvas
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        
    const ctx = canvas.getContext('2d');
        
        // Disegna il frame corrente del video sul canvas con crop centrato
        // Usa la stessa area che viene mostrata nel video (object-fit: cover)
        ctx.drawImage(
          video,
          sourceX, sourceY, sourceWidth, sourceHeight,  // Area sorgente (crop) - CORRETTO
          0, 0, canvasWidth, canvasHeight                // Area destinazione (canvas)
        );
        
        console.log("Canvas creato, dimensioni:", canvas.width, "x", canvas.height);
        console.log("Crop applicato:", { sourceX, sourceY, sourceWidth, sourceHeight });
        
        // Converti canvas in blob
    canvas.toBlob(async (blob) => {
          if(!blob) {
            console.error("Error: blob not created");
            alert("Error capturing photo. Please try again.");
        return;
      }
          
          // Se siamo in modalitÃ  aggiunta membro famiglia (senza email)
          if(isAddingFamilyMember) {
            // Verifica limite membri
            if(familyMembers.length >= 8) {
              alert('You have already added the maximum number of members (8).');
              isAddingFamilyMember = false;
              activeFamilyMode = false;
              showScreen('album');
              return;
            }
            
            // Salva blob per match_selfie
            capturedBlob = blob;
            
            // Salva preview per avatar
            const url = URL.createObjectURL(blob);
            const confirmPreview = document.getElementById('confirmPreview');
            if(confirmPreview) {
              confirmPreview.src = url;
            }
            
            // Vai direttamente a confirm (come il primo selfie)
            // L'utente deve cliccare "Conferma" per procedere
            showScreen('confirm');
            
            // NON avviare matchPhotos automaticamente
            // Il click su confirmBtn gestirÃ  il flow (come nel primo selfie)
            // Reset stati per il prossimo match
            photosReady = false;
            photosFailed = false;
            photosSearchPromise = null;
            return; // Ferma qui, aspetta il click su confirmBtn
          }
          
          // Logica normale per selfie principale
          console.log("Blob creato, dimensione:", blob.size, "bytes");
          capturedBlob = blob;
          const url = URL.createObjectURL(blob);
          confirmPreview.src = url;
          if(mainPersonAvatar) {
            mainPersonAvatar.src = url;
            // Aggiorna chip membri se siamo sull'album
            setTimeout(() => renderMemberChips(), 100);
          }
          
          // Ferma lo stream
          if(stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
          }
          
          showScreen('confirm');
        }, 'image/jpeg', 0.9);
        
      } catch(err) {
        console.error("Errore nella cattura selfie:", err);
        alert("Error capturing photo: " + err.message);
      }
    }
    
    // Funzione per avviare la ricerca foto in background (senza await)
    // BLOCCA qualsiasi "auto-search" senza selfie
    function startPhotosSearchInBackground() {
      // GUARD: NON partire se non c'Ã¨ capturedBlob
      if(!capturedBlob) {
        console.warn('[CONFIRM_FLOW] BLOCKED: capturedBlob is null - cannot start search without selfie');
        updateMinimalDebug('BLOCKED', 0, '-', undefined, 'no selfie');
        photosReady = false;
        photosFailed = true;
        return;
      }
      
      if(photosSearchPromise) {
        // GiÃ  in corso, non riavviare
        return;
      }
      
      console.log('[CONFIRM_FLOW] Starting photos search in background');
      updateMinimalDebug('START', undefined, '-', undefined, '');
      
      // Reset stati foto
      photosReady = false;
      photosFailed = false;
      
      // Avvia match in background (senza await)
      photosSearchPromise = matchPhotos().catch(err => {
        console.error('[CONFIRM_FLOW] Error in matchPhotos:', err);
        updateMinimalDebug(`ERROR: ${err.message}`, 0, '-', undefined, '');
        photosReady = false;
        photosFailed = true;
        photosSearchPromise = null;
      });
    }
    
    // Funzione chiamata dopo la selezione della lingua
    async function proceedAfterLanguageSelection() {
      console.log('[CONFIRM_FLOW] proceedAfterLanguageSelection called');
      
      // Mostra feedback
      const langFeedback = document.getElementById('langFeedback');
      const langFeedbackText = document.getElementById('langFeedbackText');
      if(langFeedback && langFeedbackText) {
        langFeedbackText.textContent = t('language_selected', { langName: langNames[selectedLanguage] });
        langFeedback.style.display = 'block';
      }
      
      // Se le foto sono giÃ  pronte, vai subito all'album
      if(photosReady && allPhotos.length > 0) {
        console.log('[CONFIRM_FLOW] Photos already ready, going to album');
        const langLoading = document.getElementById('langLoading');
        const langErrorBox = document.getElementById('langErrorBox');
        if(langLoading) {
          langLoading.style.display = 'none';
          langLoading.style.pointerEvents = 'none';
        }
        if(langErrorBox) {
          langErrorBox.style.display = 'none';
          langErrorBox.style.pointerEvents = 'none';
        }
        
        showScreen('album');
        await displayPhotos();
        updateCart();
        if(allPhotos.length > 0) {
          showStickyOfferBar();
        }
        return;
      }
      
      // Se le foto sono fallite, mostra errore REALE (non generico "nessuna foto")
      if(photosFailed) {
        console.log('[CONFIRM_FLOW] Photos failed, showing error');
        const langLoading = document.getElementById('langLoading');
        const langErrorBox = document.getElementById('langErrorBox');
        if(langLoading) {
          langLoading.style.display = 'none';
          langLoading.style.pointerEvents = 'none';
        }
        if(langErrorBox) {
          langErrorBox.style.display = 'block';
          langErrorBox.style.pointerEvents = 'auto';
          // FIX: mostra errore reale, non messaggio generico
          const errorText = langErrorBox.querySelector('.lang-error-text');
          if (errorText && !errorText.innerHTML.includes('Errore:')) {
            errorText.innerHTML = `<span style="color: #ff4444; font-weight: bold;">Errore: caricamento foto fallito. Riprova.</span>`;
          }
        }
        return;
      }
      
      // Foto non ancora pronte: mostra loading e aspetta
      console.log('[CONFIRM_FLOW] Photos not ready yet, showing loading');
      const langLoading = document.getElementById('langLoading');
      const langErrorBox = document.getElementById('langErrorBox');
      if(langLoading) {
        langLoading.style.display = 'flex';
        langLoading.style.pointerEvents = 'auto';
      }
      if(langErrorBox) {
        langErrorBox.style.display = 'none';
        langErrorBox.style.pointerEvents = 'none';
      }
      
      // Se la ricerca non Ã¨ ancora partita, avviala
      if(!photosSearchPromise) {
        startPhotosSearchInBackground();
      }
      
      // Aspetta che la ricerca finisca
      try {
        await photosSearchPromise;
        photosSearchPromise = null;
        
        // Controlla di nuovo lo stato dopo l'attesa
        if(photosReady && allPhotos.length > 0) {
          // Foto pronte, vai all'album
          if(langLoading) {
            langLoading.style.display = 'none';
            langLoading.style.pointerEvents = 'none';
          }
          if(langErrorBox) {
            langErrorBox.style.display = 'none';
            langErrorBox.style.pointerEvents = 'none';
          }
          // IMPORTANTE: chiama displayPhotos per renderizzare la griglia
          goToAlbumScreen();
          return;
          
          // Se stiamo aggiungendo un membro famiglia, gestisci avatar e reset flag
          if(isAddingFamilyMember) {
            // Salva nuovo membro (NON toccare members[0])
            const confirmPreview = document.getElementById('confirmPreview');
            if(confirmPreview && confirmPreview.src) {
              // Usa le foto salvate temporaneamente durante il merge
              const memberPhotos = window._lastMemberPhotos || [];
              
              // Crea nuovo membro e aggiungilo (NON sovrascrivere members[0])
              const newMember = {
                id: 'member_' + Date.now(),
                avatarDataUrl: confirmPreview.src,
                timestamp: Date.now(),
                photoKeys: memberPhotos
              };
              members.push(newMember);
              
              // Aggiorna anche familyMembers per compatibilitÃ  con il codice esistente
              const memberAvatar = {
                id: newMember.id,
                avatar: confirmPreview.src,
                timestamp: newMember.timestamp,
                photos: memberPhotos
              };
              familyMembers.push(memberAvatar);
              
              // Ricostruisci album da tutti i membri
              rebuildAlbumFromMembers();
              
              // Pulisci variabile temporanea
              window._lastMemberPhotos = null;
              // Aggiorna barra membri
              renderMemberChips();
            }
            // Reset flag
            isAddingFamilyMember = false;
            activeFamilyMode = false;
            // Aggiorna header
            const headerText = document.getElementById('selfieHeaderText');
            if(headerText) headerText.textContent = t('take_your_selfie');
          }
          
          showScreen('album');
          await displayPhotos();
          updateCart();
          if(allPhotos.length > 0) {
            showStickyOfferBar();
          }
        } else {
          // Foto fallite o non trovate
          if(langLoading) {
            langLoading.style.display = 'none';
            langLoading.style.pointerEvents = 'none';
          }
          if(langErrorBox) {
            langErrorBox.style.display = 'block';
            langErrorBox.style.pointerEvents = 'auto';
          }
        }
      } catch(err) {
        console.error('[CONFIRM_FLOW] Error waiting for photos:', err);
        if(langLoading) {
          langLoading.style.display = 'none';
          langLoading.style.pointerEvents = 'none';
        }
        if(langErrorBox) {
          langErrorBox.style.display = 'block';
          langErrorBox.style.pointerEvents = 'auto';
        }
      }
    }
    
    async function confirmSelfie() {
      try {
        console.log('[CONFIRM_FLOW] Confirm button clicked');
        
        // NON mostrare loading qui
        const confirmLoading = document.getElementById('confirmLoadingIndicator');
        if (confirmLoading) {
          confirmLoading.style.display = 'none';
          confirmLoading.style.pointerEvents = 'none';
        }

        // Stop camera per evitare blocchi su iOS
        try {
          if (window._cameraStream) {
            window._cameraStream.getTracks().forEach(t => t.stop());
            window._cameraStream = null;
          }
          if (typeof cameraStream !== 'undefined' && cameraStream) {
            cameraStream.getTracks().forEach(t => t.stop());
            cameraStream = null;
          }
        } catch(e) {
          console.warn('[CAMERA] stop failed', e);
        }

        // Marca selfie come completato
        selfieCompleted = true;

        // BLOCCA: NON avviare ricerca automatica - aspetta che l'utente selezioni lingua
        // La ricerca partirÃ  solo quando l'utente seleziona la lingua (se capturedBlob esiste)
        // startPhotosSearchInBackground(); // DISATTIVATO - parte solo dopo selezione lingua

        // Vai subito alla schermata lingua
        showScreen('language');
        
        // Nascondi tutti gli overlay inizialmente
        const langLoading = document.getElementById('langLoading');
        const langErrorBox = document.getElementById('langErrorBox');
        const langFeedback = document.getElementById('langFeedback');
        if(langLoading) {
          langLoading.style.display = 'none';
          langLoading.style.pointerEvents = 'none';
        }
        if(langErrorBox) {
          langErrorBox.style.display = 'none';
          langErrorBox.style.pointerEvents = 'none';
        }
        if(langFeedback) {
          langFeedback.style.display = 'none';
        }

        // Se la lingua era giÃ  stata scelta in questa sessione, non richiederla
        if (selectedLanguage) {
          setLanguage(selectedLanguage);
          proceedAfterLanguageSelection();
        }
      } catch (e) {
        console.error('[CONFIRM] error', e);
      }
    }

    // Funzioni UI per gestione selfie loading/error
    function showSelfieLoading(isLoading) {
      const uploadStatus = document.getElementById('uploadStatus');
      const selfieErrorBox = document.getElementById('selfieErrorBox');
      const captureBtn = document.getElementById('captureBtn');
      
      if(isLoading) {
        // Mostra loading, nascondi errore
        if(uploadStatus) uploadStatus.classList.add('active');
        if(selfieErrorBox) selfieErrorBox.style.display = 'none';
        if(captureBtn) {
          captureBtn.disabled = true;
          captureBtn.style.opacity = '0.5';
        }
      } else {
        // Nascondi loading
        if(uploadStatus) uploadStatus.classList.remove('active');
        if(captureBtn) {
          captureBtn.disabled = false;
          captureBtn.style.opacity = '1';
        }
      }
    }
    
    function showSelfieError(message) {
      const uploadStatus = document.getElementById('uploadStatus');
      const selfieErrorBox = document.getElementById('selfieErrorBox');
      const selfieErrorMessage = document.getElementById('selfieErrorMessage');
      const captureBtn = document.getElementById('captureBtn');
      
      // Nascondi loading
      if(uploadStatus) uploadStatus.classList.remove('active');
      if(captureBtn) {
        captureBtn.disabled = false;
        captureBtn.style.opacity = '1';
      }
      
        // Mostra errore
        if(selfieErrorMessage) {
          selfieErrorMessage.textContent = message || t('no_photos_found');
        }
      if(selfieErrorBox) {
        selfieErrorBox.style.display = 'flex';
      }
    }
    
    function resetSelfieState() {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked resetSelfieState() - post-payment flow active');
        return;
      }
      
      // Reset variabili
      capturedBlob = null;
      selfieCompleted = false;
      allPhotos = [];
      currentPhotoIndex = 0;
      paidPhotos = [];
      
      // Nascondi errore
      const selfieErrorBox = document.getElementById('selfieErrorBox');
      if(selfieErrorBox) selfieErrorBox.style.display = 'none';
      
      // Torna allo schermo selfie e riavvia camera
      showScreen('selfie');
      startCamera();
    }
    
    // ========== DEBUG TEMPORANEO (solo per sviluppo) ==========
    let debugBox = null;
    function initDebugBox() {
      if (debugBox) return;
      debugBox = document.createElement('div');
      debugBox.id = 'tempDebugBox';
      debugBox.style.cssText = 'position:fixed; bottom:0; left:0; right:0; max-height:200px; overflow-y:auto; background:rgba(0,0,0,0.95); color:#0f0; font-family:monospace; font-size:11px; padding:10px; z-index:99999; border-top:2px solid #0f0;';
      document.body.appendChild(debugBox);
    }
    function debugLogBox(msg) {
      // Disabilitato per pulizia log - non mostra piÃ¹ il box verde
      // if (!debugBox) initDebugBox();
      // const line = document.createElement('div');
      // line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      // debugBox.appendChild(line);
      // debugBox.scrollTop = debugBox.scrollHeight;
      console.log(msg);
    }

    // Helper: log error safely without breaking the flow
    function debugError(err) {
      try {
        // Always log full object to console
        console.error('[CONFIRM_FLOW] Error:', err);

        // Build a readable message for the on-page debug box
        let msg = '';
        if (typeof err === 'string') {
          msg = err;
        } else if (err && typeof err === 'object') {
          if (err.message) msg = err.message;
          else if (err.status && err.statusText) msg = `HTTP ${err.status}: ${err.statusText}`;
          else {
            try {
              msg = JSON.stringify(err);
            } catch (_) {
              msg = String(err);
            }
          }
        } else {
          msg = String(err);
        }

        // Avoid huge lines in the box
        if (msg && msg.length > 400) msg = msg.slice(0, 400) + '...';

        // If debug box is enabled, show it; otherwise do nothing
        if (typeof debugLogBox === 'function') {
          debugLogBox(`ERROR: ${msg || 'Unknown error'}`);
        }
      } catch (e) {
        // Last resort: never throw from the error logger
        console.error('debugError failed:', e);
      }
    }
    
    // ========== FUNZIONI ROBUSTE PARSING ==========
    // PARSING ROBUSTO DEL JSON - accetta questi campi per compatibilitÃ 
    function getPhotoIds(data) {
      // PrioritÃ  1: ids (chiave piÃ¹ comune)
      if (Array.isArray(data.ids) && data.ids.length > 0) {
        console.log('[getPhotoIds] Found ids:', data.ids.length);
        // debugLogBox(`getPhotoIds: ids (${data.ids.length})`);  // Rimosso per pulizia log
        return data.ids;
      }
      // PrioritÃ  2: photo_ids (compatibilitÃ )
      if (Array.isArray(data.photo_ids) && data.photo_ids.length > 0) {
        console.log('[getPhotoIds] Found photo_ids:', data.photo_ids.length);
        // debugLogBox(`getPhotoIds: photo_ids (${data.photo_ids.length})`);  // Rimosso per pulizia log
        return data.photo_ids;
      }
      // PrioritÃ  3: matched_photo_ids (nuovo formato standard)
      if (Array.isArray(data.matched_photo_ids) && data.matched_photo_ids.length > 0) {
        console.log('[getPhotoIds] Found matched_photo_ids:', data.matched_photo_ids.length);
        // debugLogBox(`getPhotoIds: matched_photo_ids (${data.matched_photo_ids.length})`);  // Rimosso per pulizia log
        return data.matched_photo_ids;
      }
      // PrioritÃ  4: matched_ids (alternativa)
      if (Array.isArray(data.matched_ids) && data.matched_ids.length > 0) {
        console.log('[getPhotoIds] Found matched_ids:', data.matched_ids.length);
        // debugLogBox(`getPhotoIds: matched_ids (${data.matched_ids.length})`);  // Rimosso per pulizia log
        return data.matched_ids;
      }
      // PrioritÃ  5: photos (se Ã¨ array di stringhe)
      if (Array.isArray(data.photos)) {
        if (data.photos.length > 0 && typeof data.photos[0] === 'string') {
          console.log('[getPhotoIds] Found photos (strings):', data.photos.length);
          // debugLogBox(`getPhotoIds: photos array strings (${data.photos.length})`);  // Rimosso per pulizia log
          return data.photos;
        }
      }
      // PrioritÃ  4: estrai da results (se Ã¨ array di oggetti, estrai filename/photo_id)
      const resultsIds = [];
      if (Array.isArray(data.results)) {
        data.results.forEach(item => {
          const pid = item.photo_id || item.photoId || item.r2_key || item.display_name || item.filename;
          if (pid) {
            let normalized = String(pid).replace("originals/", "").replace("thumbs/", "").replace("wm/", "");
            if (normalized.startsWith("/")) normalized = normalized.substring(1);
            if (normalized && !resultsIds.includes(normalized)) {
              resultsIds.push(normalized);
            }
          }
        });
      }
      if (Array.isArray(data.matches)) {
        data.matches.forEach(item => {
          const pid = item.photo_id || item.photoId || item.r2_key || item.display_name || item.filename;
          if (pid) {
            let normalized = String(pid).replace("originals/", "").replace("thumbs/", "").replace("wm/", "");
            if (normalized.startsWith("/")) normalized = normalized.substring(1);
            if (normalized && !resultsIds.includes(normalized)) {
              resultsIds.push(normalized);
            }
          }
        });
      }
      if (resultsIds.length > 0) {
        // debugLogBox(`getPhotoIds: extracted from results/matches (${resultsIds.length})`);  // Rimosso per pulizia log
        return [...new Set(resultsIds.filter(Boolean))];
      }
      // debugLogBox('getPhotoIds: NO PHOTO IDS FOUND');  // Rimosso per pulizia log
      return [];
    }
    
    function normalizePhotos(resp) {
      // Se resp Ã¨ giÃ  un array, ritorna direttamente
      if (Array.isArray(resp)) {
        // debugLogBox(`normalizePhotos: array (${resp.length})`);  // Rimosso per pulizia log
        return resp;
      }
      // Se resp ha campo items (nuovo formato)
      if (resp && Array.isArray(resp.items)) {
        // debugLogBox(`normalizePhotos: resp.items (${resp.items.length})`);  // Rimosso per pulizia log
        return resp.items;
      }
      // Se resp ha campo photos (retrocompatibilitÃ )
      if (resp && Array.isArray(resp.photos)) {
        // debugLogBox(`normalizePhotos: resp.photos (${resp.photos.length})`);  // Rimosso per pulizia log
        return resp.photos;
      }
      // Se resp ha campo results
      if (resp && Array.isArray(resp.results)) {
        // debugLogBox(`normalizePhotos: resp.results (${resp.results.length})`);  // Rimosso per pulizia log
        return resp.results;
      }
      // debugLogBox('normalizePhotos: NO PHOTOS FOUND');  // Rimosso per pulizia log
      return [];
    }
    
    // Funzione helper per costruire URL diretti (fallback se /api/photos fallisce)
    function buildDirectPhotoUrls(photoIds, baseUrl = '') {
      return photoIds.map(photoId => {
        const encodedId = encodeURIComponent(photoId);
        const thumbUrl = baseUrl ? `${baseUrl}/thumbs/${encodedId}` : `/photo/${encodedId}?variant=thumb`;
        const wmUrl = baseUrl ? `${baseUrl}/wm/${encodedId}` : `/photo/${encodedId}?variant=wm`;
        return {
          id: photoId,
          photo_id: photoId,
          filename: photoId,
          thumb_url: thumbUrl,
          wm_url: wmUrl,
          direct_thumb_url: thumbUrl,
          direct_wm_url: wmUrl
        };
      });
    }
    
    // Funzioni matching
    async function matchPhotos() {
      // Guardia: blocca se siamo in flusso post-pagamento
      if (IS_STRIPE_SUCCESS_FLOW) {
        console.log('[StripeSuccess] Blocked matchPhotos() - post-payment flow active');
        return;
      }
      
      // IMPORTANTISSIMO: reset stati all'inizio di ogni nuovo selfie
      photosReady = false;
      photosFailed = false;
      
      // DEBUG: mostra sempre START
      updateMinimalDebug('START', undefined, '-', undefined, '');
      // debugLogBox('match_selfie: START');  // Rimosso per pulizia log
      
      if(!capturedBlob) {
        const errorMsg = "capturedBlob Ã¨ null! Non Ã¨ stato selezionato nessun selfie.";
        debugError(errorMsg);
        debugLogBox(`match_selfie ERROR: ${errorMsg}`);
        updateMinimalDebug('ERROR: no blob', 0, '-', undefined, '');
        console.error("[CONFIRM_FLOW]", errorMsg);
          // FIX: mostra errore REALE in rosso, non generico
          const langLoading = document.getElementById('langLoading');
          const langErrorBox = document.getElementById('langErrorBox');
          if(langLoading) langLoading.style.display = 'none';
          if(langErrorBox) {
            langErrorBox.style.display = 'block';
            const errorText = langErrorBox.querySelector('.lang-error-text');
            if (errorText) {
              errorText.innerHTML = `<span style="color: #ff4444; font-weight: bold;">Errore: ${httpErrorMsg}</span>`;
            }
          }
          photosReady = false;
          photosFailed = true;
          return;
      }

      // Mostra stato "Uploading selfie..."
      debugLog("Uploading selfie...");
      // debugLogBox('match_selfie: Uploading...');  // Rimosso per pulizia log
      const langLoading = document.getElementById('langLoading');
      const langLoadingText = document.getElementById('langLoadingText');
      if(langLoadingText) langLoadingText.textContent = 'Caricamento selfie...';
      
      try {
        const matchStartTime = Date.now();
        debugLog("Inizio matchPhotos: invio selfie al server...");
        
        const fd = new FormData();
        fd.append("selfie", capturedBlob, "selfie.jpg");
        
        // Simula progress durante upload (XMLHttpRequest per avere progress reale)
        const xhr = new XMLHttpRequest();
        
        // Promise per gestire la risposta
        const uploadPromise = new Promise((resolve, reject) => {
          xhr.upload.addEventListener('progress', (e) => {
            if(e.lengthComputable) {
              const percent = Math.round((e.loaded / e.total) * 100);
              debugLog(`Upload progress: ${percent}%`);
            }
          });
          
          xhr.addEventListener('load', () => {
            if(xhr.status >= 200 && xhr.status < 300) {
              resolve(xhr);
            } else {
              const error = new Error(`HTTP ${xhr.status}: ${xhr.statusText}`);
              error.status = xhr.status;
              error.statusText = xhr.statusText;
              error.responseText = xhr.responseText;
              reject(error);
            }
          });
          
          xhr.addEventListener('error', (e) => {
            const error = new Error('Network error');
            error.type = 'network';
            reject(error);
          });
          
          xhr.addEventListener('timeout', () => {
            const error = new Error('Request timeout');
            error.type = 'timeout';
            reject(error);
          });
          
          xhr.addEventListener('abort', () => {
            const error = new Error('Upload aborted');
            error.type = 'abort';
            reject(error);
          });
          
          xhr.timeout = 120000;
          
          let url = '/match_selfie?top_k_faces=120';
          if(userEmail) {
            url += `&email=${encodeURIComponent(userEmail)}`;
          }
          
          xhr.open('POST', url);
          xhr.send(fd);
        });
        
        await uploadPromise;
        
        const matchEndTime = Date.now();
        const matchDuration = matchEndTime - matchStartTime;
        const res = xhr;
        
        // DEBUG: mostra sempre HTTP status
        debugLog(`match_selfie: ${res.status} in ${matchDuration}ms`);
        // debugLogBox(`match_selfie: HTTP ${res.status} in ${matchDuration}ms`);  // Rimosso per pulizia log
        updateMinimalDebug(`HTTP ${res.status}`, undefined, '-', undefined, '');
        
        // Controlla se la risposta Ã¨ OK
        if(res.status < 200 || res.status >= 300) {
          const httpErrorMsg = `Errore HTTP: ${res.status} ${res.statusText}`;
          debugLogBox(`match_selfie ERROR: ${httpErrorMsg}`);
          updateMinimalDebug(`ERROR ${res.status}`, 0, '-', undefined, '');
          const errorMsg = `Errore HTTP: ${res.status} ${res.statusText}`;
          debugError({ status: res.status, statusText: res.statusText, responseText: res.responseText });
          console.error("[CONFIRM_FLOW] âŒ", errorMsg);
          
          photosReady = false;
          photosFailed = true;
          photosSearchPromise = null;
          
          // Mostra errore in pagina
          if(langLoadingText) langLoadingText.textContent = `Errore: ${res.status}`;
          return;
        }
        
        // Verifica che la risposta non sia vuota
        if(!res.responseText || res.responseText.trim() === '') {
          const errorMsg = 'Risposta vuota dal server';
          debugError(errorMsg);
          throw new Error(errorMsg);
        }
        
        let data;
        try {
          data = JSON.parse(res.responseText);
          // DEBUG: stampa risposta COMPLETA in console
          console.log('[MATCH_SELFIE] Full response:', JSON.stringify(data, null, 2));
          debugLog(`JSON keys: ${Object.keys(data).join(', ')}`);
          // DEBUG: stampa risposta grezza (rimosso per pulizia log)
          // debugLogBox(`match_selfie response keys: ${Object.keys(data).join(', ')}`);
          // debugLogBox(`match_selfie response: ${JSON.stringify(data).substring(0, 500)}`);
        } catch(parseError) {
          // DEBUG: stampa primi 200 caratteri della response text se JSON parse fallisce
          const responsePreview = res.responseText ? res.responseText.substring(0, 200) : 'empty response';
          const errorMsg = `Invalid JSON: ${parseError.message}`;
          debugError({ parseError, responsePreview });
          debugLogBox(`match_selfie ERROR: ${errorMsg}`);
          debugLogBox(`Response preview (first 200 chars): ${responsePreview}`);
          updateMinimalDebug(`ERROR: JSON parse`, 0, '-', undefined, '');
          throw new Error(errorMsg);
        }
        
        // Usa funzione robusta getPhotoIds() - estrae da qualsiasi chiave: ids, photo_ids, photos, matched_ids, results, matches
        const allIds = getPhotoIds(data);
        console.log('[MATCH_PHOTOS] Extracted photo_ids:', allIds);
        // debugLogBox(`photo_ids estratti: ${allIds.length} - ${allIds.slice(0, 3).join(', ')}${allIds.length > 3 ? '...' : ''}`);  // Rimosso per pulizia log
        
        // Log count ricevuto
        const receivedCount = data.count || data.matched_count || allIds.length;
        debugLog(`Count ricevuto: ${receivedCount}, photo_ids estratti: ${allIds.length}`);
        console.log(`[MATCH_PHOTOS] Count=${receivedCount}, photo_ids=${allIds.length}`);
        
        // IMPORTANTISSIMO: mostra "no photos found" SOLO se ids.length === 0
        if (allIds.length === 0) {
          const errorMsg = receivedCount > 0 
            ? "Foto trovate ma anteprime non caricabili. Riprova."
            : "Risposta inattesa: nessun photo_id trovato";
          debugError({ data, errorMsg, receivedCount });
          debugLogBox(`ERROR: ${errorMsg} (receivedCount=${receivedCount}, allIds.length=${allIds.length})`);
          updateMinimalDebug(`200 OK`, 0, '-', undefined, undefined);
          
          // Se count > 0 ma allIds vuoto, mostra bottone "Riprova caricamento"
          if (receivedCount > 0 && langErrorBox) {
            const errorText = langErrorBox.querySelector('.lang-error-text');
            if (errorText) {
              errorText.innerHTML = `${errorMsg}<br><button id="retryLoadBtn" style="margin-top:10px; padding:8px 16px; background:#6366f1; color:#fff; border:none; border-radius:8px; cursor:pointer;">Riprova caricamento</button>`;
              const retryBtn = document.getElementById('retryLoadBtn');
              if (retryBtn) {
                retryBtn.onclick = async () => {
                  debugLog("Riprova caricamento foto...");
                  if(langLoading) langLoading.style.display = 'flex';
                  if(langErrorBox) langErrorBox.style.display = 'none';
                  
                  try {
                    const photosRes = await fetch('/api/photos', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ variant: 'thumb', photo_ids: allIds })
                    });
                    if (photosRes.ok) {
                      const photosData = await photosRes.json();
                      if (photosData.photos && photosData.photos.length > 0) {
                        // Ricarica con successo
                        location.reload();
                      }
                    }
                  } catch (e) {
                    debugError(e);
                  }
                };
              }
            }
          } else if (langLoadingText) {
            langLoadingText.textContent = errorMsg;
          }
          
          photosReady = false;
          photosFailed = true;
          photosSearchPromise = null;
          return;
        }
        
        // IMPORTANTISSIMO: chiama /api/photos SOLO se allIds.length > 0 (giÃ  verificato sopra)
        // Carica URL delle foto usando POST /api/photos
        debugLog("Chiamata POST /api/photos...");
        const photosStartTime = Date.now();
        
        let photosData;
        let useFallback = false;
        try {
          const photosRes = await fetch('/api/photos', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              variant: 'thumb',
              ids: allIds  // Usa 'ids' invece di 'photo_ids' per compatibilitÃ 
            })
          });
          
          const photosEndTime = Date.now();
          const photosDuration = photosEndTime - photosStartTime;
          
          if (!photosRes.ok) {
            const errorMsg = `HTTP ${photosRes.status}: ${photosRes.statusText}`;
            debugLogBox(`api/photos ERROR: ${errorMsg} -> using fallback direct URLs`);
            console.warn(`[API_PHOTOS] Request failed (${photosRes.status}), using fallback`);
            useFallback = true;
          } else {
            photosData = await photosRes.json();
            const normalizedPhotos = normalizePhotos(photosData);
            debugLog(`api/photos POST: ${photosRes.status}, items=${normalizedPhotos.length} in ${photosDuration}ms`);
            console.log(`[API_PHOTOS] Success: ${normalizedPhotos.length} items`);
            // debugLogBox(`api/photos ok: ${normalizedPhotos.length} items`);  // Rimosso per pulizia log
            
            // Verifica che la risposta sia valida
            if (!photosData.ok || normalizedPhotos.length === 0) {
              debugLogBox(`api/photos empty response -> using fallback`);
              console.warn(`[API_PHOTOS] Empty or invalid response, using fallback`);
              useFallback = true;
            } else {
              // DEBUG: stampa risposta grezza (rimosso per pulizia log)
              // debugLogBox(`api/photos response keys: ${Object.keys(photosData).join(', ')}`);
              updateMinimalDebug(`200 OK`, allIds.length, `${photosRes.status} OK`, normalizedPhotos.length, undefined);
            }
          }
        } catch (photosError) {
          const errorStatus = photosError?.status || (photosError instanceof Response ? photosError.status : null);
          debugError({ photosError, status: errorStatus });
          debugLogBox(`api/photos exception -> using fallback: ${photosError.message}`);
          console.warn(`[API_PHOTOS] Exception: ${photosError.message}, using fallback`);
          useFallback = true;
        }
        
        // FALLBACK: se /api/photos fallisce, costruisci URL diretti
        if (useFallback) {
          debugLogBox(`api/photos failed -> fallback direct urls`);
          console.log(`[API_PHOTOS] Building fallback URLs for ${allIds.length} photos`);
          // Costruisci URL diretti usando base URL se disponibile (da window o env)
          const baseUrl = window.R2_PUBLIC_BASE_URL || '';
          const fallbackPhotos = buildDirectPhotoUrls(allIds, baseUrl);
          photosData = {
            ok: true,
            items: fallbackPhotos,
            photos: fallbackPhotos  // retrocompatibilitÃ 
          };
          updateMinimalDebug(`200 OK`, allIds.length, `FALLBACK`, fallbackPhotos.length, undefined);
        }
        
        // Converti in formato allPhotos usando normalizePhotos()
        const normalizedApiPhotos = normalizePhotos(photosData);
        const photos = data.results || data.matches || [];
        let newPhotos = [];
        
        // Crea mappa per lookup veloce: photo_id -> { thumb_url, wm_url }
        const photosMap = new Map(normalizedApiPhotos.map(p => {
          const pid = p.photo_id || p.filename || p.id || p.photoId;
          return [pid, p];
        }));
        
        if (photos.length > 0) {
          // Usa i dati da /api/photos per thumb_url e wm_url
          newPhotos = photos.map(p => {
            const photoId = p.photo_id || p.photoId || p.r2_key || p.display_name;
            const apiPhoto = photosMap.get(photoId);
            // Usa thumb_url e wm_url dalla risposta (sempre presenti)
            const thumbUrl = apiPhoto?.thumb_url || apiPhoto?.direct_thumb_url || apiPhoto?.direct_wm_url || apiPhoto?.direct_url || apiPhoto?.url || null;
            const wmUrl = apiPhoto?.wm_url || apiPhoto?.direct_wm_url || apiPhoto?.direct_url || apiPhoto?.url || null;
            if (!thumbUrl) {
              debugLogBox(`WARNING: No thumb_url for photo_id=${photoId}`);
            }
            return {
              photo_id: photoId,
              score: p.score || 0,
              has_face: true,
              paid: false,
              thumb_url: thumbUrl,  // griglia usa questo
              wm_url: wmUrl,        // lightbox usa questo
              paid_url: null
            };
          });
        } else {
          // Se non abbiamo oggetti completi, crea da allIds usando dati da /api/photos
          newPhotos = allIds.map(photoId => {
            const apiPhoto = photosMap.get(photoId);
            // Usa thumb_url e wm_url dalla risposta (sempre presenti)
            const thumbUrl = apiPhoto?.thumb_url || apiPhoto?.direct_thumb_url || apiPhoto?.direct_wm_url || apiPhoto?.direct_url || apiPhoto?.url || null;
            const wmUrl = apiPhoto?.wm_url || apiPhoto?.direct_wm_url || apiPhoto?.direct_url || apiPhoto?.url || null;
            if (!thumbUrl) {
              debugLogBox(`WARNING: No thumb_url for photo_id=${photoId}`);
            }
            return {
              photo_id: photoId,
              score: 0,
              has_face: true,
              paid: false,
              thumb_url: thumbUrl,  // griglia usa questo
              wm_url: wmUrl,        // lightbox usa questo
              paid_url: null
            };
          });
        }
        
        // debugLogBox(`newPhotos creati: ${newPhotos.length}, con URL: ${newPhotos.filter(p => p.thumb_url).length}`);  // Rimosso per pulizia log
        
        debugLog(`Trovate ${newPhotos.length} foto, rendering...`);
        
        // FIX: NON mostrare "nessuna foto" se allIds.length > 0
        // Mostra foto se allIds.length > 0, indipendentemente da data.ok
        if(allIds.length > 0) {
          
          // Se stiamo aggiungendo un membro famiglia, fai merge invece di replace
          if(isAddingFamilyMember) {
            // Salva le foto esistenti prima del merge per identificare quelle nuove
            const existingPhotoIds = new Set(albumPhotosAll.map(p => p.photo_id || p.id || p.url || p.filename));
            albumPhotosAll = mergeUnique(albumPhotosAll, newPhotos);
            allPhotos = albumPhotosAll;
            
            // Identifica le foto nuove aggiunte
            const newPhotoIds = allPhotos
              .map(p => p.photo_id || p.id || p.url || p.filename)
              .filter(id => id && !existingPhotoIds.has(id));
            
            // Salva le foto nuove in una variabile temporanea per associarle al membro
            window._lastMemberPhotos = newPhotoIds;
            
            console.log(`[CONFIRM_FLOW] Merge completato: ${albumPhotosAll.length} foto totali (${newPhotos.length} nuove)`);
          } else {
            // Primo selfie: imposta allPhotos direttamente con newPhotos (come prima)
            allPhotos = newPhotos;
            albumPhotosAll = newPhotos;
            
            // Crea o aggiorna main member per retrocompatibilitÃ 
            const confirmPreview = document.getElementById('confirmPreview');
            const mainPersonAvatar = document.getElementById('mainPersonAvatar');
            const avatarDataUrl = confirmPreview?.src || mainPersonAvatar?.src;
            
            // Estrai le chiavi delle foto
            const photoKeys = newPhotos.map(p => p.photo_id || p.id || p.url || p.filename).filter(Boolean);
            
            // Crea o aggiorna main member
            if(members.length === 0 || !members[0]) {
              members[0] = {
                id: 'main_' + Date.now(),
                avatarDataUrl: avatarDataUrl || null,
                photoKeys: photoKeys
              };
            } else {
              // Aggiorna main member mantenendo le foto esistenti (merge)
              const existingKeys = new Set(members[0].photoKeys || []);
              const newKeys = photoKeys.filter(k => !existingKeys.has(k));
              members[0].photoKeys = [...(members[0].photoKeys || []), ...newKeys];
              if(avatarDataUrl) {
                members[0].avatarDataUrl = avatarDataUrl;
              }
            }
            
            window._lastMemberPhotos = null;
          }
          
          photosLoadedCount = 0;
          paidPhotos = [];
          
          // Imposta stato pronto
          photosReady = true;
          photosFailed = false;
          photosSearchPromise = null;
          
          debugLog("âœ… Match completato con successo");
          // debugLogBox(`âœ… Match completato: ${newPhotos.length} foto, allIds=${allIds.length}`);  // Rimosso per pulizia log
          
          // Aggiorna minimal debug box con successo
          updateMinimalDebug(`200 OK`, allIds.length, `200 OK`, newPhotos.length, undefined);
        } else {
          // Solo se davvero non ci sono foto, imposta stato errore
          // FIX: mostra errore reale, NON "nessuna foto trovata" generico
          const errorMsg = `Errore caricamento: ${data.message || data.detail || 'Nessun photo_id trovato nella risposta'}`;
          console.warn(`[CONFIRM_FLOW] âš ï¸ ${errorMsg}`);
          debugLogBox(`ERROR: ${errorMsg}`);
          
          // Mostra errore reale
          const langLoading = document.getElementById('langLoading');
          const langErrorBox = document.getElementById('langErrorBox');
          const langLoadingText = document.getElementById('langLoadingText');
          if(langLoading) langLoading.style.display = 'none';
          if(langErrorBox) {
            langErrorBox.style.display = 'block';
            const errorText = langErrorBox.querySelector('.lang-error-text');
            if (errorText) {
              errorText.innerHTML = `${errorMsg}<br><button id="retryMatchBtn" style="margin-top:10px; padding:8px 16px; background:#6366f1; color:#fff; border:none; border-radius:8px; cursor:pointer;">Riprova</button>`;
              const retryBtn = document.getElementById('retryMatchBtn');
              if (retryBtn) {
                retryBtn.onclick = () => location.reload();
              }
            }
          } else if (langLoadingText) {
            langLoadingText.textContent = errorMsg;
          }
          
          photosReady = false;
          photosFailed = true;
          photosSearchPromise = null;
          
          // Controlla se ci sono foto giÃ  acquistate da mostrare (stateless: disabilitato)
          if(false && userEmail) {
            // Mostra schermata subito, fetch in background
            showScreen('album');
            setTimeout(async () => {
            try {
                const paidData = await fetchUserPhotos(userEmail);
              
              if(paidData && paidData.ok && paidData.paid_photos && paidData.paid_photos.length > 0) {
                // Ci sono foto pagate - mostrale nell'album
                paidPhotos = paidData.paid_photos;
                allPhotos = paidData.paid_photos.map(photoId => ({
                  photo_id: photoId,
                  score: 0,
                  has_face: true,
                  paid: true
                }));
                
                photosLoadedCount = 0;
                
                // Nascondi upload status
                if(uploadStatus) uploadStatus.classList.remove('active');
                if(captureBtn) {
                  captureBtn.disabled = false;
                  captureBtn.style.opacity = '1';
                }
                
                // Album giÃ  mostrato sopra, aggiorna carrello
                updateCart();
                await displayPhotos();
                showStickyOfferBar(allPhotos.length);
              } else {
                console.log('No paid photos found');
              }
            } catch(e) {
              console.error('Errore caricamento foto pagate:', e);
              if(e.message && e.message.includes('timeout')) {
                alert('Request timeout. Please check your connection and try again.');
              } else {
                alert('Error loading photos. Please try again.');
            }
            }
          }, 0);
          }
          
          // Nessuna foto trovata e nessuna foto pagata
          // Gestisci nella language screen (NON tornare a selfie screen)
          photosReady = false;
          photosFailed = true;
          
          // Nascondi langLoading e mostra langErrorBox
          if(langLoading) langLoading.style.display = 'none';
          if(langErrorBox) langErrorBox.style.display = 'block';
        }
      } catch(err) {
        debugError(err);
        console.error("[CONFIRM_FLOW] Errore nel caricamento foto:", err);
        console.error("[CONFIRM_FLOW] Stack trace:", err.stack);
        console.error("[CONFIRM_FLOW] Tipo errore:", err.name, "Messaggio:", err.message);
        console.error("[CONFIRM_FLOW] Error type:", err.type, "Status:", err.status);
        
        // Mostra errore in pagina
        const langLoading = document.getElementById('langLoading');
        const langErrorBox = document.getElementById('langErrorBox');
        const langLoadingText = document.getElementById('langLoadingText');
        if(langLoading) langLoading.style.display = 'none';
        if(langErrorBox) {
          langErrorBox.style.display = 'block';
          const errorText = langErrorBox.querySelector('.lang-error-text');
          if(errorText) {
            errorText.textContent = err.message || 'Errore durante la ricerca foto';
          }
        }
        if(langLoadingText) langLoadingText.textContent = 'Errore';
        
        // Imposta stato errore
        photosReady = false;
        photosFailed = true;
        photosSearchPromise = null;
      }
    }

    // Guardia anti-doppio fetch per /user/photos
    let photosFetchInFlight = null;
    
    // Funzione centralizzata per fetch /user/photos con timeout e guardia anti-doppio
    async function fetchUserPhotos(email, timeoutMs = 15000) {
      if(!email) {
        console.error("fetchUserPhotos: email is required");
        return null;
      }
      
      // Guardia anti-doppio: se c'Ã¨ giÃ  una fetch in corso, ritorna quella
      if(photosFetchInFlight) {
        console.log("fetchUserPhotos: already in flight, returning existing promise");
        return photosFetchInFlight;
      }
      
      // Crea AbortController per timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        controller.abort();
      }, timeoutMs);
      
      // Crea promise con guardia
      photosFetchInFlight = (async () => {
        try {
          console.log(`fetchUserPhotos: fetching for ${email}`);
          const res = await fetch(`/user/photos?email=${encodeURIComponent(email)}`, {
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if(!res.ok) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
          
          const data = await res.json();
          console.log(`fetchUserPhotos: success for ${email}`);
          return data;
        } catch(e) {
          clearTimeout(timeoutId);
          if(e.name === 'AbortError') {
            console.error(`fetchUserPhotos: timeout after ${timeoutMs}ms for ${email}`);
            throw new Error(`Request timeout after ${timeoutMs}ms. Please try again.`);
          }
          console.error(`fetchUserPhotos: error for ${email}:`, e);
          throw e;
        } finally {
          // Reset guardia dopo un breve delay per evitare race conditions
          setTimeout(() => {
            photosFetchInFlight = null;
          }, 100);
        }
      })();
      
      return photosFetchInFlight;
    }

    // Intersection Observer per lazy loading
    let imageObserver = null;
    
    function initImageObserver() {
      if(imageObserver) {
        imageObserver.disconnect();
      }
      
      imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if(entry.isIntersecting) {
            const img = entry.target;
            const photoId = img.dataset.photoId;
            const index = parseInt(img.dataset.index);
            
            // Carica l'immagine solo quando entra nel viewport
            if(!img.dataset.loaded) {
              img.dataset.loaded = 'true';
              const imgElement = new Image();
              
              imgElement.onload = () => {
                img.src = imgElement.src;
                img.classList.add('loaded');
                // Rimuovi skeleton
                const skeleton = img.parentElement.querySelector('.photo-skeleton');
                if(skeleton) skeleton.remove();
              };
              
              // Retry logic per 404 (thumb non ancora generato)
              let retryCount = 0;
              const maxRetries = 3;
              const retryDelay = 500; // ms
              
              const tryLoadLazyImage = () => {
                // Usa thumb_url se disponibile (precomputato), altrimenti fallback
                const photoObj = allPhotos.find(p => p.photo_id === photoId);
                let photoUrl = photoObj?.thumb_url || `/photo/${encodeURIComponent(photoId)}?variant=thumb`;
                imgElement.src = photoUrl;
              };
              
              imgElement.onerror = () => {
                retryCount++;
                if(retryCount < maxRetries) {
                  // Retry dopo delay (thumb potrebbe essere in generazione)
                  console.log(`[RETRY] Thumb not ready for ${photoId}, retrying (${retryCount}/${maxRetries})...`);
                  setTimeout(tryLoadLazyImage, retryDelay * retryCount); // Backoff esponenziale
                } else {
                  // Max retries raggiunto: rimuovi completamente la card dal DOM
                  console.error('Thumb not ready after retries, removing card:', photoId);
                  const cardDiv = img.closest('.album-photo');
                  if(cardDiv && cardDiv.parentNode) {
                    imageObserver.unobserve(img);
                    cardDiv.parentNode.removeChild(cardDiv);
                  }
                }
              };
              
              tryLoadLazyImage();
            }
            
            imageObserver.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px' // Inizia a caricare 50px prima che entri nel viewport
      });
    }
    
    function checkAllPhotosLoaded() {
      photosLoadedCount++;
      // Quando tutte le prime immagini sono caricate, nascondi overlay
      const preloadCount = Math.min(9, allPhotos.length);
      if(photosLoadedCount >= preloadCount) {
        const loadingOverlay = document.getElementById('albumLoadingOverlay');
        if(loadingOverlay) {
          loadingOverlay.classList.remove('active');
        }
        enableAlbumInteractions();
      }
    }
    
    function disableAlbumInteractions() {
      // Disabilita SOLO i pulsanti, NON lo scroll
      // NON bloccare pointer-events sull'albumScreen per permettere lo scroll
      
      // Disabilita pulsanti specifici
      const albumCartBtn = document.getElementById('albumCartBtn');
      const albumBackBtn = document.getElementById('albumBackBtn');
      const myContentTab = document.getElementById('myContentTab');
      const pricesTab = document.getElementById('pricesTab');
      if(albumCartBtn) {
        albumCartBtn.style.pointerEvents = 'none';
        albumCartBtn.style.opacity = '0.5';
      }
      if(albumBackBtn) {
        albumBackBtn.style.pointerEvents = 'none';
        albumBackBtn.style.opacity = '0.5';
      }
      if(myContentTab) {
        myContentTab.style.pointerEvents = 'none';
        myContentTab.style.opacity = '0.5';
      }
      if(pricesTab) {
        pricesTab.style.pointerEvents = 'none';
        pricesTab.style.opacity = '0.5';
      }
      
      // Disabilita click sulle foto durante il caricamento
      const photos = albumGrid.querySelectorAll('.album-photo');
      photos.forEach(photo => {
        photo.style.pointerEvents = 'none';
      });
    }
    
    function enableAlbumInteractions() {
      // Riabilita pulsanti
      const albumCartBtn = document.getElementById('albumCartBtn');
      const albumBackBtn = document.getElementById('albumBackBtn');
      const myContentTab = document.getElementById('myContentTab');
      const pricesTab = document.getElementById('pricesTab');
      if(albumCartBtn) {
        albumCartBtn.style.pointerEvents = 'auto';
        albumCartBtn.style.opacity = '1';
      }
      if(albumBackBtn) {
        albumBackBtn.style.pointerEvents = 'auto';
        albumBackBtn.style.opacity = '1';
      }
      if(myContentTab) {
        myContentTab.style.pointerEvents = 'auto';
        myContentTab.style.opacity = '1';
      }
      if(pricesTab) {
        pricesTab.style.pointerEvents = 'auto';
        pricesTab.style.opacity = '1';
      }
      
      // Riabilita click sulle foto
      const photos = albumGrid.querySelectorAll('.album-photo');
      photos.forEach(photo => {
        photo.style.pointerEvents = 'auto';
      });
    }
    
    // Funzione semplificata per caricare foto pagate
    async function loadPaidPhotos() {
      if(!userEmail) {
        // Stateless: userEmail non persistente
      }
      if(!userEmail) return paidPhotos;
      
      try {
        const res = await fetch(`/user/photos?email=${encodeURIComponent(userEmail)}`);
      const data = await res.json();
        if(data.ok) {
          paidPhotos = [];
          if(data.paid_photos) paidPhotos = [...data.paid_photos];
          if(data.found_photos) {
            const paidFromFound = data.found_photos
              .filter(p => p.status === 'paid')
              .map(p => p.photo_id);
            paidPhotos = [...new Set([...paidPhotos, ...paidFromFound])];
          }
        }
      } catch(e) {
        console.error("Error loading paid photos:", e);
      }
      return paidPhotos;
    }
    
    async function displayPhotos() {
      // Carrello sempre vuoto all'inizio (non persistente, si svuota ad ogni refresh)
      initCart();
      // Reset photosLoaded all'inizio
      photosLoaded = false;
      
      if(!allPhotos || allPhotos.length === 0) {
        console.warn("displayPhotos chiamato ma non ci sono foto!");
        // NON mostrare alert, NON chiamare showSelfieError, NON avviare camera
        // L'utente puÃ² tornare al selfie manualmente se vuole
        return;
      }

      // Carica foto pagate prima di renderizzare
      await loadPaidPhotos();
      
      // NON rimuovere le foto pagate dall'album - le mostriamo con badge "Acquistata"
      // Le foto pagate saranno visibili ma non selezionabili per il carrello
      const paidPhotoIdsSet = new Set(paidPhotos);
      const unpaidPhotos = allPhotos.filter(photo => !paidPhotoIdsSet.has(photo.photo_id));
      const paidCount = allPhotos.length - unpaidPhotos.length;
      
      if(paidCount > 0) {
        console.log(`Mostrando ${paidCount} foto pagate nell'album con badge "Acquistata"`);
      }
      
      const loadingOverlay = document.getElementById('albumLoadingOverlay');
      const loadingText = document.getElementById('albumLoadingText');
      
      // Reset counter
      photosLoadedCount = 0;
      
      // Mostra overlay di caricamento
      if(loadingOverlay) {
        loadingOverlay.classList.add('active');
        if(loadingText) loadingText.textContent = 'Loading photos...';
      }
      
      // Disabilita interazioni
      disableAlbumInteractions();
      
      albumGrid.innerHTML = '';
      
      // Lazy loading ottimizzato: preload delle prime foto visibili
      // Con ~10-12 foto per utente, non serve virtual scrolling
      const PRELOAD_COUNT = Math.min(6, allPhotos.length); // Preload prime 6 foto (quelle visibili subito)
      
      // Nascondi overlay dopo che le prime 6 foto sono caricate (per percepire velocitÃ )
      let firstPhotosLoaded = 0;
      const hideOverlayAfter = 6;
      
      // Renderizza tutte le foto (con lazy loading per quelle non visibili)
      allPhotos.forEach((photo, index) => {
        const div = document.createElement('div');
        div.className = 'album-photo';

        const img = document.createElement('img');
        img.dataset.photoId = photo.photo_id;
        img.dataset.index = index;
        img.alt = photo.photo_id;
        img.loading = 'lazy';
        img.decoding = 'async';
        
        // Skeleton loader
        const skeleton = document.createElement('div');
        skeleton.className = 'photo-skeleton';
        
        // Per le prime immagini visibili, carica subito con prioritÃ  alta
        if(index < PRELOAD_COUNT) {
          img.dataset.loaded = 'true';
          const imgElement = new Image();
          imgElement.onload = () => {
            img.src = imgElement.src;
            img.classList.add('loaded');
            skeleton.remove();
            firstPhotosLoaded++;
            
            // Nascondi overlay dopo le prime foto caricate (per percepire velocitÃ )
            if(firstPhotosLoaded >= hideOverlayAfter && loadingOverlay && loadingOverlay.classList.contains('active')) {
              loadingOverlay.classList.remove('active');
              enableAlbumInteractions();
            }
            
            checkAllPhotosLoaded();
          };
          // Retry logic per 404 (thumb non ancora generato)
          let retryCount = 0;
          const maxRetries = 3;
          const retryDelay = 500; // ms
          
          const tryLoadImage = () => {
            // Usa thumb_url se disponibile (precomputato, veloce), altrimenti fallback
            let photoUrl = photo.thumb_url || `/photo/${encodeURIComponent(photo.photo_id)}?variant=thumb`;
          
          // Per le prime 6 foto, usa fetchpriority per caricamento piÃ¹ veloce
          if(index < 6) {
            img.fetchPriority = 'high';
          }
          
          imgElement.src = photoUrl;
          };
          
          imgElement.onerror = () => {
            retryCount++;
            if(retryCount < maxRetries) {
              // Retry dopo delay (thumb potrebbe essere in generazione)
              console.log(`[RETRY] Thumb not ready for ${photo.photo_id}, retrying (${retryCount}/${maxRetries})...`);
              setTimeout(tryLoadImage, retryDelay * retryCount); // Backoff esponenziale
            } else {
              // Max retries raggiunto: rimuovi completamente la card dal DOM
              console.error('Thumb not ready after retries, removing card:', photo.photo_id);
              if(div && div.parentNode) {
                div.parentNode.removeChild(div);
              }
              firstPhotosLoaded++;
              checkAllPhotosLoaded();
            }
          };
          
          tryLoadImage();
        }
        
        // Aggiungi classe photo-card per stili
        div.classList.add('photo-card');
        div.dataset.photoId = photo.photo_id;
        
        // Se la foto Ã¨ pagata, mostra solo badge "Pagata"
        const isPaid = paidPhotos.includes(photo.photo_id) || photo.paid === true;
        if(isPaid) {
          // Assicurati che la foto sia in paidPhotos
          if(!paidPhotos.includes(photo.photo_id)) {
            paidPhotos.push(photo.photo_id);
          }
          // Badge "Pagata" pulito e piccolo in alto a sinistra
          const paidText = document.createElement('div');
          paidText.className = 'photo-paid-text';
          paidText.textContent = 'âœ“ Pagata';
          paidText.style.cssText = 'position: absolute; top: 10px; left: 10px; background: rgba(76, 175, 80, 0.9); color: white; padding: 6px 10px; border-radius: 8px; font-size: 12px; font-weight: 600; z-index: 10; pointer-events: none; box-shadow: 0 2px 4px rgba(0,0,0,0.2);';
          div.appendChild(paidText);
          div.classList.add('photo-paid');
        } else {
          // Icona "+" o "âœ“" verde in alto a destra solo per foto non pagate
          const addCartBtn = document.createElement('button');
          addCartBtn.className = 'add-to-cart-btn';
          addCartBtn.dataset.photoId = photo.photo_id;
          addCartBtn.type = 'button';
          addCartBtn.innerHTML = '<span class="btn-icon">+</span><span class="btn-check">âœ“</span>';
          
          // Verifica se la foto Ã¨ giÃ  nel carrello
          const isInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photo.photo_id);
          if(isInCart) {
            addCartBtn.classList.add('is-added');
            addCartBtn.setAttribute('aria-label', 'Rimuovi dal carrello');
            div.classList.add('selected'); // Aggiungi classe selected alla card
          } else {
            addCartBtn.setAttribute('aria-label', 'Aggiungi al carrello');
          }
          
          // Click sull'icona fa toggle add/remove SENZA aprire viewer
          // Feedback visivo immediato (ottimistico update) con animazione "pop"
          addCartBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const wasInCart = addCartBtn.classList.contains('is-added');
            
            // Aggiungi animazione "pop"
            addCartBtn.classList.add('pop');
            setTimeout(() => {
              addCartBtn.classList.remove('pop');
            }, 160);
            
            // Aggiorna immediatamente lo stato visivo (ottimistico)
            if(wasInCart) {
              addCartBtn.classList.remove('is-added');
              addCartBtn.setAttribute('aria-label', 'Aggiungi al carrello');
              div.classList.remove('selected'); // Rimuovi classe selected dalla card
            } else {
              addCartBtn.classList.add('is-added');
              addCartBtn.setAttribute('aria-label', 'Rimuovi dal carrello');
              div.classList.add('selected'); // Aggiungi classe selected alla card
            }
            
            try {
              if(wasInCart) {
                // Rimuovi dal carrello
                await removeFromCart(photo.photo_id);
              } else {
                // Aggiungi al carrello
                await addToCart(photo.photo_id);
              }
            } catch(err) {
              console.error('Error toggling cart:', err);
              // In caso di errore, ripristina lo stato visivo
              if(wasInCart) {
                addCartBtn.classList.add('is-added');
                addCartBtn.setAttribute('aria-label', 'Rimuovi dal carrello');
                div.classList.add('selected'); // Ripristina classe selected
              } else {
                addCartBtn.classList.remove('is-added');
                addCartBtn.setAttribute('aria-label', 'Aggiungi al carrello');
                div.classList.remove('selected'); // Rimuovi classe selected
              }
            }
          });
          
          div.appendChild(addCartBtn);
        }
        
        div.appendChild(skeleton);
        div.appendChild(img);
        
        // Click sull'immagine apre SOLO il viewer (non aggiunge al carrello)
        img.addEventListener('click', (e) => {
          e.stopPropagation();
          openLightbox(index);
        });
        
        // Blocca long-press e salvataggio su immagini pre-acquisto
        img.style.webkitTouchCallout = 'none';
        img.style.webkitUserSelect = 'none';
        img.style.userSelect = 'none';
        albumGrid.appendChild(div);
      });
      
      // Inizializza observer dopo che tutti gli elementi sono nel DOM
      setTimeout(() => {
        initImageObserver();
        // Osserva tutte le immagini non ancora caricate
        albumGrid.querySelectorAll('img:not([data-loaded="true"])').forEach(img => {
          imageObserver.observe(img);
        });
      }, 100);
      
      // Fallback: nascondi overlay dopo max 2 secondi se non Ã¨ giÃ  stato nascosto
      setTimeout(() => {
        if(loadingOverlay && loadingOverlay.classList.contains('active')) {
          loadingOverlay.classList.remove('active');
          enableAlbumInteractions();
        }
      }, 2000);
      
      // Aggiorna sticky bar e nudge bar
      bindStickyOfferClick();
      updateStickyAllOffer();
      updateNudgeBar();
      updateBottomPadding(); // Aggiorna padding dopo displayPhotos
      
      // Renderizza chip membri su mobile
      renderMemberChips();
    }

    function showStickyOfferBar(photoCount) {
      const stickyBar = document.getElementById('stickyOfferBar');
      const stickyFoundEl = document.getElementById('stickyOfferFoundText');
      const stickyCtaEl = document.getElementById('stickyOfferCtaText');
      const photoCountBanner = document.getElementById('albumPhotoCount');
      const photoCountNumber = document.getElementById('photoCountNumber');
      const albumScreen = document.getElementById('albumScreen');
      
      if(!stickyBar) {
        console.warn("Sticky offer bar non trovato");
        return;
      }
      
      // Verifica che lo schermo album sia attivo E le foto siano state renderizzate
      if(!albumScreen || !albumScreen.classList.contains('active')) {
        console.warn("Schermo album non attivo, aspetto...");
        setTimeout(() => showStickyOfferBar(photoCount), 200);
        return;
      }
      
      // Verifica che le foto siano state caricate
      if(!photosLoaded) {
        console.warn("Foto non ancora caricate, aspetto...");
        setTimeout(() => showStickyOfferBar(photoCount), 200);
        return;
      }
      
      // Mostra banner conteggio foto sopra la griglia
      if(photoCountBanner && photoCountNumber) {
        photoCountNumber.textContent = photoCount;
        const foundText = t('album_photo_count', { count: photoCount });
        photoCountBanner.innerHTML = foundText;
        photoCountBanner.style.display = 'block';
      }
      
      // Calcola prezzo
      const priceCents = calculatePrice(photoCount);
      const priceEuros = (priceCents / 100).toFixed(2);
      
      // Aggiorna testo "X foto trovate"
      if(stickyFoundEl) {
        stickyFoundEl.textContent = tr('sticky_found_photos', { count: String(photoCount) });
      }
      
      // Aggiorna testo "Acquistale tutte a â‚¬X"
      if(stickyCtaEl) {
        const priceStr = priceEuros.replace(/â‚¬/g, '').trim();
        stickyCtaEl.textContent = tr('sticky_buy_all_for', { price: priceStr });
      }
      
      // I testi sono giÃ  stati aggiornati sopra con tr()
      
      // Pulsante chiudi rimosso - il banner rimane sempre visibile
      
      // Mostra banner con animazione
      stickyBar.style.display = 'flex';
      stickyBar.classList.add('active');
      
      // Mostra countdown banner se ci sono foto pagate
      showPaidCountdownBanner();
    }
    
    function showPaidCountdownBanner() {
      const countdownBanner = document.getElementById('paidCountdownBanner');
      const countdownText = document.getElementById('paidCountdownText');
      const countdownDays = document.getElementById('paidCountdownDays');
      
      if(!countdownBanner || paidPhotos.length === 0) {
      return;
    }

      // Calcola giorni rimanenti (30 giorni dalla data di pagamento)
      // Per ora usiamo una stima: assumiamo che le foto siano state pagate oggi
      // In futuro potremmo recuperare la data di scadenza dal server
      const daysRemaining = 30; // Default, in futuro recuperare da server
      
      if(daysRemaining > 0) {
        // Traduci il messaggio
        let message = "";
        if(currentLang === 'en') {
          message = `Your paid photos will expire in <strong>${daysRemaining}</strong> days`;
        } else if(currentLang === 'it') {
          message = `Le tue foto pagate scadranno tra <strong>${daysRemaining}</strong> giorni`;
        } else if(currentLang === 'fr') {
          message = `Vos photos payÃ©es expireront dans <strong>${daysRemaining}</strong> jours`;
        } else if(currentLang === 'de') {
          message = `Ihre bezahlten Fotos laufen in <strong>${daysRemaining}</strong> Tagen ab`;
        } else if(currentLang === 'es') {
          message = `Tus fotos pagadas expirarÃ¡n en <strong>${daysRemaining}</strong> dÃ­as`;
        } else {
          message = `Le tue foto pagate scadranno tra <strong>${daysRemaining}</strong> giorni`;
        }
        
        if(countdownText) {
          countdownText.innerHTML = message;
        }
        if(countdownDays) {
          countdownDays.textContent = daysRemaining;
        }
        
        // Mostra banner con animazione
        setTimeout(() => {
          countdownBanner.classList.add('show');
        }, 500);
      }
    }

    function openLightbox(index) {
      // Previeni l'apertura se le foto stanno ancora caricando
      const loadingOverlay = document.getElementById('albumLoadingOverlay');
      if(loadingOverlay && loadingOverlay.classList.contains('active')) {
        return; // Non fare nulla se sta caricando
      }
      
      currentPhotoIndex = index;
      const photo = allPhotos[index];
      
      // Verifica che lightboxImage e photoLightbox esistano
      if(!lightboxImage || !photoLightbox) {
        console.error('Lightbox elements not found');
        return;
      }
      
      // Preload dell'immagine prima di mostrarla
      const img = new Image();
      img.onload = () => {
        if(lightboxImage) {
          lightboxImage.src = img.src;
        }
        updateLightboxCounter();
        if(photoLightbox) {
          photoLightbox.classList.add('active');
        }
      };
      img.onerror = () => {
        alert('Connection error. Check your internet connection and try again.');
      };
      
      // Usa wm_url per foto non pagate, paid_url per foto pagate
      const isPaid = paidPhotos.includes(photo.photo_id) || photo.paid === true;
      let photoUrl;
      if(isPaid) {
        // Foto pagata: usa paid_url se disponibile, altrimenti costruisci URL
        photoUrl = photo.paid_url || `/photo/${encodeURIComponent(photo.photo_id)}?paid=true`;
        if(userEmail) {
        photoUrl += `&email=${encodeURIComponent(userEmail)}`;
        }
      } else {
        // Foto non pagata: usa wm_url (precomputato, veloce)
        photoUrl = photo.wm_url || `/photo/${encodeURIComponent(photo.photo_id)}?variant=wm`;
      }
      img.src = photoUrl;
      
      // Mostra/nascondi frecce: solo su desktop, mai su mobile/tablet
      const prevBtn = document.getElementById('lightboxPrev');
      const nextBtn = document.getElementById('lightboxNext');
      const downloadBtn = document.getElementById('lightboxDownload');
      const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      if(prevBtn) {
        // Su desktop: mostra se ci sono piÃ¹ foto. Su mobile: sempre nascosto (usa swipe)
        prevBtn.style.display = (!isMobileDevice && allPhotos.length > 1) ? 'flex' : 'none';
      }
      if(nextBtn) {
        // Su desktop: mostra se ci sono piÃ¹ foto. Su mobile: sempre nascosto (usa swipe)
        nextBtn.style.display = (!isMobileDevice && allPhotos.length > 1) ? 'flex' : 'none';
      }
      
      // Gestione download, istruzioni iOS e CTA carrello
      const iosInstruction = document.getElementById('lightboxIOSInstruction');
      const cartCTA = document.getElementById('lightboxCartCTA');
      const addCartBtnLightbox = document.getElementById('lightboxAddCartBtn');
      
      if(isPaid) {
        // Foto pagata: PERMETTI long-press iOS per salvare
        // Rimuovi blocchi CSS che impediscono long-press
        if(lightboxImage) {
          lightboxImage.style.webkitTouchCallout = 'default';
          lightboxImage.style.webkitUserSelect = 'auto';
          lightboxImage.style.userSelect = 'auto';
        }
        
        // Foto pagata: mostra download/istruzioni iOS come prima
        if(cartCTA) {
          cartCTA.style.display = 'none';
        }
        if(isIOS()) {
          if(downloadBtn) {
            downloadBtn.style.display = 'none';
          }
          if(iosInstruction) {
            iosInstruction.style.display = 'block';
          }
        } else {
          if(downloadBtn) {
            downloadBtn.style.display = 'block';
            downloadBtn.onclick = () => downloadPhoto(photo.photo_id);
          }
          if(iosInstruction) {
            iosInstruction.style.display = 'none';
          }
        }
      } else {
        // Foto NON pagata: BLOCCA long-press (watermark)
        if(lightboxImage) {
          lightboxImage.style.webkitTouchCallout = 'none';
          lightboxImage.style.webkitUserSelect = 'none';
          lightboxImage.style.userSelect = 'none';
        }
        // Foto NON pagata: mostra CTA carrello (pre-acquisto)
        if(downloadBtn) {
          downloadBtn.style.display = 'none';
        }
        if(iosInstruction) {
          iosInstruction.style.display = 'none';
        }
        if(cartCTA) {
          cartCTA.style.display = 'block';
          // Verifica se Ã¨ giÃ  nel carrello
          const isInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photo.photo_id);
          if(addCartBtnLightbox) {
            if(isInCart) {
              addCartBtnLightbox.textContent = t('lightbox_remove_from_cart');
              addCartBtnLightbox.style.background = '#ff4444';
              addCartBtnLightbox.style.color = 'white';
              addCartBtnLightbox.style.boxShadow = '0 2px 8px rgba(255, 68, 68, 0.4)';
            } else {
              addCartBtnLightbox.textContent = t('lightbox_add_to_cart');
              addCartBtnLightbox.style.background = 'linear-gradient(135deg, #7b74ff 0%, #5f58ff 100%)';
              addCartBtnLightbox.style.color = 'white';
              addCartBtnLightbox.style.boxShadow = '0 2px 8px rgba(95, 88, 255, 0.3)';
            }
            addCartBtnLightbox.onclick = (e) => {
              e.stopPropagation();
              toggleCart(photo.photo_id, null);
              // Aggiorna il bottone dopo toggle
              setTimeout(() => {
                const newIsInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photo.photo_id);
                if(addCartBtnLightbox) {
                  if(newIsInCart) {
                    addCartBtnLightbox.textContent = t('lightbox_remove_from_cart');
                    addCartBtnLightbox.style.background = '#ff4444';
                    addCartBtnLightbox.style.color = 'white';
                    addCartBtnLightbox.style.boxShadow = '0 2px 8px rgba(255, 68, 68, 0.4)';
                  } else {
                    addCartBtnLightbox.textContent = t('lightbox_add_to_cart');
                    addCartBtnLightbox.style.background = 'linear-gradient(135deg, #7b74ff 0%, #5f58ff 100%)';
                    addCartBtnLightbox.style.color = 'white';
                    addCartBtnLightbox.style.boxShadow = '0 2px 8px rgba(95, 88, 255, 0.3)';
                  }
                }
              }, 100);
            };
          }
        }
      }
    }
    
    function updateLightboxCounter() {
      if(photoCounter) {
        photoCounter.textContent = `${currentPhotoIndex + 1}/${allPhotos.length}`;
      }
    }
    
    function nextPhoto() {
      if(!lightboxImage) return;
      if(currentPhotoIndex < allPhotos.length - 1) {
        currentPhotoIndex++;
        const photo = allPhotos[currentPhotoIndex];
        // Usa paid_url per foto pagate (senza watermark), wm_url per non pagate
        const isPaid = paidPhotos.includes(photo.photo_id) || photo.paid === true;
        let photoUrl;
        if(isPaid) {
          // Foto pagata: usa paid_url se disponibile (VELOCITÃ€ MASSIMA: originale R2)
          photoUrl = photo.paid_url || `/photo/${encodeURIComponent(photo.photo_id)}?paid=true`;
          if(userEmail && !photo.paid_url) {
            photoUrl += `&email=${encodeURIComponent(userEmail)}`;
          }
        } else {
          // Foto non pagata: usa wm_url (pre-generato, veloce)
          photoUrl = photo.wm_url || `/photo/${encodeURIComponent(photo.photo_id)}?variant=wm`;
        }
        lightboxImage.src = photoUrl;
        updateLightboxCounter();
        updateDownloadButton(photo.photo_id);
      }
    }
    
    function prevPhoto() {
      if(!lightboxImage) return;
      if(currentPhotoIndex > 0) {
        currentPhotoIndex--;
        const photo = allPhotos[currentPhotoIndex];
        // Usa paid_url per foto pagate (senza watermark), wm_url per non pagate
        const isPaid = paidPhotos.includes(photo.photo_id) || photo.paid === true;
        let photoUrl;
        if(isPaid) {
          // Foto pagata: usa paid_url se disponibile (VELOCITÃ€ MASSIMA: originale R2)
          photoUrl = photo.paid_url || `/photo/${encodeURIComponent(photo.photo_id)}?paid=true`;
          if(userEmail && !photo.paid_url) {
            photoUrl += `&email=${encodeURIComponent(userEmail)}`;
          }
        } else {
          // Foto non pagata: usa wm_url (pre-generato, veloce)
          photoUrl = photo.wm_url || `/photo/${encodeURIComponent(photo.photo_id)}?variant=wm`;
        }
        lightboxImage.src = photoUrl;
        updateLightboxCounter();
        updateDownloadButton(photo.photo_id);
      }
    }
    
    function updateDownloadButton(photoId) {
      const downloadBtn = document.getElementById('lightboxDownload');
      const iosInstruction = document.getElementById('lightboxIOSInstruction');
      const cartCTA = document.getElementById('lightboxCartCTA');
      const addCartBtnLightbox = document.getElementById('lightboxAddCartBtn');
      const isPaid = paidPhotos.includes(photoId);
      
      if(isPaid) {
        // Foto pagata: PERMETTI long-press iOS per salvare
        if(lightboxImage) {
          lightboxImage.style.webkitTouchCallout = 'default';
          lightboxImage.style.webkitUserSelect = 'auto';
          lightboxImage.style.userSelect = 'auto';
        }
        
        // Foto pagata: mostra download/istruzioni iOS
        if(cartCTA) {
          cartCTA.style.display = 'none';
        }
        if(isIOS()) {
          if(downloadBtn) {
            downloadBtn.style.display = 'none';
          }
          if(iosInstruction) {
            iosInstruction.style.display = 'block';
          }
        } else {
          if(downloadBtn) {
            downloadBtn.style.display = 'block';
            downloadBtn.onclick = () => downloadPhoto(photoId);
          }
          if(iosInstruction) {
            iosInstruction.style.display = 'none';
          }
        }
      } else {
        // Foto NON pagata: BLOCCA long-press (watermark)
        if(lightboxImage) {
          lightboxImage.style.webkitTouchCallout = 'none';
          lightboxImage.style.webkitUserSelect = 'none';
          lightboxImage.style.userSelect = 'none';
        }
        
        // Foto NON pagata: mostra CTA carrello
        if(downloadBtn) {
          downloadBtn.style.display = 'none';
        }
        if(iosInstruction) {
          iosInstruction.style.display = 'none';
        }
        if(cartCTA) {
          cartCTA.style.display = 'block';
          const isInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photoId);
          if(addCartBtnLightbox) {
            if(isInCart) {
              addCartBtnLightbox.textContent = t('lightbox_remove_from_cart');
              addCartBtnLightbox.style.background = '#ff4444';
              addCartBtnLightbox.style.color = 'white';
              addCartBtnLightbox.style.boxShadow = '0 2px 8px rgba(255, 68, 68, 0.4)';
            } else {
              addCartBtnLightbox.textContent = t('lightbox_add_to_cart');
              addCartBtnLightbox.style.background = 'linear-gradient(135deg, #7b74ff 0%, #5f58ff 100%)';
              addCartBtnLightbox.style.color = 'white';
              addCartBtnLightbox.style.boxShadow = '0 2px 8px rgba(95, 88, 255, 0.3)';
            }
          }
        }
      }
    }
    
    // Rileva se Ã¨ iOS
    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    }
    
    // Rileva se Ã¨ Android
    function isAndroid() {
      return /Android/i.test(navigator.userAgent);
    }
    
    async function downloadPhoto(photoId) {
      try {
        // Verifica che la foto sia pagata
        if(!paidPhotos.includes(photoId)) {
          alert("This photo has not been paid yet");
      return;
    }

        // Passa SEMPRE email per verifica backend (obbligatorio per foto pagate)
        if(!userEmail) {
          // Stateless: userEmail non persistente
        }
        
        if(!userEmail) {
          alert("Email not found. Please log in again.");
        return;
      }

        const filename = `${photoId}.jpg`;
        
        // Costruisci URL con paid=true, email e download=true per verifica backend e forzare download
        const photoUrl = `/photo/${encodeURIComponent(photoId)}?paid=true&email=${encodeURIComponent(userEmail)}&download=true`;
        
        // Su iOS: usa approccio semplice e diretto
        if(isIOS()) {
          try {
            // Prova prima con Web Share API (salva direttamente nella galleria)
            const response = await fetch(photoUrl);
            if(!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const blob = await response.blob();
            const file = new File([blob], filename, { type: 'image/jpeg' });
            
            if(navigator.share && navigator.canShare) {
              try {
                if(navigator.canShare({ files: [file] })) {
                  await navigator.share({
                    files: [file],
                    title: 'Salva foto',
                    text: 'Salva questa foto nella galleria'
                  });
                  return;
                }
              } catch(shareErr) {
                console.log('Web Share error:', shareErr);
              }
            }
          } catch(fetchError) {
            console.error('Errore fetch:', fetchError);
            alert('Error loading photo. Please try again.');
        return;
      }

          // Fallback: apri l'immagine direttamente usando l'URL
          // Su iOS Safari, questo permette all'utente di fare long-press e salvare
          const imgWindow = window.open(photoUrl, '_blank');
          
          if(imgWindow) {
            // Mostra istruzioni dopo un breve delay
            setTimeout(() => {
              alert('ðŸ“± Touch and hold the image, then select "Save to Photos" to save it to your gallery.');
            }, 800);
          } else {
            // Se popup bloccato, mostra istruzioni alternative
            alert('ðŸ“± Popup blocked. To save the photo:\n1. Touch and hold the image\n2. Select "Save to Photos"\n\nOr open this page in Safari.');
          }
        }
        // Su Android: download diretto (salva automaticamente nella galleria)
        else if(isAndroid()) {
          // photoUrl giÃ  contiene download=true
          const link = document.createElement('a');
          link.href = photoUrl;
          link.download = filename;
          link.style.display = 'none';
          link.target = '_self';
          document.body.appendChild(link);
          link.click();
          
          setTimeout(() => {
            document.body.removeChild(link);
          }, 1000);
        }
        // Desktop: download normale
        else {
          // photoUrl giÃ  contiene download=true
          const response = await fetch(photoUrl);
          if(!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const blob = await response.blob();
          const blobUrl = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = blobUrl;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(blobUrl);
        }
      } catch(e) {
        console.error("Error downloading photo:", e);
        alert("Error downloading photo. Please try again.");
      }
    }

    function toggleCart(photoId, buttonElement) {
        // Previeni l'aggiunta di foto pagate al carrello
        if(paidPhotos.includes(photoId)) {
          console.warn(`Photo ${photoId} is already paid, cannot add to cart`);
          alert("This photo has already been purchased. You can download it by clicking 'Download'.");
          return;
        }
        
        // Verifica se la foto Ã¨ giÃ  nel carrello
        const isInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photoId);
        
        if(isInCart) {
        // Rimuovi dal carrello (istantaneo)
        removeFromCart(photoId);
        } else {
        // Aggiungi al carrello (istantaneo)
        addToCart(photoId);
      }
      
      // Aggiorna lo stato visivo del pulsante
          const btn = buttonElement || document.querySelector(`.add-to-cart-btn[data-photo-id="${photoId}"]`);
          if(btn) {
            if(isInCart) {
              // Foto rimossa dal carrello
              btn.classList.remove('is-added');
              btn.disabled = false;
              btn.setAttribute('aria-label', 'Add to cart');
            } else {
              // Foto aggiunta al carrello
              btn.classList.add('is-added');
          btn.disabled = false; // Non disabilitare, permettere rimozione
          btn.setAttribute('aria-label', 'Rimuovi dal carrello');
            }
          }
          
          // Aggiorna anche il bottone nel viewer se Ã¨ aperto
          const addCartBtnLightbox = document.getElementById('lightboxAddCartBtn');
          if(addCartBtnLightbox && photoLightbox && photoLightbox.classList.contains('active')) {
            const currentPhoto = allPhotos[currentPhotoIndex];
            if(currentPhoto && currentPhoto.photo_id === photoId) {
              const newIsInCart = currentCart.photo_ids && currentCart.photo_ids.includes(photoId);
              if(newIsInCart) {
                addCartBtnLightbox.textContent = t('lightbox_remove_from_cart');
                addCartBtnLightbox.style.background = '#ff4444';
                addCartBtnLightbox.style.color = 'white';
              } else {
                addCartBtnLightbox.textContent = t('lightbox_add_to_cart');
                addCartBtnLightbox.style.background = 'white';
                addCartBtnLightbox.style.color = 'rgba(123, 116, 255, 1)';
              }
            }
      }
    }
    
    function addToCart(photoId) {
      // Previeni l'aggiunta di foto pagate al carrello
      if(paidPhotos.includes(photoId)) {
        console.warn(`Photo ${photoId} is already paid, cannot add to cart`);
        return;
      }
      
      // Aggiungi localmente (istantaneo)
      const updated = addToCartLocal(photoId);
      syncCart();
      
      // Aggiorna UI immediatamente
          const btn = document.querySelector(`.add-to-cart-btn[data-photo-id="${photoId}"]`);
          if(btn && !btn.classList.contains('is-added')) {
            btn.classList.add('is-added');
            btn.setAttribute('aria-label', 'Rimuovi dal carrello');
            // Aggiungi classe selected alla card
            const card = btn.closest('.album-photo');
            if(card) card.classList.add('selected');
      }
    }

    function updateCart() {
      // Aggiorna solo se gli elementi esistono (sicuro anche se chiamato prima del DOM)
      try {
        if(albumCartCount) {
          albumCartCount.textContent = currentCart.count || 0;
        }
        if(albumCartPrice) {
          albumCartPrice.textContent = `â‚¬${(currentCart.price_euros || 0).toFixed(2)}`;
        }
        // buyAllPrice rimosso insieme al pulsante buyAllBtn
        if(buyAllPrice) {
          buyAllPrice.textContent = `â‚¬${(currentCart.price_euros || 0).toFixed(2)}`;
        }
      } catch(e) {
        // Ignora errori se elementi non esistono ancora
      }
    }
    
    function updateCartModal() {
      const cartItems = document.getElementById('cartItems');
      const cartTotal = document.getElementById('cartTotal');
      const checkoutBtn = document.getElementById('checkoutBtn');
      const clearCartBtn = document.getElementById('clearCartBtn');
      
      if(!cartItems || !cartTotal || !checkoutBtn) {
        console.warn('Cart modal elements not found');
        return;
      }
      
      if(currentCart.photo_ids && currentCart.photo_ids.length > 0) {
        cartItems.innerHTML = '';
        currentCart.photo_ids.forEach(photoId => {
          const div = document.createElement('div');
          div.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.1);';
          div.innerHTML = `
            <div style="display: flex; align-items: center; gap: 12px;">
              <img src="/photo/${encodeURIComponent(photoId)}?paid=false" style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px;" />
              <span style="font-size: 14px; color: var(--text-light);">${photoId}</span>
  </div>
            <button onclick="removeFromCart('${photoId}')" style="background: #ff4444; color: #fff; border: none; border-radius: 6px; padding: 6px 12px; cursor: pointer; font-size: 14px;">Rimuovi</button>
          `;
          cartItems.appendChild(div);
        });
        cartTotal.textContent = `â‚¬${currentCart.price_euros.toFixed(2)}`;
        checkoutBtn.disabled = false;
        if(clearCartBtn) {
          clearCartBtn.disabled = false;
          clearCartBtn.style.opacity = '1';
        }
      } else {
        cartItems.innerHTML = '<p style="text-align: center; color: var(--text-muted);">Il carrello Ã¨ vuoto</p>';
        cartTotal.textContent = "â‚¬0.00";
        checkoutBtn.disabled = true;
        if(clearCartBtn) {
          clearCartBtn.disabled = true;
          clearCartBtn.style.opacity = '0.5';
        }
      }
    }
    
    function removeFromCart(photoId) {
      // Rimuovi localmente (istantaneo)
      const updated = removeFromCartLocal(photoId);
      syncCart();
      updateNudgeBar(); // Aggiorna nudge bar quando si rimuove foto
      
      // Aggiorna UI immediatamente
          const btn = document.querySelector(`.add-to-cart-btn[data-photo-id="${photoId}"]`);
          if(btn && btn.classList.contains('is-added')) {
            btn.classList.remove('is-added');
            btn.setAttribute('aria-label', 'Aggiungi al carrello');
            // Rimuovi classe selected dalla card
            const card = btn.closest('.album-photo');
            if(card) card.classList.remove('selected');
      }
    }
    
    function clearCart() {
      // Svuota completamente il carrello
      const photoIdsToRemove = [...cartPhotoIds];
      cartPhotoIds = [];
      syncCart();
      updateNudgeBar();
      
      // Aggiorna UI: rimuovi classe is-added da tutti i pulsanti
      photoIdsToRemove.forEach(photoId => {
        const btn = document.querySelector(`.add-to-cart-btn[data-photo-id="${photoId}"]`);
        if(btn && btn.classList.contains('is-added')) {
          btn.classList.remove('is-added');
          btn.setAttribute('aria-label', 'Aggiungi al carrello');
          const card = btn.closest('.album-photo');
          if(card) card.classList.remove('selected');
        }
      });
      
      // Aggiorna anche il bottone nel viewer se Ã¨ aperto
      const addCartBtnLightbox = document.getElementById('lightboxAddCartBtn');
      if(addCartBtnLightbox) {
        addCartBtnLightbox.textContent = t('lightbox_add_to_cart');
        addCartBtnLightbox.style.background = 'linear-gradient(135deg, #7b74ff 0%, #5f58ff 100%)';
        addCartBtnLightbox.style.color = 'white';
        addCartBtnLightbox.style.boxShadow = '0 2px 8px rgba(95, 88, 255, 0.3)';
      }
      
      console.log('[CART] Cart cleared');
    }

    // Funzione unica per calcolare prezzo in euro (number)
    function computePrice(count) {
      if(count <= 0) return 0;
      if(count === 1) return 18;
      if(count === 2) return 36;
      if(count === 3) return 39;
      if(count === 4) return 42;
      if(count === 5) return 45;
      if(count === 6) return 47;
      // Dalla 7Âª in poi: +â‚¬1.00 per ogni foto aggiunta
      // Formula: 47 + (count - 6) * 1 = 41 + count
      if(count >= 7) return 47 + (count - 6) * 1;
      return 0;
    }
    
    // Mantieni calculatePrice per compatibilitÃ  (ritorna centesimi)
    function calculatePrice(count) {
      return Math.round(computePrice(count) * 100);
    }
    
    // Logica nudge: trova il prossimo target conveniente
    function getNextOffer(k, N) {
      if(N <= 0) return null;
      
      const targets = [3, 6, 9, 12];
      
      // Se k >= 12 e N > k, target = N (completa album)
      if(k >= 12 && N > k) {
        return {
          target: N,
          add: N - k,
          delta: computePrice(N) - computePrice(k)
        };
      }
      
      // Trova il primo target > k e <= N
      for(const target of targets) {
        if(target > k && target <= N) {
          return {
            target: target,
            add: target - k,
            delta: computePrice(target) - computePrice(k)
          };
        }
      }
      
      // Nessun target disponibile
      return null;
    }
    
    // Aggiorna sticky bar con offerta "Prendile tutte"
    // Funzioni utility per gestire visibilitÃ  banner in base al tab attivo
    function hideStickyOfferBar() {
      const bar = document.getElementById('stickyOfferBar');
      if (!bar) return;
      bar.classList.remove('active');
      bar.style.display = 'none';
    }
    
    function hideNudgeBar() {
      const n = document.getElementById('nudgeBar');
      if (!n) return;
      n.classList.remove('active');
      n.style.display = 'none';
    }
    
    function showStickyOfferBarIfAllowed() {
      // Non forziamo nulla: rimetti display vuoto e lasci che la logica esistente decida se attivarlo
      const bar = document.getElementById('stickyOfferBar');
      if (!bar) return;
      bar.style.display = '';
      // Richiama updateStickyAllOffer per aggiornare i testi e attivare se necessario
      updateStickyAllOffer();
    }
    
    function showNudgeBarIfAllowed() {
      const n = document.getElementById('nudgeBar');
      if (!n) return;
      n.style.display = '';
    }
    
    function updateStickyAllOffer() {
      const bar = document.getElementById('stickyOfferBar');
      const foundEl = document.getElementById('stickyOfferFoundText');
      const ctaEl = document.getElementById('stickyOfferCtaText');
      if(!bar || !foundEl || !ctaEl) return;

      // SOLO album grid, MAI listino
      const albumScreen = document.getElementById('albumScreen');
      const pricesList = document.getElementById('pricesList');
      const onAlbum = albumScreen && albumScreen.classList.contains('active');
      const onPrices = pricesList && pricesList.classList.contains('active');

      if(!onAlbum || onPrices || !allPhotos || allPhotos.length <= 0){
        bar.classList.remove('active');
        bar.style.display = 'none';
        return;
      }

      const totalPhotos = allPhotos.length;
      const priceEuros = computePrice(totalPhotos);
      const priceStr = Number(priceEuros || 0).toFixed(0);

      // Testi tradotti
      foundEl.textContent = tr('sticky_found_photos', { count: totalPhotos });
      ctaEl.textContent = tr('sticky_buy_all_for', { price: priceStr });

      // Attiva il banner: aggiungi classe active e imposta display
      bar.classList.add('active');
      bar.style.display = 'flex'; // Mostra esplicitamente il banner
    }
    
    function bindStickyOfferClick(){
      const bar = document.getElementById('stickyOfferBar');
      if(!bar) return;
      if(bar.__bound) return;
      bar.__bound = true;

      bar.addEventListener('click', () => {
        const cartModal = document.getElementById('cartModal');
        if(cartModal) {
          cartModal.classList.add('active');
          if(typeof updateCartModal === 'function') {
            updateCartModal();
          }
        }
      });
    }
    
    // Formatta numero con virgola italiana, max 2 decimali, rimuove zeri inutili
    function formatPrice(price) {
      const parts = price.toFixed(2).split('.');
      const integer = parts[0];
      let decimals = parts[1];
      // Rimuovi zeri finali
      decimals = decimals.replace(/0+$/, '');
      if(decimals === '') {
        return integer;
      }
      return integer + ',' + decimals;
    }
    
    // Aggiorna nudge bar con suggerimento upgrade
    function updateNudgeBar(forcePop = false) {
      // Blocco di sicurezza: nascondi se siamo nel tab listino prezzi
      const pricesTabIsActive = document.getElementById('pricesTab')?.classList.contains('active');
      if(pricesTabIsActive) {
        hideNudgeBar();
        return;
      }
      
      const nudgeBar = document.getElementById('nudgeBar');
      const nudgeLine1 = document.getElementById('nudgeLine1');
      const nudgeLine2 = document.getElementById('nudgeLine2');
      const nudgeCheckoutBtn = document.getElementById('nudgeCheckoutBtn');
      
      if(!nudgeBar || !nudgeLine1 || !nudgeLine2 || !nudgeCheckoutBtn) return;
      
      const wasVisible = nudgeBar.classList.contains('active');
      
      // Nascondi se non siamo nell'album
      if(currentScreen !== 'album') {
        nudgeBar.classList.remove('active');
        nudgeBar.style.display = 'none';
        updateBottomPadding();
        return;
      }
      
      // Nascondi se il carrello Ã¨ aperto
      const cartModal = document.getElementById('cartModal');
      if(cartModal && cartModal.classList.contains('active')) {
        nudgeBar.classList.remove('active');
        nudgeBar.style.display = 'none';
        updateBottomPadding();
        return;
      }
      
      const k = cartPhotoIds.length;
      const N = allPhotos ? allPhotos.length : 0;
      
      // Se k < 2 => nascondi (0 e 1 foto: MAI)
      if(k < 2 || N <= 0) {
        nudgeBar.classList.remove('active');
        nudgeBar.style.display = 'none';
        updateBottomPadding();
        return;
      }
      
      // Se k >= N: stato tutto selezionato
      if(k >= N) {
        nudgeLine1.textContent = t('nudge_selected_all');
        nudgeLine2.textContent = t('nudge_go_checkout');
        nudgeCheckoutBtn.onclick = () => {
          const cartModal = document.getElementById('cartModal');
          if(cartModal) {
            cartModal.classList.add('active');
            updateCartModal();
            updateNudgeBar(); // Nascondi nudge bar quando si apre il carrello
          }
        };
        nudgeBar.classList.add('active');
        nudgeBar.style.display = 'flex';
        if(forcePop || !wasVisible) {
          nudgeBar.classList.add('pop');
          setTimeout(() => nudgeBar.classList.remove('pop'), 200);
        }
        updateBottomPadding();
        return;
      }
      
      // Se k >= 6 e k < N: messaggio fisso
      if(k >= 6 && k < N) {
        nudgeLine1.textContent = t('nudge_deal_unlocked');
        nudgeLine2.textContent = t('nudge_add_more');
        nudgeCheckoutBtn.onclick = () => {
          const cartModal = document.getElementById('cartModal');
          if(cartModal) {
            cartModal.classList.add('active');
            updateCartModal();
            updateNudgeBar(); // Nascondi nudge bar quando si apre il carrello
          }
        };
        nudgeBar.classList.add('active');
        nudgeBar.style.display = 'flex';
        if(forcePop || !wasVisible) {
          nudgeBar.classList.add('pop');
          setTimeout(() => nudgeBar.classList.remove('pop'), 200);
        }
        updateBottomPadding();
        return;
      }
      
      // Se k < 6: usa logica target (3 e 6) con perEach
      const targets = [3, 6]; // Solo 3 e 6 per k < 6
      let T = null;
      
      // Primo T in targets con T > k e T <= N
      for(const target of targets) {
        if(target > k && target <= N) {
          T = target;
          break;
        }
      }
      
      // Se non esiste target, nascondi
      if(!T) {
        nudgeBar.classList.remove('active');
        nudgeBar.style.display = 'none';
        updateBottomPadding();
        return;
      }
      
      const add = T - k;
      const delta = computePrice(T) - computePrice(k);
      const perEach = delta / add;
      const perEachFormatted = formatPrice(perEach);
      
      // Copy
      if(add === 1) {
        nudgeLine1.textContent = t('nudge_add_one', { price: perEachFormatted });
      } else {
        nudgeLine1.textContent = t('nudge_add_many', { count: add, price: perEachFormatted });
      }
      nudgeLine2.textContent = t('nudge_unlock_package', { count: T });
      
      nudgeCheckoutBtn.onclick = () => {
        const cartModal = document.getElementById('cartModal');
        if(cartModal) {
          cartModal.classList.add('active');
          updateCartModal();
        }
      };
      
      nudgeBar.classList.add('active');
      nudgeBar.style.display = 'flex';
      if(forcePop || !wasVisible) {
        nudgeBar.classList.add('pop');
        setTimeout(() => nudgeBar.classList.remove('pop'), 200);
      }
      updateBottomPadding();
    }
    
    // Aggiorna padding-bottom della griglia in base all'altezza dei banner
    function updateBottomPadding() {
      const stickyBar = document.getElementById('stickyOfferBar');
      const nudgeBar = document.getElementById('nudgeBar');
      
      let sum = 0;
      
      // Altezza sticky bar se visibile
      if(stickyBar && stickyBar.classList.contains('active') && stickyBar.style.display !== 'none') {
        const stickyRect = stickyBar.getBoundingClientRect();
        if(stickyRect.height > 0) {
          sum += stickyRect.height;
        }
      }
      
      // Altezza nudge bar se visibile + gap
      if(nudgeBar && nudgeBar.classList.contains('active') && nudgeBar.style.display !== 'none') {
        const nudgeRect = nudgeBar.getBoundingClientRect();
        if(nudgeRect.height > 0) {
          sum += nudgeRect.height + 16; // gap 16px
        }
      }
      
      // Safe area + margine extra
      sum += 24; // margine extra
      
      // Imposta variabile CSS
      document.documentElement.style.setProperty('--bottom-bars', `${sum}px`);
    }
    
    // Checkout per tutte le foto (indipendente dal carrello)
    async function startCheckoutForAllPhotos() {
      if(!allPhotos || allPhotos.length === 0) {
        alert('Nessuna foto disponibile!');
        return;
      }
      
      const allPhotoIds = allPhotos.map(p => p.photo_id || p.r2_key).filter(Boolean);
      if(allPhotoIds.length === 0) {
        alert('Nessuna foto valida disponibile!');
        return;
      }
      
      // Filtra foto giÃ  pagate
      const paidPhotoIdsSet = new Set(paidPhotos);
      const unpaidPhotoIds = allPhotoIds.filter(photoId => !paidPhotoIdsSet.has(photoId));
      
      if(unpaidPhotoIds.length === 0) {
        alert('Tutte le foto sono giÃ  state acquistate!');
        return;
      }
      
      const totalCount = unpaidPhotoIds.length;
      const totalPriceEuros = computePrice(totalCount);
      const totalPriceCents = Math.round(totalPriceEuros * 100);
      
      try {
        const res = await fetch(`/create_checkout`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            photo_ids: unpaidPhotoIds,
            price_cents: totalPriceCents,
            currency: 'eur'
          })
        });
        
        if(!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        
        const data = await res.json();
        if(data.checkout_url) {
          window.location.href = data.checkout_url;
        } else {
          throw new Error('No checkout_url in response');
        }
      } catch(e) {
        console.error('Checkout error:', e);
        alert('Errore durante il checkout. Riprova.');
      }
    }

    async function checkout() {
      // Usa carrello in memoria (non persistente)
      const photoIds = cartPhotoIds;
      
      if(!photoIds || photoIds.length === 0) {
        alert(t('cart_empty'));
        return;
      }
      
      // FILTRA FOTO PAGATE: rimuovi foto giÃ  pagate dal carrello prima del checkout
      let unpaidPhotoIds = photoIds;
      if(paidPhotos.length > 0) {
        const paidPhotoIdsSet = new Set(paidPhotos);
        unpaidPhotoIds = photoIds.filter(photoId => !paidPhotoIdsSet.has(photoId));
        
        if(unpaidPhotoIds.length !== photoIds.length) {
          console.log(`Rimosse ${photoIds.length - unpaidPhotoIds.length} foto pagate dal carrello prima del checkout`);
          
          // Aggiorna carrello in memoria rimuovendo foto pagate
          cartPhotoIds = unpaidPhotoIds;
          syncCart();
            
            // Se carrello vuoto dopo filtro, avvisa
          if(unpaidPhotoIds.length === 0) {
              alert("All selected photos have already been purchased. You can download them from the 'My Photos' page.");
        return;
          }
        }
      }
      
      const checkoutBtn = document.getElementById("checkoutBtn");
      if(checkoutBtn) {
        checkoutBtn.disabled = true;
        checkoutBtn.textContent = t('cart_loading');
      }
      
      try {
        console.log("Inizio checkout (stateless):", { photoCount: unpaidPhotoIds.length });
        
        // Stateless: usa /create_checkout con photo_ids dal localStorage
        const priceCents = calculatePrice(unpaidPhotoIds.length);
        
        let res = await fetch(`/create_checkout`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            photo_ids: unpaidPhotoIds,
            price_cents: priceCents,
            currency: "eur"
          })
        });
        
        console.log("Checkout response status:", res.status);
        
        // Se Stripe non Ã¨ configurato (503), mostra errore
        if(res.status === 503) {
          throw new Error("Stripe not configured. Please contact support.");
        }
        
        if(!res.ok) {
          const errorText = await res.text();
          console.error("Checkout error response:", errorText);
          let errorData;
          try {
            errorData = JSON.parse(errorText);
          } catch(e) {
            errorData = { detail: errorText || `Errore ${res.status}` };
          }
          throw new Error(errorData.detail || `Errore ${res.status}: ${res.statusText}`);
        }
        
        const data = await res.json();
        console.log("Checkout data:", data);
        
        // Gestisci sia checkout_url che url (per test mode)
        const redirectUrl = data.checkout_url || data.url;
        if(redirectUrl) {
          console.log("Redirecting to checkout:", redirectUrl);
          window.location.href = redirectUrl;
        } else {
          throw new Error("URL di checkout non ricevuto dal server");
        }
      } catch(err) {
        console.error("Checkout error:", err);
        alert("Error during payment: " + err.message + "\n\nCheck the console for details.");
        if(checkoutBtn) {
          checkoutBtn.disabled = false;
          checkoutBtn.textContent = t('cart_go_payment');
        }
      }
    }
    
    async function checkoutAllPhotos() {
      // Checkout per TUTTE le foto: ignora il carrello e usa tutte le foto trovate
      if(!allPhotos || allPhotos.length === 0) {
        alert("No photos available!");
    return;
  }

      // Crea un carrello temporaneo con TUTTE le foto
      const allPhotoIds = allPhotos.map(photo => photo.photo_id);
      const totalCount = allPhotoIds.length;
      const totalPriceCents = calculatePrice(totalCount);
      const totalPriceEuros = (totalPriceCents / 100).toFixed(2);
      
      // Aggiungi tutte le foto al carrello temporaneamente per il checkout
      // Usiamo una sessione separata o aggiungiamo direttamente tutte le foto
      try {
        // Prima, aggiungi tutte le foto al carrello (sovrascrive il carrello corrente)
        // Oppure crea una nuova sessione per questo checkout
        const checkoutSessionId = "checkout_all_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
        
        // Stateless: usa /create_checkout con photo_ids nel body
        const res = await fetch(`/create_checkout`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            photo_ids: allPhotoIds,
            price_cents: totalPriceCents,
            currency: "eur"
          })
        });
        
        const data = await res.json();
        if(data.checkout_url) {
          window.location.href = data.checkout_url;
        } else {
          alert("Error during checkout. Please try again.");
        }
      } catch(err) {
        console.error("Errore checkout tutte le foto:", err);
        alert("Error during checkout. Please try again.");
      }
    }

    // Lightbox controls (solo se elementi esistono)
    const lightboxClose = document.getElementById('lightboxClose');
    const lightboxPrev = document.getElementById('lightboxPrev');
    const lightboxNext = document.getElementById('lightboxNext');
    
    if(lightboxClose && photoLightbox) {
      lightboxClose.addEventListener('click', () => {
        photoLightbox.classList.remove('active');
      });
    }
    
    if(lightboxPrev) {
      lightboxPrev.addEventListener('click', prevPhoto);
    }
    
    if(lightboxNext) {
      lightboxNext.addEventListener('click', nextPhoto);
    }
    
    // Navigazione con tastiera
    document.addEventListener('keydown', (e) => {
      if(photoLightbox && photoLightbox.classList.contains('active')) {
        if(e.key === 'ArrowLeft') prevPhoto();
        if(e.key === 'ArrowRight') nextPhoto();
        if(e.key === 'Escape') photoLightbox.classList.remove('active');
      }
    });

    if(photoLightbox) {
      photoLightbox.addEventListener('click', (e) => {
        // Chiudi solo se si clicca sullo sfondo (photoLightbox stesso o il div container interno)
        // NON chiudere se si clicca sull'immagine, sui pulsanti o sulle istruzioni
        const containerDiv = photoLightbox.querySelector('div');
        if(e.target === photoLightbox || (e.target === containerDiv && e.target.tagName === 'DIV')) {
          photoLightbox.classList.remove('active');
        }
      });
      
      // Swipe navigation per mobile/tablet (solo orizzontale)
      const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      if(isMobileDevice && lightboxImage) {
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 50; // Minimo 50px per considerare uno swipe
        
        lightboxImage.addEventListener('touchstart', (e) => {
          touchStartX = e.changedTouches[0].screenX;
          touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });
        
        lightboxImage.addEventListener('touchend', (e) => {
          touchEndX = e.changedTouches[0].screenX;
          touchEndY = e.changedTouches[0].screenY;
          
          const deltaX = touchEndX - touchStartX;
          const deltaY = Math.abs(touchEndY - touchStartY);
          const absDeltaX = Math.abs(deltaX);
          
          // Solo swipe orizzontale: deltaX deve essere maggiore di deltaY (swipe piÃ¹ orizzontale che verticale)
          // E deve superare la soglia minima
          if(absDeltaX > minSwipeDistance && absDeltaX > deltaY) {
            if(deltaX > 0) {
              // Swipe a destra â†’ foto precedente
              prevPhoto();
            } else {
              // Swipe a sinistra â†’ foto successiva
              nextPhoto();
            }
          }
        }, { passive: true });
      }
    }
    
    // Blocca salvataggio foto NON pagate (solo se lightboxImage esiste)
    if(lightboxImage) {
      lightboxImage.addEventListener('contextmenu', (e) => {
        // Verifica se la foto Ã¨ pagata controllando se il lightbox mostra CTA carrello
        const cartCTA = document.getElementById('lightboxCartCTA');
        if(cartCTA && cartCTA.style.display !== 'none') {
          // Foto NON pagata: blocca
          e.preventDefault();
          return false;
        }
        // Foto pagata: permetti (non fare preventDefault)
      });
      
      lightboxImage.addEventListener('dragstart', (e) => {
        // Blocca drag solo per foto non pagate
        const cartCTA = document.getElementById('lightboxCartCTA');
        if(cartCTA && cartCTA.style.display !== 'none') {
          e.preventDefault();
          return false;
        }
      });
    }
    

    // Blocca long-press e salvataggio pre-acquisto (SOLO in index.html, NON in /my-photos)
    // Verifica che non siamo nella pagina post-acquisto
    if(!window.location.pathname.includes('/my-photos')) {
      // Blocca menu contestuale (long-press su immagini) SOLO per foto NON pagate
      document.addEventListener('contextmenu', (e) => {
        if (e.target && e.target.tagName === 'IMG') {
          // Se Ã¨ l'immagine nel lightbox, verifica se Ã¨ pagata
          if(e.target.id === 'lightboxImage') {
            const cartCTA = document.getElementById('lightboxCartCTA');
            // Se CTA carrello Ã¨ visibile, la foto NON Ã¨ pagata -> blocca
            if(cartCTA && cartCTA.style.display !== 'none') {
              e.preventDefault();
              return false;
            }
            // Se CTA carrello Ã¨ nascosta, la foto Ã¨ pagata -> PERMETTI (non bloccare)
            return;
          }
          // Per immagini nella griglia (non pagate), blocca sempre
          if(e.target.closest('.album-photo')) {
            e.preventDefault();
            return false;
          }
        }
      }, { passive: false });
      
      // Blocca drag (long-press drag su immagini) SOLO per foto NON pagate
      document.addEventListener('dragstart', (e) => {
        if (e.target && e.target.tagName === 'IMG') {
          if(e.target.id === 'lightboxImage') {
            const cartCTA = document.getElementById('lightboxCartCTA');
            if(cartCTA && cartCTA.style.display !== 'none') {
              e.preventDefault();
              return false;
            }
            return;
          }
          if(e.target.closest('.album-photo')) {
            e.preventDefault();
            return false;
          }
        }
      }, { passive: false });
      
      // Blocca anche select (doppio tap su iOS) SOLO per foto NON pagate
      document.addEventListener('selectstart', (e) => {
        if (e.target && e.target.tagName === 'IMG') {
          if(e.target.id === 'lightboxImage') {
            const cartCTA = document.getElementById('lightboxCartCTA');
            if(cartCTA && cartCTA.style.display !== 'none') {
              e.preventDefault();
              return false;
            }
            return;
          }
          if(e.target.closest('.album-photo')) {
            e.preventDefault();
            return false;
          }
        }
      }, { passive: false });
    }

    // Boot
    window.addEventListener('load', () => {
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("This browser does not support the camera.");
      }
    });
  </script>
  
  <!-- Deal Unlocked Modal -->
  <div id="dealModal" class="deal-modal">
    <div class="deal-modal-backdrop"></div>
    <div class="deal-modal-card" role="dialog" aria-modal="true" aria-label="Deal unlocked">
      <div class="deal-burst" aria-hidden="true"></div>
      <div class="deal-title" data-i18n="deal_title">Complimenti! Hai sbloccato il vero affare</div>
      <div class="deal-subtitle" data-i18n="deal_subtitle">Da adesso in poi ogni foto costa â‚¬1.00</div>
      <button id="dealContinueBtn" class="deal-continue-btn" type="button" data-i18n="deal_continue">Continua la selezione</button>
    </div>
  </div>
  
  <!-- BUILD ID Badge (NASCOSTO) -->
  <div id="buildIdBadge" style="display: none; position: fixed; bottom: 8px; left: 8px; background: rgba(0,0,0,0.8); color: #0f0; font-family: monospace; font-size: 10px; padding: 4px 8px; border-radius: 4px; z-index: 99998; border: 1px solid #0f0;">
    BUILD: 2026-01-23-<span id="buildRandom">a1b2c3</span>
  </div>
  
  <!-- Debug Box Minimo (collassabile) - NASCOSTO -->
  <div id="minimalDebugBox" style="display: none; position: fixed; bottom: 40px; left: 8px; background: rgba(0,0,0,0.9); color: #0f0; font-family: monospace; font-size: 10px; padding: 8px; border-radius: 4px; z-index: 99997; border: 1px solid #0f0; max-width: 300px; max-height: 150px; overflow-y: auto;">
    <div style="font-weight: bold; margin-bottom: 4px; cursor: pointer; color: #0ff;" onclick="toggleMinimalDebug()">â–¼ DEBUG</div>
    <div id="minimalDebugContent" style="display: block; white-space: pre-wrap; word-break: break-all; font-size: 9px;">
      match_selfie: -<br>
      photo_ids: -<br>
      api/photos: -<br>
    </div>
  </div>
  
  <!-- Debug Panel (solo se ?debug=1) -->
  <div id="debugPanel" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.9); color: #0f0; font-family: monospace; font-size: 11px; padding: 10px; max-height: 200px; overflow-y: auto; z-index: 99999; border-top: 2px solid #0f0;">
    <div style="font-weight: bold; margin-bottom: 5px; color: #0ff;">DEBUG MODE</div>
    <div id="debugContent" style="white-space: pre-wrap; word-break: break-all;"></div>
  </div>
  
  <script>
    // Genera random 6 caratteri per BUILD ID
    (function() {
      const chars = '0123456789abcdef';
      let random = '';
      for (let i = 0; i < 6; i++) {
        random += chars[Math.floor(Math.random() * chars.length)];
      }
      const badge = document.getElementById('buildIdBadge');
      if (badge) {
        const span = badge.querySelector('#buildRandom');
        if (span) span.textContent = random;
      }
    })();
    
    // Toggle minimal debug box
    function toggleMinimalDebug() {
      const content = document.getElementById('minimalDebugContent');
      if (content) {
        content.style.display = content.style.display === 'none' ? 'block' : 'none';
      }
    }
    
    // Aggiorna minimal debug box
    function updateMinimalDebug(matchStatus, photoIdsCount, apiPhotosStatus, apiPhotosCount, keyUsed) {
      const content = document.getElementById('minimalDebugContent');
      if (content) {
        let text = `match_selfie: ${matchStatus}`;
        if (photoIdsCount !== undefined) {
          text += ` (${photoIdsCount} photo_ids`;
          if (keyUsed) text += ` via ${keyUsed}`;
          text += `)`;
        }
        text += `\napi/photos: ${apiPhotosStatus}`;
        if (apiPhotosCount !== undefined) {
          text += ` (${apiPhotosCount} photos)`;
        }
        if (photoIdsCount === 0 && keyUsed) {
          text += `\nâš ï¸ No photo_ids found (tried: ${keyUsed})`;
        }
        content.textContent = text;
      }
    }
  </script>
</body>
</html>